/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/startup.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@aurelia/jit/dist/index.umd.js":
/*!*****************************************************!*\
  !*** ./node_modules/@aurelia/jit/dist/index.umd.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! @aurelia/kernel */ \"./node_modules/@aurelia/kernel/dist/index.umd.js\"), __webpack_require__(/*! @aurelia/runtime */ \"./node_modules/@aurelia/runtime/dist/index.umd.js\")) :\n  undefined;\n}(this, (function (exports,kernel,runtime) { 'use strict';\n\n  class AttrSyntax {\n      constructor(rawName, rawValue, target, command) {\n          this.rawName = rawName;\n          this.rawValue = rawValue;\n          this.target = target;\n          this.command = command;\n      }\n  }\n  const IAttributeParser = kernel.DI.createInterface()\n      .withDefault(x => x.singleton(AttributeParser));\n  /*@internal*/\n  class AttributeParser {\n      constructor() {\n          this.cache = {};\n      }\n      parse(name, value) {\n          let target;\n          let command;\n          const existing = this.cache[name];\n          if (existing === undefined) {\n              let lastIndex = 0;\n              target = name;\n              for (let i = 0, ii = name.length; i < ii; ++i) {\n                  if (name.charCodeAt(i) === 46 /* Dot */) {\n                      // set the targetName to only the part that comes before the first dot\n                      if (name === target) {\n                          target = name.slice(0, i);\n                      }\n                      lastIndex = i;\n                  }\n              }\n              command = lastIndex > 0 ? name.slice(lastIndex + 1) : null;\n              this.cache[name] = [target, command];\n          }\n          else {\n              target = existing[0];\n              command = existing[1];\n          }\n          return new AttrSyntax(name, value, target, command && command.length ? command : null);\n      }\n  }\n\n  /*! *****************************************************************************\n  Copyright (c) Microsoft Corporation. All rights reserved.\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n  this file except in compliance with the License. You may obtain a copy of the\n  License at http://www.apache.org/licenses/LICENSE-2.0\n\n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n  MERCHANTABLITY OR NON-INFRINGEMENT.\n\n  See the Apache Version 2.0 License for specific language governing permissions\n  and limitations under the License.\n  ***************************************************************************** */\n\n  function __decorate(decorators, target, key, desc) {\n      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n      if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n      return c > 3 && r && Object.defineProperty(target, key, r), r;\n  }\n\n  // tslint:disable:no-reserved-keywords\n  // tslint:disable:no-any\n  class TextBindingInstruction {\n      constructor(from) {\n          this.from = from;\n          this.type = \"a\" /* textBinding */;\n      }\n  }\n  class InterpolationInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"b\" /* interpolation */;\n      }\n  }\n  class OneTimeBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"c\" /* propertyBinding */;\n          this.oneTime = true;\n          this.mode = runtime.BindingMode.oneTime;\n      }\n  }\n  class ToViewBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"c\" /* propertyBinding */;\n          this.oneTime = false;\n          this.mode = runtime.BindingMode.toView;\n      }\n  }\n  class FromViewBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"c\" /* propertyBinding */;\n          this.oneTime = false;\n          this.mode = runtime.BindingMode.fromView;\n      }\n  }\n  class TwoWayBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"c\" /* propertyBinding */;\n          this.oneTime = false;\n          this.mode = runtime.BindingMode.twoWay;\n      }\n  }\n  class IteratorBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"d\" /* iteratorBinding */;\n      }\n  }\n  class TriggerBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"e\" /* listenerBinding */;\n          this.strategy = runtime.DelegationStrategy.none;\n          this.preventDefault = true;\n      }\n  }\n  class DelegateBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"e\" /* listenerBinding */;\n          this.strategy = runtime.DelegationStrategy.bubbling;\n          this.preventDefault = false;\n      }\n  }\n  class CaptureBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"e\" /* listenerBinding */;\n          this.strategy = runtime.DelegationStrategy.capturing;\n          this.preventDefault = false;\n      }\n  }\n  class CallBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"f\" /* callBinding */;\n      }\n  }\n  class RefBindingInstruction {\n      constructor(from) {\n          this.from = from;\n          this.type = \"g\" /* refBinding */;\n      }\n  }\n  class StylePropertyBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"h\" /* stylePropertyBinding */;\n      }\n  }\n  class SetPropertyInstruction {\n      constructor(value, to) {\n          this.value = value;\n          this.to = to;\n          this.type = \"i\" /* setProperty */;\n      }\n  }\n  class SetAttributeInstruction {\n      constructor(value, to) {\n          this.value = value;\n          this.to = to;\n          this.type = \"j\" /* setAttribute */;\n      }\n  }\n  class HydrateElementInstruction {\n      constructor(res, instructions, parts, contentOverride) {\n          this.res = res;\n          this.instructions = instructions;\n          this.parts = parts;\n          this.contentOverride = contentOverride;\n          this.type = \"k\" /* hydrateElement */;\n      }\n  }\n  class HydrateAttributeInstruction {\n      constructor(res, instructions) {\n          this.res = res;\n          this.instructions = instructions;\n          this.type = \"l\" /* hydrateAttribute */;\n      }\n  }\n  class HydrateTemplateController {\n      constructor(def, res, instructions, link) {\n          this.def = def;\n          this.res = res;\n          this.instructions = instructions;\n          this.link = link;\n          this.type = \"m\" /* hydrateTemplateController */;\n      }\n  }\n  class LetElementInstruction {\n      constructor(instructions, toViewModel) {\n          this.instructions = instructions;\n          this.toViewModel = toViewModel;\n          this.type = \"n\" /* letElement */;\n      }\n  }\n  class LetBindingInstruction {\n      constructor(from, to) {\n          this.from = from;\n          this.to = to;\n          this.type = \"o\" /* letBinding */;\n      }\n  }\n\n  function bindingCommand(nameOrSource) {\n      return function (target) {\n          return BindingCommandResource.define(nameOrSource, target);\n      };\n  }\n  const BindingCommandResource = {\n      name: 'binding-command',\n      keyFrom(name) {\n          return `${this.name}:${name}`;\n      },\n      // tslint:disable-next-line:no-reserved-keywords\n      isType(type) {\n          return type.kind === this;\n      },\n      define(nameOrSource, ctor) {\n          const description = typeof nameOrSource === 'string' ? { name: nameOrSource, target: null } : nameOrSource;\n          const Type = ctor;\n          Type.kind = BindingCommandResource;\n          Type.description = description;\n          Type.register = function (container) {\n              container.register(kernel.Registration.singleton(Type.kind.keyFrom(description.name), Type));\n          };\n          const proto = Type.prototype;\n          proto.handles = proto.handles || defaultHandles;\n          return Type;\n      }\n  };\n  function defaultHandles($symbol) {\n      return !$symbol.isTemplateController;\n  }\n  exports.OneTimeBindingCommand = class OneTimeBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return new OneTimeBindingInstruction(this.parser.parse($symbol.rawValue, 49 /* OneTimeCommand */), $symbol.to);\n      }\n  };\n  exports.OneTimeBindingCommand.inject = [runtime.IExpressionParser];\n  exports.OneTimeBindingCommand = __decorate([\n      bindingCommand('one-time')\n  ], exports.OneTimeBindingCommand);\n  exports.ToViewBindingCommand = class ToViewBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return new ToViewBindingInstruction(this.parser.parse($symbol.rawValue, 50 /* ToViewCommand */), $symbol.to);\n      }\n  };\n  exports.ToViewBindingCommand.inject = [runtime.IExpressionParser];\n  exports.ToViewBindingCommand = __decorate([\n      bindingCommand('to-view')\n  ], exports.ToViewBindingCommand);\n  exports.FromViewBindingCommand = class FromViewBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return new FromViewBindingInstruction(this.parser.parse($symbol.rawValue, 51 /* FromViewCommand */), $symbol.to);\n      }\n  };\n  exports.FromViewBindingCommand.inject = [runtime.IExpressionParser];\n  exports.FromViewBindingCommand = __decorate([\n      bindingCommand('from-view')\n  ], exports.FromViewBindingCommand);\n  exports.TwoWayBindingCommand = class TwoWayBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return new TwoWayBindingInstruction(this.parser.parse($symbol.rawValue, 52 /* TwoWayCommand */), $symbol.to);\n      }\n  };\n  exports.TwoWayBindingCommand.inject = [runtime.IExpressionParser];\n  exports.TwoWayBindingCommand = __decorate([\n      bindingCommand('two-way')\n  ], exports.TwoWayBindingCommand);\n  // Not bothering to throw on non-existing modes, should never happen anyway.\n  // Keeping all array elements of the same type for better optimizeability.\n  const compileMode = ['', '$1', '$2', '', '$4', '', '$6'];\n  exports.DefaultBindingCommand = class DefaultBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return this[compileMode[$symbol.mode]]($symbol);\n      }\n  };\n  exports.DefaultBindingCommand.inject = [runtime.IExpressionParser];\n  exports.DefaultBindingCommand = __decorate([\n      bindingCommand('bind')\n  ], exports.DefaultBindingCommand);\n  exports.DefaultBindingCommand.prototype.$1 = exports.OneTimeBindingCommand.prototype.compile;\n  exports.DefaultBindingCommand.prototype.$2 = exports.ToViewBindingCommand.prototype.compile;\n  exports.DefaultBindingCommand.prototype.$4 = exports.FromViewBindingCommand.prototype.compile;\n  exports.DefaultBindingCommand.prototype.$6 = exports.TwoWayBindingCommand.prototype.compile;\n  exports.TriggerBindingCommand = class TriggerBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return new TriggerBindingInstruction(this.parser.parse($symbol.rawValue, 86 /* TriggerCommand */), $symbol.to);\n      }\n  };\n  exports.TriggerBindingCommand.inject = [runtime.IExpressionParser];\n  exports.TriggerBindingCommand = __decorate([\n      bindingCommand('trigger')\n  ], exports.TriggerBindingCommand);\n  exports.DelegateBindingCommand = class DelegateBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return new DelegateBindingInstruction(this.parser.parse($symbol.rawValue, 88 /* DelegateCommand */), $symbol.to);\n      }\n  };\n  exports.DelegateBindingCommand.inject = [runtime.IExpressionParser];\n  exports.DelegateBindingCommand = __decorate([\n      bindingCommand('delegate')\n  ], exports.DelegateBindingCommand);\n  exports.CaptureBindingCommand = class CaptureBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return new CaptureBindingInstruction(this.parser.parse($symbol.rawValue, 87 /* CaptureCommand */), $symbol.to);\n      }\n  };\n  exports.CaptureBindingCommand.inject = [runtime.IExpressionParser];\n  exports.CaptureBindingCommand = __decorate([\n      bindingCommand('capture')\n  ], exports.CaptureBindingCommand);\n  exports.CallBindingCommand = class CallBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          return new CallBindingInstruction(this.parser.parse($symbol.rawValue, 153 /* CallCommand */), $symbol.to);\n      }\n  };\n  exports.CallBindingCommand.inject = [runtime.IExpressionParser];\n  exports.CallBindingCommand = __decorate([\n      bindingCommand('call')\n  ], exports.CallBindingCommand);\n  exports.ForBindingCommand = class ForBindingCommand {\n      constructor(parser) {\n          this.parser = parser;\n      }\n      compile($symbol) {\n          const def = {\n              name: 'repeat',\n              template: $symbol.$element.node,\n              instructions: []\n          };\n          return new HydrateTemplateController(def, 'repeat', [\n              new IteratorBindingInstruction(this.parser.parse($symbol.rawValue, 539 /* ForCommand */), 'items'),\n              new SetPropertyInstruction('item', 'local')\n              // tslint:disable-next-line:align\n          ], false);\n      }\n      handles($symbol) {\n          return $symbol.target === 'repeat';\n      }\n  };\n  exports.ForBindingCommand.inject = [runtime.IExpressionParser];\n  exports.ForBindingCommand = __decorate([\n      bindingCommand('for')\n  ], exports.ForBindingCommand);\n\n  /*@internal*/\n  function unescapeCode(code) {\n      switch (code) {\n          case 98 /* LowerB */: return 8 /* Backspace */;\n          case 116 /* LowerT */: return 9 /* Tab */;\n          case 110 /* LowerN */: return 10 /* LineFeed */;\n          case 118 /* LowerV */: return 11 /* VerticalTab */;\n          case 102 /* LowerF */: return 12 /* FormFeed */;\n          case 114 /* LowerR */: return 13 /* CarriageReturn */;\n          case 34 /* DoubleQuote */: return 34 /* DoubleQuote */;\n          case 39 /* SingleQuote */: return 39 /* SingleQuote */;\n          case 92 /* Backslash */: return 92 /* Backslash */;\n          default: return code;\n      }\n  }\n\n  // tslint:disable:no-non-null-assertion\n  const ParserRegistration = {\n      register(container) {\n          container.registerTransformer(runtime.IExpressionParser, parser => {\n              parser['parseCore'] = parseCore;\n              return parser;\n          });\n      }\n  };\n  const $false = runtime.PrimitiveLiteral.$false;\n  const $true = runtime.PrimitiveLiteral.$true;\n  const $null = runtime.PrimitiveLiteral.$null;\n  const $undefined = runtime.PrimitiveLiteral.$undefined;\n  const $this = runtime.AccessThis.$this;\n  const $parent = runtime.AccessThis.$parent;\n  /*@internal*/\n  class ParserState {\n      get tokenRaw() {\n          return this.input.slice(this.startIndex, this.index);\n      }\n      constructor(input) {\n          this.index = 0;\n          this.startIndex = 0;\n          this.lastIndex = 0;\n          this.input = input;\n          this.length = input.length;\n          this.currentToken = 1572864 /* EOF */;\n          this.tokenValue = '';\n          this.currentChar = input.charCodeAt(0);\n          this.assignable = true;\n      }\n  }\n  const $state = new ParserState('');\n  /*@internal*/\n  function parseCore(input, bindingType) {\n      $state.input = input;\n      $state.length = input.length;\n      $state.index = 0;\n      $state.currentChar = input.charCodeAt(0);\n      return parse($state, 0 /* Reset */, 61 /* Variadic */, bindingType === undefined ? 53 /* BindCommand */ : bindingType);\n  }\n  /*@internal*/\n  function parse(state, access, minPrecedence, bindingType) {\n      if (state.index === 0) {\n          if (bindingType & 2048 /* Interpolation */) {\n              // tslint:disable-next-line:no-any\n              return parseInterpolation(state);\n          }\n          nextToken(state);\n          if (state.currentToken & 1048576 /* ExpressionTerminal */) {\n              throw kernel.Reporter.error(100 /* InvalidExpressionStart */, { state });\n          }\n      }\n      state.assignable = 448 /* Binary */ > minPrecedence;\n      let result = undefined;\n      if (state.currentToken & 32768 /* UnaryOp */) {\n          /** parseUnaryExpression\n           * https://tc39.github.io/ecma262/#sec-unary-operators\n           *\n           * UnaryExpression :\n           *   1. LeftHandSideExpression\n           *   2. void UnaryExpression\n           *   3. typeof UnaryExpression\n           *   4. + UnaryExpression\n           *   5. - UnaryExpression\n           *   6. ! UnaryExpression\n           *\n           * IsValidAssignmentTarget\n           *   2,3,4,5,6 = false\n           *   1 = see parseLeftHandSideExpression\n           *\n           * Note: technically we should throw on ++ / -- / +++ / ---, but there's nothing to gain from that\n           */\n          const op = TokenValues[state.currentToken & 63 /* Type */];\n          nextToken(state);\n          result = new runtime.Unary(op, parse(state, access, 449 /* LeftHandSide */, bindingType));\n          state.assignable = false;\n      }\n      else {\n          /** parsePrimaryExpression\n           * https://tc39.github.io/ecma262/#sec-primary-expression\n           *\n           * PrimaryExpression :\n           *   1. this\n           *   2. IdentifierName\n           *   3. Literal\n           *   4. ArrayLiteral\n           *   5. ObjectLiteral\n           *   6. TemplateLiteral\n           *   7. ParenthesizedExpression\n           *\n           * Literal :\n           *    NullLiteral\n           *    BooleanLiteral\n           *    NumericLiteral\n           *    StringLiteral\n           *\n           * ParenthesizedExpression :\n           *   ( AssignmentExpression )\n           *\n           * IsValidAssignmentTarget\n           *   1,3,4,5,6,7 = false\n           *   2 = true\n           */\n          primary: switch (state.currentToken) {\n              case 3077 /* ParentScope */: // $parent\n                  state.assignable = false;\n                  do {\n                      nextToken(state);\n                      access++; // ancestor\n                      if (consumeOpt(state, 16392 /* Dot */)) {\n                          if (state.currentToken === 16392 /* Dot */) {\n                              throw kernel.Reporter.error(102 /* DoubleDot */, { state });\n                          }\n                          else if (state.currentToken === 1572864 /* EOF */) {\n                              throw kernel.Reporter.error(105 /* ExpectedIdentifier */, { state });\n                          }\n                          continue;\n                      }\n                      else if (state.currentToken & 524288 /* AccessScopeTerminal */) {\n                          const ancestor = access & 511 /* Ancestor */;\n                          result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new runtime.AccessThis(ancestor);\n                          access = 512 /* This */;\n                          break primary;\n                      }\n                      else {\n                          throw kernel.Reporter.error(103 /* InvalidMemberExpression */, { state });\n                      }\n                  } while (state.currentToken === 3077 /* ParentScope */);\n              // falls through\n              case 1024 /* Identifier */: // identifier\n                  if (bindingType & 512 /* IsIterator */) {\n                      result = new runtime.BindingIdentifier(state.tokenValue);\n                  }\n                  else {\n                      result = new runtime.AccessScope(state.tokenValue, access & 511 /* Ancestor */);\n                      access = 1024 /* Scope */;\n                  }\n                  state.assignable = true;\n                  nextToken(state);\n                  break;\n              case 3076 /* ThisScope */: // $this\n                  state.assignable = false;\n                  nextToken(state);\n                  result = $this;\n                  access = 512 /* This */;\n                  break;\n              case 671750 /* OpenParen */: // parenthesized expression\n                  nextToken(state);\n                  result = parse(state, 0 /* Reset */, 62 /* Assign */, bindingType);\n                  consume(state, 1835018 /* CloseParen */);\n                  access = 0 /* Reset */;\n                  break;\n              case 671756 /* OpenBracket */:\n                  result = parseArrayLiteralExpression(state, access, bindingType);\n                  access = 0 /* Reset */;\n                  break;\n              case 131079 /* OpenBrace */:\n                  result = parseObjectLiteralExpression(state, bindingType);\n                  access = 0 /* Reset */;\n                  break;\n              case 540713 /* TemplateTail */:\n                  result = new runtime.Template([state.tokenValue]);\n                  state.assignable = false;\n                  nextToken(state);\n                  access = 0 /* Reset */;\n                  break;\n              case 540714 /* TemplateContinuation */:\n                  result = parseTemplate(state, access, bindingType, result, false);\n                  access = 0 /* Reset */;\n                  break;\n              case 4096 /* StringLiteral */:\n              case 8192 /* NumericLiteral */:\n                  result = new runtime.PrimitiveLiteral(state.tokenValue);\n                  state.assignable = false;\n                  nextToken(state);\n                  access = 0 /* Reset */;\n                  break;\n              case 2050 /* NullKeyword */:\n              case 2051 /* UndefinedKeyword */:\n              case 2049 /* TrueKeyword */:\n              case 2048 /* FalseKeyword */:\n                  result = TokenValues[state.currentToken & 63 /* Type */];\n                  state.assignable = false;\n                  nextToken(state);\n                  access = 0 /* Reset */;\n                  break;\n              default:\n                  if (state.index >= state.length) {\n                      throw kernel.Reporter.error(104 /* UnexpectedEndOfExpression */, { state });\n                  }\n                  else {\n                      throw kernel.Reporter.error(101 /* UnconsumedToken */, { state });\n                  }\n          }\n          if (bindingType & 512 /* IsIterator */) {\n              // tslint:disable-next-line:no-any\n              return parseForOfStatement(state, result);\n          }\n          // tslint:disable-next-line:no-any\n          if (449 /* LeftHandSide */ < minPrecedence)\n              return result;\n          /** parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)\n           * MemberExpression :\n           *   1. PrimaryExpression\n           *   2. MemberExpression [ AssignmentExpression ]\n           *   3. MemberExpression . IdentifierName\n           *   4. MemberExpression TemplateLiteral\n           *\n           * IsValidAssignmentTarget\n           *   1,4 = false\n           *   2,3 = true\n           *\n           *\n           * parseCallExpression (Token.OpenParen)\n           * CallExpression :\n           *   1. MemberExpression Arguments\n           *   2. CallExpression Arguments\n           *   3. CallExpression [ AssignmentExpression ]\n           *   4. CallExpression . IdentifierName\n           *   5. CallExpression TemplateLiteral\n           *\n           * IsValidAssignmentTarget\n           *   1,2,5 = false\n           *   3,4 = true\n           */\n          let name = state.tokenValue;\n          while ((state.currentToken & 16384 /* LeftHandSide */) > 0) {\n              switch (state.currentToken) {\n                  case 16392 /* Dot */:\n                      state.assignable = true;\n                      nextToken(state);\n                      if ((state.currentToken & 3072 /* IdentifierName */) === 0) {\n                          throw kernel.Reporter.error(105 /* ExpectedIdentifier */, { state });\n                      }\n                      name = state.tokenValue;\n                      nextToken(state);\n                      // Change $This to $Scope, change $Scope to $Member, keep $Member as-is, change $Keyed to $Member, disregard other flags\n                      access = ((access & (512 /* This */ | 1024 /* Scope */)) << 1) | (access & 2048 /* Member */) | ((access & 4096 /* Keyed */) >> 1);\n                      if (state.currentToken === 671750 /* OpenParen */) {\n                          if (access === 0 /* Reset */) { // if the left hand side is a literal, make sure we parse a CallMember\n                              access = 2048 /* Member */;\n                          }\n                          continue;\n                      }\n                      if (access & 1024 /* Scope */) {\n                          result = new runtime.AccessScope(name, result.ancestor);\n                      }\n                      else { // if it's not $Scope, it's $Member\n                          result = new runtime.AccessMember(result, name);\n                      }\n                      continue;\n                  case 671756 /* OpenBracket */:\n                      state.assignable = true;\n                      nextToken(state);\n                      access = 4096 /* Keyed */;\n                      result = new runtime.AccessKeyed(result, parse(state, 0 /* Reset */, 62 /* Assign */, bindingType));\n                      consume(state, 1835021 /* CloseBracket */);\n                      break;\n                  case 671750 /* OpenParen */:\n                      state.assignable = false;\n                      nextToken(state);\n                      const args = new Array();\n                      while (state.currentToken !== 1835018 /* CloseParen */) {\n                          args.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType));\n                          if (!consumeOpt(state, 1572875 /* Comma */)) {\n                              break;\n                          }\n                      }\n                      consume(state, 1835018 /* CloseParen */);\n                      if (access & 1024 /* Scope */) {\n                          result = new runtime.CallScope(name, args, result.ancestor);\n                      }\n                      else if (access & 2048 /* Member */) {\n                          result = new runtime.CallMember(result, name, args);\n                      }\n                      else {\n                          result = new runtime.CallFunction(result, args);\n                      }\n                      access = 0;\n                      break;\n                  case 540713 /* TemplateTail */:\n                      state.assignable = false;\n                      const strings = [state.tokenValue];\n                      result = new runtime.TaggedTemplate(strings, strings, result);\n                      nextToken(state);\n                      break;\n                  case 540714 /* TemplateContinuation */:\n                      result = parseTemplate(state, access, bindingType, result, true);\n                  default:\n              }\n          }\n      }\n      // tslint:disable-next-line:no-any\n      if (448 /* Binary */ < minPrecedence)\n          return result;\n      /** parseBinaryExpression\n       * https://tc39.github.io/ecma262/#sec-multiplicative-operators\n       *\n       * MultiplicativeExpression : (local precedence 6)\n       *   UnaryExpression\n       *   MultiplicativeExpression * / % UnaryExpression\n       *\n       * AdditiveExpression : (local precedence 5)\n       *   MultiplicativeExpression\n       *   AdditiveExpression + - MultiplicativeExpression\n       *\n       * RelationalExpression : (local precedence 4)\n       *   AdditiveExpression\n       *   RelationalExpression < > <= >= instanceof in AdditiveExpression\n       *\n       * EqualityExpression : (local precedence 3)\n       *   RelationalExpression\n       *   EqualityExpression == != === !== RelationalExpression\n       *\n       * LogicalANDExpression : (local precedence 2)\n       *   EqualityExpression\n       *   LogicalANDExpression && EqualityExpression\n       *\n       * LogicalORExpression : (local precedence 1)\n       *   LogicalANDExpression\n       *   LogicalORExpression || LogicalANDExpression\n       */\n      while ((state.currentToken & 65536 /* BinaryOp */) > 0) {\n          const opToken = state.currentToken;\n          if ((opToken & 448 /* Precedence */) <= minPrecedence) {\n              break;\n          }\n          nextToken(state);\n          result = new runtime.Binary(TokenValues[opToken & 63 /* Type */], result, parse(state, access, opToken & 448 /* Precedence */, bindingType));\n          state.assignable = false;\n      }\n      // tslint:disable-next-line:no-any\n      if (63 /* Conditional */ < minPrecedence)\n          return result;\n      /**\n       * parseConditionalExpression\n       * https://tc39.github.io/ecma262/#prod-ConditionalExpression\n       *\n       * ConditionalExpression :\n       *   1. BinaryExpression\n       *   2. BinaryExpression ? AssignmentExpression : AssignmentExpression\n       *\n       * IsValidAssignmentTarget\n       *   1,2 = false\n       */\n      if (consumeOpt(state, 1572879 /* Question */)) {\n          const yes = parse(state, access, 62 /* Assign */, bindingType);\n          consume(state, 1572878 /* Colon */);\n          result = new runtime.Conditional(result, yes, parse(state, access, 62 /* Assign */, bindingType));\n          state.assignable = false;\n      }\n      // tslint:disable-next-line:no-any\n      if (62 /* Assign */ < minPrecedence)\n          return result;\n      /** parseAssignmentExpression\n       * https://tc39.github.io/ecma262/#prod-AssignmentExpression\n       * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator\n       *\n       * AssignmentExpression :\n       *   1. ConditionalExpression\n       *   2. LeftHandSideExpression = AssignmentExpression\n       *\n       * IsValidAssignmentTarget\n       *   1,2 = false\n       */\n      if (consumeOpt(state, 1048615 /* Equals */)) {\n          if (!state.assignable) {\n              throw kernel.Reporter.error(150 /* NotAssignable */, { state });\n          }\n          result = new runtime.Assign(result, parse(state, access, 62 /* Assign */, bindingType));\n      }\n      // tslint:disable-next-line:no-any\n      if (61 /* Variadic */ < minPrecedence)\n          return result;\n      /** parseValueConverter\n       */\n      while (consumeOpt(state, 1572883 /* Bar */)) {\n          if (state.currentToken === 1572864 /* EOF */) {\n              throw kernel.Reporter.error(112);\n          }\n          const name = state.tokenValue;\n          nextToken(state);\n          const args = new Array();\n          while (consumeOpt(state, 1572878 /* Colon */)) {\n              args.push(parse(state, access, 62 /* Assign */, bindingType));\n          }\n          result = new runtime.ValueConverter(result, name, args);\n      }\n      /** parseBindingBehavior\n       */\n      while (consumeOpt(state, 1572880 /* Ampersand */)) {\n          if (state.currentToken === 1572864 /* EOF */) {\n              throw kernel.Reporter.error(113);\n          }\n          const name = state.tokenValue;\n          nextToken(state);\n          const args = new Array();\n          while (consumeOpt(state, 1572878 /* Colon */)) {\n              args.push(parse(state, access, 62 /* Assign */, bindingType));\n          }\n          result = new runtime.BindingBehavior(result, name, args);\n      }\n      if (state.currentToken !== 1572864 /* EOF */) {\n          if (bindingType & 2048 /* Interpolation */) {\n              // tslint:disable-next-line:no-any\n              return result;\n          }\n          if (state.tokenRaw === 'of') {\n              throw kernel.Reporter.error(151 /* UnexpectedForOf */, { state });\n          }\n          throw kernel.Reporter.error(101 /* UnconsumedToken */, { state });\n      }\n      // tslint:disable-next-line:no-any\n      return result;\n  }\n  /**\n   * parseArrayLiteralExpression\n   * https://tc39.github.io/ecma262/#prod-ArrayLiteral\n   *\n   * ArrayLiteral :\n   *   [ Elision(opt) ]\n   *   [ ElementList ]\n   *   [ ElementList, Elision(opt) ]\n   *\n   * ElementList :\n   *   Elision(opt) AssignmentExpression\n   *   ElementList, Elision(opt) AssignmentExpression\n   *\n   * Elision :\n   *  ,\n   *  Elision ,\n   */\n  function parseArrayLiteralExpression(state, access, bindingType) {\n      nextToken(state);\n      const elements = new Array();\n      while (state.currentToken !== 1835021 /* CloseBracket */) {\n          if (consumeOpt(state, 1572875 /* Comma */)) {\n              elements.push($undefined);\n              if (state.currentToken === 1835021 /* CloseBracket */) {\n                  elements.push($undefined);\n                  break;\n              }\n          }\n          else {\n              elements.push(parse(state, access, 62 /* Assign */, bindingType & ~512 /* IsIterator */));\n              if (consumeOpt(state, 1572875 /* Comma */)) {\n                  if (state.currentToken === 1835021 /* CloseBracket */) {\n                      elements.push($undefined);\n                      break;\n                  }\n              }\n              else {\n                  break;\n              }\n          }\n      }\n      consume(state, 1835021 /* CloseBracket */);\n      if (bindingType & 512 /* IsIterator */) {\n          return new runtime.ArrayBindingPattern(elements);\n      }\n      else {\n          state.assignable = false;\n          return new runtime.ArrayLiteral(elements);\n      }\n  }\n  function parseForOfStatement(state, result) {\n      if ((result.$kind & 65536 /* IsForDeclaration */) === 0) {\n          throw kernel.Reporter.error(106 /* InvalidForDeclaration */, { state });\n      }\n      if (state.currentToken !== 1051179 /* OfKeyword */) {\n          throw kernel.Reporter.error(106 /* InvalidForDeclaration */, { state });\n      }\n      nextToken(state);\n      const declaration = result;\n      const statement = parse(state, 0 /* Reset */, 61 /* Variadic */, 0 /* None */);\n      return new runtime.ForOfStatement(declaration, statement);\n  }\n  /**\n   * parseObjectLiteralExpression\n   * https://tc39.github.io/ecma262/#prod-Literal\n   *\n   * ObjectLiteral :\n   *   { }\n   *   { PropertyDefinitionList }\n   *\n   * PropertyDefinitionList :\n   *   PropertyDefinition\n   *   PropertyDefinitionList, PropertyDefinition\n   *\n   * PropertyDefinition :\n   *   IdentifierName\n   *   PropertyName : AssignmentExpression\n   *\n   * PropertyName :\n   *   IdentifierName\n   *   StringLiteral\n   *   NumericLiteral\n   */\n  function parseObjectLiteralExpression(state, bindingType) {\n      const keys = new Array();\n      const values = new Array();\n      nextToken(state);\n      while (state.currentToken !== 1835017 /* CloseBrace */) {\n          keys.push(state.tokenValue);\n          // Literal = mandatory colon\n          if (state.currentToken & 12288 /* StringOrNumericLiteral */) {\n              nextToken(state);\n              consume(state, 1572878 /* Colon */);\n              values.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType & ~512 /* IsIterator */));\n          }\n          else if (state.currentToken & 3072 /* IdentifierName */) {\n              // IdentifierName = optional colon\n              const { currentChar, currentToken, index } = state;\n              nextToken(state);\n              if (consumeOpt(state, 1572878 /* Colon */)) {\n                  values.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType & ~512 /* IsIterator */));\n              }\n              else {\n                  // Shorthand\n                  state.currentChar = currentChar;\n                  state.currentToken = currentToken;\n                  state.index = index;\n                  values.push(parse(state, 0 /* Reset */, 450 /* Primary */, bindingType & ~512 /* IsIterator */));\n              }\n          }\n          else {\n              throw kernel.Reporter.error(107 /* InvalidObjectLiteralPropertyDefinition */, { state });\n          }\n          if (state.currentToken !== 1835017 /* CloseBrace */) {\n              consume(state, 1572875 /* Comma */);\n          }\n      }\n      consume(state, 1835017 /* CloseBrace */);\n      if (bindingType & 512 /* IsIterator */) {\n          return new runtime.ObjectBindingPattern(keys, values);\n      }\n      else {\n          state.assignable = false;\n          return new runtime.ObjectLiteral(keys, values);\n      }\n  }\n  function parseInterpolation(state) {\n      const parts = [];\n      const expressions = [];\n      const length = state.length;\n      let result = '';\n      while (state.index < length) {\n          switch (state.currentChar) {\n              case 36 /* Dollar */:\n                  if (state.input.charCodeAt(state.index + 1) === 123 /* OpenBrace */) {\n                      parts.push(result);\n                      result = '';\n                      state.index += 2;\n                      state.currentChar = state.input.charCodeAt(state.index);\n                      nextToken(state);\n                      const expression = parse(state, 0 /* Reset */, 61 /* Variadic */, 2048 /* Interpolation */);\n                      expressions.push(expression);\n                      continue;\n                  }\n                  else {\n                      result += '$';\n                  }\n                  break;\n              case 92 /* Backslash */:\n                  result += String.fromCharCode(unescapeCode(nextChar(state)));\n                  break;\n              default:\n                  result += String.fromCharCode(state.currentChar);\n          }\n          nextChar(state);\n      }\n      if (expressions.length) {\n          parts.push(result);\n          return new runtime.Interpolation(parts, expressions);\n      }\n      return null;\n  }\n  /**\n   * parseTemplateLiteralExpression\n   * https://tc39.github.io/ecma262/#prod-Literal\n   *\n   * Template :\n   *   NoSubstitutionTemplate\n   *   TemplateHead\n   *\n   * NoSubstitutionTemplate :\n   *   ` TemplateCharacters(opt) `\n   *\n   * TemplateHead :\n   *   ` TemplateCharacters(opt) ${\n   *\n   * TemplateSubstitutionTail :\n   *   TemplateMiddle\n   *   TemplateTail\n   *\n   * TemplateMiddle :\n   *   } TemplateCharacters(opt) ${\n   *\n   * TemplateTail :\n   *   } TemplateCharacters(opt) `\n   *\n   * TemplateCharacters :\n   *   TemplateCharacter TemplateCharacters(opt)\n   *\n   * TemplateCharacter :\n   *   $ [lookahead ≠ {]\n   *   \\ EscapeSequence\n   *   SourceCharacter (but not one of ` or \\ or $)\n   */\n  function parseTemplate(state, access, bindingType, result, tagged) {\n      const cooked = [state.tokenValue];\n      //const raw = [state.tokenRaw];\n      consume(state, 540714 /* TemplateContinuation */);\n      const expressions = [parse(state, access, 62 /* Assign */, bindingType)];\n      while ((state.currentToken = scanTemplateTail(state)) !== 540713 /* TemplateTail */) {\n          cooked.push(state.tokenValue);\n          // if (tagged) {\n          //   raw.push(state.tokenRaw);\n          // }\n          consume(state, 540714 /* TemplateContinuation */);\n          expressions.push(parse(state, access, 62 /* Assign */, bindingType));\n      }\n      cooked.push(state.tokenValue);\n      state.assignable = false;\n      if (tagged) {\n          //raw.push(state.tokenRaw);\n          nextToken(state);\n          return new runtime.TaggedTemplate(cooked, cooked, result, expressions);\n      }\n      else {\n          nextToken(state);\n          return new runtime.Template(cooked, expressions);\n      }\n  }\n  function nextToken(state) {\n      while (state.index < state.length) {\n          state.startIndex = state.index;\n          if ((state.currentToken = CharScanners[state.currentChar](state)) !== null) { // a null token means the character must be skipped\n              return;\n          }\n      }\n      state.currentToken = 1572864 /* EOF */;\n  }\n  function nextChar(state) {\n      return state.currentChar = state.input.charCodeAt(++state.index);\n  }\n  function scanIdentifier(state) {\n      // run to the next non-idPart\n      while (IdParts[nextChar(state)])\n          ;\n      const token = KeywordLookup[state.tokenValue = state.tokenRaw];\n      return token === undefined ? 1024 /* Identifier */ : token;\n  }\n  function scanNumber(state, isFloat) {\n      let char = state.currentChar;\n      if (isFloat === false) {\n          do {\n              char = nextChar(state);\n          } while (char <= 57 /* Nine */ && char >= 48 /* Zero */);\n          if (char !== 46 /* Dot */) {\n              state.tokenValue = parseInt(state.tokenRaw, 10);\n              return 8192 /* NumericLiteral */;\n          }\n          // past this point it's always a float\n          char = nextChar(state);\n          if (state.index >= state.length) {\n              // unless the number ends with a dot - that behaves a little different in native ES expressions\n              // but in our AST that behavior has no effect because numbers are always stored in variables\n              state.tokenValue = parseInt(state.tokenRaw.slice(0, -1), 10);\n              return 8192 /* NumericLiteral */;\n          }\n      }\n      if (char <= 57 /* Nine */ && char >= 48 /* Zero */) {\n          do {\n              char = nextChar(state);\n          } while (char <= 57 /* Nine */ && char >= 48 /* Zero */);\n      }\n      else {\n          state.currentChar = state.input.charCodeAt(--state.index);\n      }\n      state.tokenValue = parseFloat(state.tokenRaw);\n      return 8192 /* NumericLiteral */;\n  }\n  function scanString(state) {\n      const quote = state.currentChar;\n      nextChar(state); // Skip initial quote.\n      let unescaped = 0;\n      const buffer = new Array();\n      let marker = state.index;\n      while (state.currentChar !== quote) {\n          if (state.currentChar === 92 /* Backslash */) {\n              buffer.push(state.input.slice(marker, state.index));\n              nextChar(state);\n              unescaped = unescapeCode(state.currentChar);\n              nextChar(state);\n              buffer.push(String.fromCharCode(unescaped));\n              marker = state.index;\n          }\n          else if (state.index >= state.length) {\n              throw kernel.Reporter.error(108 /* UnterminatedQuote */, { state });\n          }\n          else {\n              nextChar(state);\n          }\n      }\n      const last = state.input.slice(marker, state.index);\n      nextChar(state); // Skip terminating quote.\n      // Compute the unescaped string value.\n      buffer.push(last);\n      const unescapedStr = buffer.join('');\n      state.tokenValue = unescapedStr;\n      return 4096 /* StringLiteral */;\n  }\n  function scanTemplate(state) {\n      let tail = true;\n      let result = '';\n      while (nextChar(state) !== 96 /* Backtick */) {\n          if (state.currentChar === 36 /* Dollar */) {\n              if ((state.index + 1) < state.length && state.input.charCodeAt(state.index + 1) === 123 /* OpenBrace */) {\n                  state.index++;\n                  tail = false;\n                  break;\n              }\n              else {\n                  result += '$';\n              }\n          }\n          else if (state.currentChar === 92 /* Backslash */) {\n              result += String.fromCharCode(unescapeCode(nextChar(state)));\n          }\n          else {\n              if (state.index >= state.length) {\n                  throw kernel.Reporter.error(109 /* UnterminatedTemplate */, { state });\n              }\n              result += String.fromCharCode(state.currentChar);\n          }\n      }\n      nextChar(state);\n      state.tokenValue = result;\n      if (tail) {\n          return 540713 /* TemplateTail */;\n      }\n      return 540714 /* TemplateContinuation */;\n  }\n  function scanTemplateTail(state) {\n      if (state.index >= state.length) {\n          throw kernel.Reporter.error(109 /* UnterminatedTemplate */, { state });\n      }\n      state.index--;\n      return scanTemplate(state);\n  }\n  function consumeOpt(state, token) {\n      // tslint:disable-next-line:possible-timing-attack\n      if (state.currentToken === token) {\n          nextToken(state);\n          return true;\n      }\n      return false;\n  }\n  function consume(state, token) {\n      // tslint:disable-next-line:possible-timing-attack\n      if (state.currentToken === token) {\n          nextToken(state);\n      }\n      else {\n          throw kernel.Reporter.error(110 /* MissingExpectedToken */, { state, expected: token });\n      }\n  }\n  /**\n   * Array for mapping tokens to token values. The indices of the values\n   * correspond to the token bits 0-38.\n   * For this to work properly, the values in the array must be kept in\n   * the same order as the token bits.\n   * Usage: TokenValues[token & Token.Type]\n   */\n  const TokenValues = [\n      $false, $true, $null, $undefined, '$this', '$parent',\n      '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\\'', '\"',\n      '&', '|', '||', '&&', '==', '!=', '===', '!==', '<', '>',\n      '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!',\n      540713 /* TemplateTail */, 540714 /* TemplateContinuation */,\n      'of'\n  ];\n  const KeywordLookup = Object.create(null);\n  KeywordLookup.true = 2049 /* TrueKeyword */;\n  KeywordLookup.null = 2050 /* NullKeyword */;\n  KeywordLookup.false = 2048 /* FalseKeyword */;\n  KeywordLookup.undefined = 2051 /* UndefinedKeyword */;\n  KeywordLookup.$this = 3076 /* ThisScope */;\n  KeywordLookup.$parent = 3077 /* ParentScope */;\n  KeywordLookup.in = 1640798 /* InKeyword */;\n  KeywordLookup.instanceof = 1640799 /* InstanceOfKeyword */;\n  KeywordLookup.typeof = 34850 /* TypeofKeyword */;\n  KeywordLookup.void = 34851 /* VoidKeyword */;\n  KeywordLookup.of = 1051179 /* OfKeyword */;\n  /**\n   * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)\n   * Single values are denoted by the second value being a 0\n   *\n   * Copied from output generated with \"node build/generate-unicode.js\"\n   *\n   * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n   */\n  const codes = {\n      /* [$0-9A-Za_a-z] */\n      AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],\n      IdStart: /*IdentifierStart*/ [0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],\n      Digit: /*DecimalNumber*/ [0x30, 0x3A],\n      Skip: /*Skippable*/ [0, 0x21, 0x7F, 0xA1]\n  };\n  /**\n   * Decompress the ranges into an array of numbers so that the char code\n   * can be used as an index to the lookup\n   */\n  function decompress(lookup, $set, compressed, value) {\n      const rangeCount = compressed.length;\n      for (let i = 0; i < rangeCount; i += 2) {\n          const start = compressed[i];\n          let end = compressed[i + 1];\n          end = end > 0 ? end : start + 1;\n          if (lookup) {\n              lookup.fill(value, start, end);\n          }\n          if ($set) {\n              for (let ch = start; ch < end; ch++) {\n                  $set.add(ch);\n              }\n          }\n      }\n  }\n  // CharFuncLookup functions\n  function returnToken(token) {\n      return s => {\n          nextChar(s);\n          return token;\n      };\n  }\n  const unexpectedCharacter = s => {\n      throw kernel.Reporter.error(111 /* UnexpectedCharacter */, { state: s });\n  };\n  unexpectedCharacter.notMapped = true;\n  // ASCII IdentifierPart lookup\n  const AsciiIdParts = new Set();\n  decompress(null, AsciiIdParts, codes.AsciiIdPart, true);\n  // IdentifierPart lookup\n  const IdParts = new Uint8Array(0xFFFF);\n  // tslint:disable-next-line:no-any\n  decompress(IdParts, null, codes.IdStart, 1);\n  // tslint:disable-next-line:no-any\n  decompress(IdParts, null, codes.Digit, 1);\n  // Character scanning function lookup\n  const CharScanners = new Array(0xFFFF);\n  CharScanners.fill(unexpectedCharacter, 0, 0xFFFF);\n  decompress(CharScanners, null, codes.Skip, s => {\n      nextChar(s);\n      return null;\n  });\n  decompress(CharScanners, null, codes.IdStart, scanIdentifier);\n  decompress(CharScanners, null, codes.Digit, s => scanNumber(s, false));\n  CharScanners[34 /* DoubleQuote */] =\n      CharScanners[39 /* SingleQuote */] = s => {\n          return scanString(s);\n      };\n  CharScanners[96 /* Backtick */] = s => {\n      return scanTemplate(s);\n  };\n  // !, !=, !==\n  CharScanners[33 /* Exclamation */] = s => {\n      if (nextChar(s) !== 61 /* Equals */) {\n          return 32808 /* Exclamation */;\n      }\n      if (nextChar(s) !== 61 /* Equals */) {\n          return 1638679 /* ExclamationEquals */;\n      }\n      nextChar(s);\n      return 1638681 /* ExclamationEqualsEquals */;\n  };\n  // =, ==, ===\n  CharScanners[61 /* Equals */] = s => {\n      if (nextChar(s) !== 61 /* Equals */) {\n          return 1048615 /* Equals */;\n      }\n      if (nextChar(s) !== 61 /* Equals */) {\n          return 1638678 /* EqualsEquals */;\n      }\n      nextChar(s);\n      return 1638680 /* EqualsEqualsEquals */;\n  };\n  // &, &&\n  CharScanners[38 /* Ampersand */] = s => {\n      if (nextChar(s) !== 38 /* Ampersand */) {\n          return 1572880 /* Ampersand */;\n      }\n      nextChar(s);\n      return 1638613 /* AmpersandAmpersand */;\n  };\n  // |, ||\n  CharScanners[124 /* Bar */] = s => {\n      if (nextChar(s) !== 124 /* Bar */) {\n          return 1572883 /* Bar */;\n      }\n      nextChar(s);\n      return 1638548 /* BarBar */;\n  };\n  // .\n  CharScanners[46 /* Dot */] = s => {\n      if (nextChar(s) <= 57 /* Nine */ && s.currentChar >= 48 /* Zero */) {\n          return scanNumber(s, true);\n      }\n      return 16392 /* Dot */;\n  };\n  // <, <=\n  CharScanners[60 /* LessThan */] = s => {\n      if (nextChar(s) !== 61 /* Equals */) {\n          return 1638746 /* LessThan */;\n      }\n      nextChar(s);\n      return 1638748 /* LessThanEquals */;\n  };\n  // >, >=\n  CharScanners[62 /* GreaterThan */] = s => {\n      if (nextChar(s) !== 61 /* Equals */) {\n          return 1638747 /* GreaterThan */;\n      }\n      nextChar(s);\n      return 1638749 /* GreaterThanEquals */;\n  };\n  CharScanners[37 /* Percent */] = returnToken(1638885 /* Percent */);\n  CharScanners[40 /* OpenParen */] = returnToken(671750 /* OpenParen */);\n  CharScanners[41 /* CloseParen */] = returnToken(1835018 /* CloseParen */);\n  CharScanners[42 /* Asterisk */] = returnToken(1638884 /* Asterisk */);\n  CharScanners[43 /* Plus */] = returnToken(623008 /* Plus */);\n  CharScanners[44 /* Comma */] = returnToken(1572875 /* Comma */);\n  CharScanners[45 /* Minus */] = returnToken(623009 /* Minus */);\n  CharScanners[47 /* Slash */] = returnToken(1638886 /* Slash */);\n  CharScanners[58 /* Colon */] = returnToken(1572878 /* Colon */);\n  CharScanners[63 /* Question */] = returnToken(1572879 /* Question */);\n  CharScanners[91 /* OpenBracket */] = returnToken(671756 /* OpenBracket */);\n  CharScanners[93 /* CloseBracket */] = returnToken(1835021 /* CloseBracket */);\n  CharScanners[123 /* OpenBrace */] = returnToken(131079 /* OpenBrace */);\n  CharScanners[125 /* CloseBrace */] = returnToken(1835017 /* CloseBrace */);\n\n  const domParser = runtime.DOM.createElement('div');\n  const marker = runtime.DOM.createElement('au-marker');\n  marker.classList.add('au');\n  const createMarker = marker.cloneNode.bind(marker, false);\n  class ElementSyntax {\n      constructor(node, name, $content, $children, $attributes) {\n          this.node = node;\n          this.name = name;\n          this.$content = $content;\n          this.$children = $children;\n          this.$attributes = $attributes;\n      }\n      static createMarker() {\n          return new ElementSyntax(createMarker(), 'au-marker', null, kernel.PLATFORM.emptyArray, kernel.PLATFORM.emptyArray);\n      }\n  }\n  const IElementParser = kernel.DI.createInterface()\n      .withDefault(x => x.singleton(exports.ElementParser));\n  /*@internal*/\n  exports.ElementParser = class ElementParser {\n      constructor(attrParser) {\n          this.attrParser = attrParser;\n      }\n      parse(markupOrNode) {\n          let node;\n          if (typeof markupOrNode === 'string') {\n              domParser.innerHTML = markupOrNode;\n              node = domParser.firstElementChild;\n              domParser.removeChild(node);\n          }\n          else {\n              node = markupOrNode;\n          }\n          let children;\n          let content;\n          if (node.nodeName === 'TEMPLATE') {\n              content = this.parse(node.content);\n              children = kernel.PLATFORM.emptyArray;\n          }\n          else {\n              content = null;\n              const nodeChildNodes = node.childNodes;\n              const nodeLen = nodeChildNodes.length;\n              if (nodeLen > 0) {\n                  children = Array(nodeLen);\n                  for (let i = 0, ii = nodeLen; i < ii; ++i) {\n                      children[i] = this.parse(nodeChildNodes[i]);\n                  }\n              }\n              else {\n                  children = kernel.PLATFORM.emptyArray;\n              }\n          }\n          let attributes;\n          const nodeAttributes = node.attributes;\n          const attrLen = nodeAttributes === undefined ? 0 : nodeAttributes.length;\n          if (attrLen > 0) {\n              attributes = Array(attrLen);\n              for (let i = 0, ii = attrLen; i < ii; ++i) {\n                  const attr = nodeAttributes[i];\n                  attributes[i] = this.attrParser.parse(attr.name, attr.value);\n              }\n          }\n          else {\n              attributes = kernel.PLATFORM.emptyArray;\n          }\n          return new ElementSyntax(node, node.nodeName, content, children, attributes);\n      }\n  };\n  exports.ElementParser = __decorate([\n      kernel.inject(IAttributeParser)\n  ], exports.ElementParser);\n\n  class SemanticModel {\n      constructor(definition, resources, attrParser, elParser, exprParser) {\n          this.resources = resources;\n          this.attrParser = attrParser;\n          this.elParser = elParser;\n          this.exprParser = exprParser;\n          this.isSemanticModel = true;\n          this.attrDefCache = {};\n          this.elDefCache = {};\n          this.commandCache = {};\n          const syntax = this.elParser.parse(definition.template);\n          definition.template = syntax.node;\n          this.root = new ElementSymbol(\n          /*   semanticModel*/ this, \n          /*isDefinitionRoot*/ true, \n          /* $definitionRoot*/ null, \n          /*         $parent*/ null, \n          /*          syntax*/ syntax, \n          /*      definition*/ definition);\n      }\n      static create(definition, resources, attrParser, elParser, exprParser) {\n          if ('get' in attrParser) {\n              const locator = attrParser;\n              attrParser = locator.get(IAttributeParser);\n              elParser = locator.get(IElementParser);\n              exprParser = locator.get(runtime.IExpressionParser);\n          }\n          return new SemanticModel(definition, resources, attrParser, elParser, exprParser);\n      }\n      getAttributeDefinition(name) {\n          const existing = this.attrDefCache[name];\n          if (existing !== undefined) {\n              return existing;\n          }\n          const definition = this.resources.find(runtime.CustomAttributeResource, name);\n          return this.attrDefCache[name] = definition === undefined ? null : definition;\n      }\n      getElementDefinition(name) {\n          const existing = this.elDefCache[name];\n          if (existing !== undefined) {\n              return existing;\n          }\n          const definition = this.resources.find(runtime.CustomElementResource, name);\n          return this.elDefCache[name] = definition === undefined ? null : definition;\n      }\n      getBindingCommand(name) {\n          const existing = this.commandCache[name];\n          if (existing !== undefined) {\n              return existing;\n          }\n          const instance = this.resources.create(BindingCommandResource, name);\n          return this.commandCache[name] = instance === undefined ? null : instance;\n      }\n      getAttributeSymbol(syntax, element) {\n          const definition = this.getAttributeDefinition(kernel.PLATFORM.camelCase(syntax.target));\n          const command = this.getBindingCommand(syntax.command);\n          return new AttributeSymbol(this, element, syntax, definition, command);\n      }\n      getMultiAttrBindingSymbol(syntax, parent) {\n          const command = this.getBindingCommand(syntax.command);\n          return new MultiAttributeBindingSymbol(this, parent, syntax, command);\n      }\n      getElementSymbol(syntax, parent) {\n          const node = syntax.node;\n          let definition;\n          if (node.nodeType === 1 /* Element */) {\n              const resourceKey = (node.getAttribute('as-element') || node.nodeName).toLowerCase();\n              definition = this.getElementDefinition(resourceKey);\n          }\n          return new ElementSymbol(\n          /*   semanticModel*/ this, \n          /*isDefinitionRoot*/ false, \n          /* $definitionRoot*/ parent.$root, \n          /*         $parent*/ parent, \n          /*          syntax*/ syntax, \n          /*      definition*/ definition);\n      }\n      getTemplateElementSymbol(syntax, parent, definition, definitionRoot) {\n          return new ElementSymbol(\n          /*   semanticModel*/ this, \n          /*isDefinitionRoot*/ true, \n          /* $definitionRoot*/ definitionRoot, \n          /*         $parent*/ parent, \n          /*          syntax*/ syntax, \n          /*      definition*/ definition);\n      }\n  }\n  class MultiAttributeBindingSymbol {\n      constructor(semanticModel, $parent, syntax, command) {\n          this.semanticModel = semanticModel;\n          this.$parent = $parent;\n          this.syntax = syntax;\n          this.command = command;\n          this.isMultiAttrBinding = true;\n          this.res = null;\n          this.bindable = null;\n          this.isTemplateController = false;\n          this.isCustomAttribute = true;\n          this.isAttributeBindable = false;\n          this.isDefaultAttributeBindable = false;\n          this.onCustomElement = false;\n          this.isElementBindable = false;\n          this.$element = null;\n          this.target = syntax.target;\n          this.rawName = syntax.rawName;\n          this.rawValue = syntax.rawValue;\n          this.rawCommand = syntax.command;\n          this.hasBindingCommand = !!command;\n          this.isHandledByBindingCommand = this.hasBindingCommand && command.handles(this);\n          const bindables = $parent.definition.bindables;\n          for (const prop in bindables) {\n              const b = bindables[prop];\n              if (b.property === syntax.target) {\n                  this.to = b.property;\n                  this.mode = (b.mode !== undefined && b.mode !== runtime.BindingMode.default) ? b.mode : runtime.BindingMode.toView;\n                  this.bindable = b;\n                  this.isAttributeBindable = true;\n                  break;\n              }\n          }\n          if (!this.isAttributeBindable) {\n              const defaultBindingMode = $parent.definition.defaultBindingMode;\n              this.to = syntax.target;\n              this.mode = defaultBindingMode === undefined ? runtime.BindingMode.toView : defaultBindingMode;\n          }\n      }\n  }\n  class AttributeSymbol {\n      constructor(semanticModel, $element, syntax, definition, command) {\n          this.semanticModel = semanticModel;\n          this.$element = $element;\n          this.syntax = syntax;\n          this.definition = definition;\n          this.command = command;\n          this.isMultiAttrBinding = false;\n          this.res = null;\n          this.bindable = null;\n          this.isAttributeBindable = false;\n          this.isDefaultAttributeBindable = false;\n          this.isElementBindable = false;\n          this.isBindable = false;\n          this.isTemplateController = false;\n          this.target = syntax.target;\n          this.rawName = syntax.rawName;\n          this.rawValue = syntax.rawValue;\n          this.rawCommand = syntax.command;\n          this.isCustomAttribute = !!definition;\n          this.hasBindingCommand = !!command;\n          this.isHandledByBindingCommand = this.hasBindingCommand && command.handles(this);\n          this.onCustomElement = $element.isCustomElement;\n          this._isProcessed = this.rawName === 'as-element'; // as-element is processed by the semantic model and shouldn't be processed by the template compiler\n          if (this.isCustomAttribute) {\n              this.isTemplateController = !!definition.isTemplateController;\n              this.res = definition.name;\n              const value = syntax.rawValue;\n              let lastIndex = 0;\n              let multiAttrBindings;\n              for (let i = 0, ii = value.length; i < ii; ++i) {\n                  if (value.charCodeAt(i) === 59 /* Semicolon */) {\n                      if (!this.isMultiAttrBinding) {\n                          multiAttrBindings = [];\n                          this.isMultiAttrBinding = true;\n                      }\n                      const innerAttr = value.slice(lastIndex, i).trim();\n                      lastIndex = i + 1;\n                      if (innerAttr.length === 0) {\n                          continue;\n                      }\n                      for (let j = 0, jj = innerAttr.length; j < jj; ++j) {\n                          if (innerAttr.charCodeAt(j) === 58 /* Colon */) {\n                              const innerAttrName = innerAttr.slice(0, j).trim();\n                              const innerAttrValue = innerAttr.slice(j + 1).trim();\n                              const innerAttrSyntax = this.semanticModel.attrParser.parse(innerAttrName, innerAttrValue);\n                              multiAttrBindings.push(this.semanticModel.getMultiAttrBindingSymbol(innerAttrSyntax, this));\n                          }\n                      }\n                  }\n              }\n              this.$multiAttrBindings = this.isMultiAttrBinding ? multiAttrBindings : kernel.PLATFORM.emptyArray;\n              const bindables = definition.bindables;\n              if (!this.isMultiAttrBinding) {\n                  for (const prop in bindables) {\n                      const b = bindables[prop];\n                      this.to = b.property;\n                      this.mode = (b.mode !== undefined && b.mode !== runtime.BindingMode.default) ? b.mode : (definition.defaultBindingMode || runtime.BindingMode.toView);\n                      this.bindable = b;\n                      this.isBindable = this.isAttributeBindable = true;\n                      break;\n                  }\n                  if (!this.isAttributeBindable) {\n                      const defaultBindingMode = definition.defaultBindingMode;\n                      this.to = 'value';\n                      this.mode = defaultBindingMode === undefined ? runtime.BindingMode.toView : defaultBindingMode;\n                      this.isBindable = this.isAttributeBindable = this.isDefaultAttributeBindable = true;\n                  }\n              }\n          }\n          else if ($element.isCustomElement) {\n              const bindables = $element.definition.bindables;\n              for (const prop in bindables) {\n                  const b = bindables[prop];\n                  if (b.attribute === syntax.target) {\n                      this.to = b.property;\n                      this.mode = (b.mode !== undefined && b.mode !== runtime.BindingMode.default) ? b.mode : runtime.BindingMode.toView;\n                      this.bindable = b;\n                      this.isBindable = this.isElementBindable = true;\n                      break;\n                  }\n              }\n              if (!this.isElementBindable) {\n                  this.to = syntax.target;\n                  this.mode = runtime.BindingMode.toView;\n              }\n          }\n          else {\n              this.to = syntax.target;\n              this.mode = runtime.BindingMode.toView;\n          }\n      }\n      get isProcessed() {\n          return this._isProcessed;\n      }\n      markAsProcessed() {\n          this._isProcessed = true;\n          if (this.isTemplateController) {\n              this.$element.node.removeAttribute(this.rawName);\n          }\n      }\n  }\n  class ElementSymbol {\n      constructor(semanticModel, isRoot, $root, $parent, syntax, definition) {\n          this.semanticModel = semanticModel;\n          this.isRoot = isRoot;\n          this.$root = $root;\n          this.$parent = $parent;\n          this.definition = definition;\n          this._$content = null;\n          this._isMarker = false;\n          this._isTemplate = false;\n          this._isSlot = false;\n          this._isLet = false;\n          this._isLifted = false;\n          this.$root = isRoot ? this : $root;\n          this._node = syntax.node;\n          this._syntax = syntax;\n          this._name = this.node.nodeName;\n          switch (this.name) {\n              case 'TEMPLATE':\n                  this._isTemplate = true;\n                  this._$content = this.semanticModel.getElementSymbol(syntax.$content, this);\n                  break;\n              case 'SLOT':\n                  this._isSlot = true;\n                  break;\n              case 'LET':\n                  this._isLet = true;\n          }\n          this._isCustomElement = !isRoot && !!definition;\n          const attributes = syntax.$attributes;\n          const attrLen = attributes.length;\n          if (attrLen > 0) {\n              const attrSymbols = Array(attrLen);\n              for (let i = 0, ii = attrLen; i < ii; ++i) {\n                  attrSymbols[i] = this.semanticModel.getAttributeSymbol(attributes[i], this);\n              }\n              this.$attributes = attrSymbols;\n          }\n          else {\n              this.$attributes = kernel.PLATFORM.emptyArray;\n          }\n          const children = syntax.$children;\n          const childLen = children.length;\n          if (childLen > 0) {\n              const childSymbols = Array(childLen);\n              for (let i = 0, ii = childLen; i < ii; ++i) {\n                  childSymbols[i] = this.semanticModel.getElementSymbol(children[i], this);\n              }\n              this.$children = childSymbols;\n          }\n          else {\n              this.$children = kernel.PLATFORM.emptyArray;\n          }\n      }\n      get $content() {\n          return this._$content;\n      }\n      get isMarker() {\n          return this._isMarker;\n      }\n      get isTemplate() {\n          return this._isTemplate;\n      }\n      get isSlot() {\n          return this._isSlot;\n      }\n      get isLet() {\n          return this._isLet;\n      }\n      get node() {\n          return this._node;\n      }\n      get syntax() {\n          return this._syntax;\n      }\n      get name() {\n          return this._name;\n      }\n      get isCustomElement() {\n          return this._isCustomElement;\n      }\n      get nextSibling() {\n          if (!this.$parent) {\n              return null;\n          }\n          const siblings = this.$parent.$children;\n          for (let i = 0, ii = siblings.length; i < ii; ++i) {\n              if (siblings[i] === this) {\n                  const nextSibling = siblings[i + 1];\n                  return nextSibling === undefined ? null : nextSibling;\n              }\n          }\n          return null;\n      }\n      get firstChild() {\n          const firstChild = this.$children[0];\n          return firstChild === undefined ? null : firstChild;\n      }\n      get componentRoot() {\n          return this.semanticModel.root;\n      }\n      get isLifted() {\n          return this._isLifted;\n      }\n      makeTarget() {\n          this.node.classList.add('au');\n      }\n      replaceTextNodeWithMarker() {\n          const marker = ElementSyntax.createMarker();\n          const node = this.node;\n          node.parentNode.insertBefore(marker.node, node);\n          node.textContent = ' ';\n          while (node.nextSibling && node.nextSibling.nodeType === 3 /* Text */) {\n              node.parentNode.removeChild(node.nextSibling);\n          }\n          this.setToMarker(marker);\n      }\n      replaceNodeWithMarker() {\n          const marker = ElementSyntax.createMarker();\n          const node = this.node;\n          if (node.parentNode) {\n              node.parentNode.replaceChild(marker.node, node);\n          }\n          else if (this.isTemplate) {\n              node.content.appendChild(marker.node);\n          }\n          this.setToMarker(marker);\n      }\n      lift(instruction) {\n          const template = instruction.def.template = runtime.DOM.createElement('template');\n          const node = this.node;\n          if (this.isTemplate) {\n              // copy remaining attributes over to the newly created template\n              const attributes = node.attributes;\n              while (attributes.length) {\n                  const attr = attributes[0];\n                  template.setAttribute(attr.name, attr.value);\n                  node.removeAttribute(attr.name);\n              }\n              template.content.appendChild(node.content);\n              this.replaceNodeWithMarker();\n          }\n          else {\n              this.replaceNodeWithMarker();\n              template.content.appendChild(node);\n          }\n          this.addInstructions([instruction]);\n          this._isLifted = true;\n          return this.semanticModel.getTemplateElementSymbol(this.semanticModel.elParser.parse(template), this, instruction.def, null);\n      }\n      addInstructions(instructions) {\n          const def = this.$root.definition;\n          if (def.instructions === kernel.PLATFORM.emptyArray) {\n              def.instructions = [];\n          }\n          def.instructions.push(instructions);\n      }\n      setToMarker(marker) {\n          this._$content = null;\n          this._isCustomElement = this._isLet = this._isSlot = this._isTemplate = false;\n          this._isMarker = true;\n          this._name = 'AU-MARKER';\n          this._node = marker.node;\n          this._syntax = marker;\n      }\n  }\n\n  exports.TemplateCompiler = class TemplateCompiler {\n      constructor(exprParser, elParser, attrParser) {\n          this.exprParser = exprParser;\n          this.elParser = elParser;\n          this.attrParser = attrParser;\n      }\n      get name() {\n          return 'default';\n      }\n      compile(definition, resources, flags) {\n          const model = SemanticModel.create(definition, resources, this.attrParser, this.elParser, this.exprParser);\n          const root = model.root;\n          let $el = root.isTemplate ? root.$content : root;\n          while ($el = this.compileNode($el))\n              ;\n          // the flag should be passed correctly from rendering engine\n          if (root.isTemplate && (flags & runtime.ViewCompileFlags.surrogate)) {\n              this.compileSurrogate(root);\n          }\n          return definition;\n      }\n      compileNode($el) {\n          const node = $el.node;\n          const nextSibling = $el.nextSibling;\n          switch (node.nodeType) {\n              case 1 /* Element */:\n                  if ($el.isSlot) {\n                      $el.$root.definition.hasSlots = true;\n                  }\n                  else if ($el.isLet) {\n                      this.compileLetElement($el);\n                  }\n                  else if ($el.isCustomElement) {\n                      this.compileCustomElement($el);\n                  }\n                  else {\n                      this.compileElementNode($el);\n                  }\n                  if (!$el.isLifted) {\n                      let $child = $el.firstChild || $el.$content;\n                      while ($child) {\n                          $child = this.compileNode($child);\n                      }\n                  }\n                  return nextSibling;\n              case 3 /* Text */:\n                  const expression = this.exprParser.parse($el.node.wholeText, 2048 /* Interpolation */);\n                  if (expression === null) {\n                      while (($el = $el.nextSibling) && $el.node.nodeType === 3 /* Text */)\n                          ;\n                      return $el;\n                  }\n                  $el.replaceTextNodeWithMarker();\n                  $el.addInstructions([new TextBindingInstruction(expression)]);\n                  return nextSibling;\n              case 8 /* Comment */:\n                  return nextSibling;\n              case 9 /* Document */:\n                  return $el.firstChild;\n              case 10 /* DocumentType */:\n                  return nextSibling;\n              case 11 /* DocumentFragment */:\n                  return $el.firstChild;\n          }\n      }\n      compileSurrogate($el) {\n          const attributes = $el.$attributes;\n          for (let i = 0, ii = attributes.length; i < ii; ++i) {\n              const $attr = attributes[i];\n              if ($attr.isTemplateController) {\n                  throw new Error('Cannot have template controller on surrogate element.');\n              }\n              const instruction = this.compileAttribute($attr);\n              if (instruction !== null) {\n                  $el.definition.surrogates.push(instruction);\n              }\n              else {\n                  let attrInst;\n                  // Doesn't make sense for these properties as they need to be unique\n                  const name = $attr.target;\n                  if (name !== 'id' && name !== 'part' && name !== 'replace-part') {\n                      switch (name) {\n                          // TODO: handle simple surrogate style attribute\n                          case 'style':\n                              attrInst = new SetAttributeInstruction($attr.rawValue, name);\n                              break;\n                          default:\n                              attrInst = new SetAttributeInstruction($attr.rawValue, name);\n                      }\n                      $el.definition.surrogates.push(attrInst);\n                  }\n                  else {\n                      throw new Error(`Invalid surrogate attribute: ${name}`);\n                  }\n              }\n          }\n      }\n      compileElementNode($el) {\n          if ($el.$attributes.length === 0) {\n              return;\n          }\n          const attributes = $el.$attributes;\n          const attributeInstructions = [];\n          for (let i = 0, ii = attributes.length; i < ii; ++i) {\n              const $attr = attributes[i];\n              if ($attr.isProcessed)\n                  continue;\n              $attr.markAsProcessed();\n              if ($attr.isTemplateController) {\n                  let instruction = this.compileAttribute($attr);\n                  // compileAttribute will return a HydrateTemplateController if there is a binding command registered that produces one (in our case only \"for\")\n                  if (instruction.type !== \"m\" /* hydrateTemplateController */) {\n                      const name = $attr.res;\n                      instruction = new HydrateTemplateController({ name, instructions: [] }, name, [instruction], name === 'else');\n                  }\n                  // all attribute instructions preceding the template controller become children of the hydrate instruction\n                  instruction.instructions.push(...attributeInstructions);\n                  this.compileNode($el.lift(instruction));\n                  return;\n              }\n              else if ($attr.isCustomAttribute) {\n                  attributeInstructions.push(this.compileCustomAttribute($attr));\n              }\n              else {\n                  const instruction = this.compileAttribute($attr);\n                  if (instruction !== null) {\n                      attributeInstructions.push(instruction);\n                  }\n              }\n          }\n          if (attributeInstructions.length) {\n              $el.addInstructions(attributeInstructions);\n              $el.makeTarget();\n          }\n      }\n      compileCustomElement($el) {\n          if ($el.$attributes.length === 0) {\n              $el.addInstructions([new HydrateElementInstruction($el.definition.name, kernel.PLATFORM.emptyArray)]);\n              if ($el.definition.containerless) {\n                  $el.replaceNodeWithMarker();\n              }\n              else {\n                  $el.makeTarget();\n              }\n              return;\n          }\n          const attributeInstructions = [];\n          // if there is a custom element, then only the attributes that map to bindables become children of the hydrate instruction,\n          // otherwise they become sibling instructions; if there is no custom element, then sibling instructions are never appended to\n          const siblingInstructions = [];\n          const attributes = $el.$attributes;\n          for (let i = 0, ii = attributes.length; i < ii; ++i) {\n              const $attr = attributes[i];\n              if ($attr.isProcessed)\n                  continue;\n              $attr.markAsProcessed();\n              if ($attr.isTemplateController) {\n                  let instruction = this.compileAttribute($attr);\n                  // compileAttribute will return a HydrateTemplateController if there is a binding command registered that produces one (in our case only \"for\")\n                  if (instruction.type !== \"m\" /* hydrateTemplateController */) {\n                      const name = $attr.res;\n                      instruction = new HydrateTemplateController({ name, instructions: [] }, name, [instruction], name === 'else');\n                  }\n                  // all attribute instructions preceding the template controller become children of the hydrate instruction\n                  instruction.instructions.push(...attributeInstructions);\n                  this.compileNode($el.lift(instruction));\n                  return;\n              }\n              else if ($attr.isCustomAttribute) {\n                  if ($attr.isAttributeBindable) {\n                      siblingInstructions.push(this.compileCustomAttribute($attr));\n                  }\n                  else {\n                      attributeInstructions.push(this.compileCustomAttribute($attr));\n                  }\n              }\n              else {\n                  const instruction = this.compileAttribute($attr);\n                  if (instruction !== null) {\n                      if (!$attr.isElementBindable) {\n                          siblingInstructions.push(instruction);\n                      }\n                      else {\n                          attributeInstructions.push(instruction);\n                      }\n                  }\n              }\n          }\n          $el.addInstructions([new HydrateElementInstruction($el.definition.name, attributeInstructions), ...siblingInstructions]);\n          if ($el.definition.containerless) {\n              $el.replaceNodeWithMarker();\n          }\n          else {\n              $el.makeTarget();\n          }\n      }\n      compileCustomAttribute($attr) {\n          const childInstructions = [];\n          if ($attr.isMultiAttrBinding) {\n              const mBindings = $attr.$multiAttrBindings;\n              for (let j = 0, jj = mBindings.length; j < jj; ++j) {\n                  childInstructions.push(this.compileAttribute(mBindings[j]));\n              }\n          }\n          else {\n              childInstructions.push(this.compileAttribute($attr));\n          }\n          return new HydrateAttributeInstruction($attr.res, childInstructions);\n      }\n      compileLetElement($el) {\n          const letInstructions = [];\n          const attributes = $el.$attributes;\n          let toViewModel = false;\n          for (let i = 0, ii = attributes.length; ii > i; ++i) {\n              const $attr = attributes[i];\n              const to = kernel.PLATFORM.camelCase($attr.to);\n              if ($attr.hasBindingCommand) {\n                  const expr = this.exprParser.parse($attr.rawValue, 53 /* BindCommand */);\n                  letInstructions.push(new LetBindingInstruction(expr, to));\n              }\n              else if ($attr.rawName === 'to-view-model') {\n                  toViewModel = true;\n                  $el.node.removeAttribute('to-view-model');\n              }\n              else {\n                  const expr = this.exprParser.parse($attr.rawValue, 2048 /* Interpolation */);\n                  if (expr === null) {\n                      // Should just be a warning, but throw for now\n                      throw new Error(`Invalid let binding. String liternal given for attribute: ${$attr.to}`);\n                  }\n                  letInstructions.push(new LetBindingInstruction(expr, to));\n              }\n          }\n          $el.addInstructions([new LetElementInstruction(letInstructions, toViewModel)]);\n          // theoretically there's no need to replace, but to keep it consistent\n          $el.replaceNodeWithMarker();\n      }\n      compileAttribute($attr) {\n          // binding commands get priority over all; they may override default behaviors\n          // it is the responsibility of the implementor to ensure they filter out stuff they shouldn't override\n          if ($attr.isHandledByBindingCommand) {\n              return $attr.command.compile($attr);\n          }\n          // simple path for ref binding\n          const parser = this.exprParser;\n          if ($attr.target === 'ref') {\n              return new RefBindingInstruction(parser.parse($attr.rawValue, 1280 /* IsRef */));\n          }\n          // simple path for style bindings (TODO: this doesnt work, but we need to use StylePropertyBindingInstruction right?)\n          // if (target === 'style' || target === 'css') {\n          //   const expression = parser.parse(value, BindingType.Interpolation);\n          //   if (expression === null) {\n          //     return null;\n          //   }\n          //   return new StylePropertyBindingInstruction(expression, target);\n          // }\n          // plain custom attribute on any kind of element\n          if ($attr.isCustomAttribute) {\n              if (!$attr.hasBindingCommand) {\n                  const expression = parser.parse($attr.rawValue, 2048 /* Interpolation */);\n                  if (expression !== null) {\n                      return new InterpolationInstruction(expression, $attr.to);\n                  }\n                  if ($attr.isMultiAttrBinding) {\n                      return new SetPropertyInstruction($attr.rawValue, $attr.to);\n                  }\n              }\n              // intentional nested block without a statement to ensure the expression variable isn't shadowed\n              // (we're not declaring it at the outer block for better typing without explicit casting)\n              {\n                  const expression = parser.parse($attr.rawValue, 50 /* ToViewCommand */);\n                  switch ($attr.mode) {\n                      case runtime.BindingMode.oneTime:\n                          return new OneTimeBindingInstruction(expression, $attr.to);\n                      case runtime.BindingMode.fromView:\n                          return new FromViewBindingInstruction(expression, $attr.to);\n                      case runtime.BindingMode.twoWay:\n                          return new TwoWayBindingInstruction(expression, $attr.to);\n                      case runtime.BindingMode.toView:\n                      default:\n                          return new ToViewBindingInstruction(expression, $attr.to);\n                  }\n              }\n          }\n          // plain attribute on a custom element\n          if ($attr.onCustomElement) {\n              // bindable attribute\n              if ($attr.isElementBindable) {\n                  const expression = parser.parse($attr.rawValue, 2048 /* Interpolation */);\n                  if (expression === null) {\n                      // no interpolation -> make it a setProperty on the component\n                      return new SetPropertyInstruction($attr.rawValue, $attr.to);\n                  }\n                  // interpolation -> behave like toView (e.g. foo=\"${someProp}\")\n                  return new InterpolationInstruction(expression, $attr.to);\n              }\n          }\n          {\n              // plain attribute on a normal element\n              const expression = parser.parse($attr.rawValue, 2048 /* Interpolation */);\n              if (expression === null) {\n                  // no interpolation -> do not return an instruction\n                  return null;\n              }\n              // interpolation -> behave like toView (e.g. id=\"${someId}\")\n              return new InterpolationInstruction(expression, $attr.to);\n          }\n      }\n  };\n  exports.TemplateCompiler = __decorate([\n      kernel.inject(runtime.IExpressionParser, IElementParser, IAttributeParser)\n  ], exports.TemplateCompiler);\n\n  const globalResources = [\n      runtime.Compose,\n      runtime.If,\n      runtime.Else,\n      runtime.Repeat,\n      runtime.Replaceable,\n      runtime.With,\n      runtime.SanitizeValueConverter,\n      runtime.AttrBindingBehavior,\n      runtime.DebounceBindingBehavior,\n      runtime.OneTimeBindingBehavior,\n      runtime.ToViewBindingBehavior,\n      runtime.FromViewBindingBehavior,\n      runtime.SelfBindingBehavior,\n      runtime.SignalBindingBehavior,\n      runtime.ThrottleBindingBehavior,\n      runtime.TwoWayBindingBehavior,\n      runtime.UpdateTriggerBindingBehavior\n  ];\n  const defaultBindingLanguage = [\n      exports.DefaultBindingCommand,\n      exports.OneTimeBindingCommand,\n      exports.ToViewBindingCommand,\n      exports.FromViewBindingCommand,\n      exports.TwoWayBindingCommand,\n      exports.TriggerBindingCommand,\n      exports.DelegateBindingCommand,\n      exports.CaptureBindingCommand,\n      exports.CallBindingCommand,\n      exports.ForBindingCommand\n  ];\n  const BasicConfiguration = {\n      register(container) {\n          container.register(ParserRegistration, kernel.Registration.singleton(runtime.ITemplateCompiler, exports.TemplateCompiler), ...globalResources, ...defaultBindingLanguage);\n      }\n  };\n\n  exports.AttrSyntax = AttrSyntax;\n  exports.IAttributeParser = IAttributeParser;\n  exports.AttributeParser = AttributeParser;\n  exports.bindingCommand = bindingCommand;\n  exports.BindingCommandResource = BindingCommandResource;\n  exports.unescapeCode = unescapeCode;\n  exports.BasicConfiguration = BasicConfiguration;\n  exports.ElementSyntax = ElementSyntax;\n  exports.IElementParser = IElementParser;\n  exports.ParserRegistration = ParserRegistration;\n  exports.ParserState = ParserState;\n  exports.parseCore = parseCore;\n  exports.parse = parse;\n  exports.TextBindingInstruction = TextBindingInstruction;\n  exports.InterpolationInstruction = InterpolationInstruction;\n  exports.OneTimeBindingInstruction = OneTimeBindingInstruction;\n  exports.ToViewBindingInstruction = ToViewBindingInstruction;\n  exports.FromViewBindingInstruction = FromViewBindingInstruction;\n  exports.TwoWayBindingInstruction = TwoWayBindingInstruction;\n  exports.IteratorBindingInstruction = IteratorBindingInstruction;\n  exports.TriggerBindingInstruction = TriggerBindingInstruction;\n  exports.DelegateBindingInstruction = DelegateBindingInstruction;\n  exports.CaptureBindingInstruction = CaptureBindingInstruction;\n  exports.CallBindingInstruction = CallBindingInstruction;\n  exports.RefBindingInstruction = RefBindingInstruction;\n  exports.StylePropertyBindingInstruction = StylePropertyBindingInstruction;\n  exports.SetPropertyInstruction = SetPropertyInstruction;\n  exports.SetAttributeInstruction = SetAttributeInstruction;\n  exports.HydrateElementInstruction = HydrateElementInstruction;\n  exports.HydrateAttributeInstruction = HydrateAttributeInstruction;\n  exports.HydrateTemplateController = HydrateTemplateController;\n  exports.LetElementInstruction = LetElementInstruction;\n  exports.LetBindingInstruction = LetBindingInstruction;\n  exports.SemanticModel = SemanticModel;\n  exports.MultiAttributeBindingSymbol = MultiAttributeBindingSymbol;\n  exports.AttributeSymbol = AttributeSymbol;\n  exports.ElementSymbol = ElementSymbol;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvaml0L2Rpc3QvaW5kZXgudW1kLmpzPzBiZDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHlFQUFpQixHQUFHLG1CQUFPLENBQUMsMkVBQWtCO0FBQ3hJLEVBQUUsU0FDeUQ7QUFDM0QsQ0FBQywyQ0FBMkM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVSxHQUFHLEtBQUs7QUFDdEMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtFQUFrRSxtQ0FBbUM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsUUFBUTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0ZBQWdGLFFBQVE7QUFDeEY7QUFDQTtBQUNBLHlGQUF5RixRQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFFBQVE7QUFDbEc7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLFFBQVE7QUFDaEc7QUFDQTtBQUNBLDhFQUE4RSxRQUFRO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFFBQVE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsUUFBUTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxRQUFRO0FBQzlFO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxRQUFRO0FBQ2hGO0FBQ0E7QUFDQSx3RUFBd0UsUUFBUTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsUUFBUTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFFBQVE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsUUFBUTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUseUJBQXlCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxRQUFRO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUseUJBQXlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUseUJBQXlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLFNBQVM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxjQUFjOztBQUU5RCxDQUFDO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvaml0L2Rpc3QvaW5kZXgudW1kLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYXVyZWxpYS9rZXJuZWwnKSwgcmVxdWlyZSgnQGF1cmVsaWEvcnVudGltZScpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGF1cmVsaWEva2VybmVsJywgJ0BhdXJlbGlhL3J1bnRpbWUnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmppdCA9IHt9KSxnbG9iYWwua2VybmVsLGdsb2JhbC5ydW50aW1lKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxrZXJuZWwscnVudGltZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgY2xhc3MgQXR0clN5bnRheCB7XG4gICAgICBjb25zdHJ1Y3RvcihyYXdOYW1lLCByYXdWYWx1ZSwgdGFyZ2V0LCBjb21tYW5kKSB7XG4gICAgICAgICAgdGhpcy5yYXdOYW1lID0gcmF3TmFtZTtcbiAgICAgICAgICB0aGlzLnJhd1ZhbHVlID0gcmF3VmFsdWU7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcbiAgICAgIH1cbiAgfVxuICBjb25zdCBJQXR0cmlidXRlUGFyc2VyID0ga2VybmVsLkRJLmNyZWF0ZUludGVyZmFjZSgpXG4gICAgICAud2l0aERlZmF1bHQoeCA9PiB4LnNpbmdsZXRvbihBdHRyaWJ1dGVQYXJzZXIpKTtcbiAgLypAaW50ZXJuYWwqL1xuICBjbGFzcyBBdHRyaWJ1dGVQYXJzZXIge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgfVxuICAgICAgcGFyc2UobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICAgIGxldCBjb21tYW5kO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5jYWNoZVtuYW1lXTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbmFtZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobmFtZS5jaGFyQ29kZUF0KGkpID09PSA0NiAvKiBEb3QgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHRhcmdldE5hbWUgdG8gb25seSB0aGUgcGFydCB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgZmlyc3QgZG90XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBuYW1lLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbW1hbmQgPSBsYXN0SW5kZXggPiAwID8gbmFtZS5zbGljZShsYXN0SW5kZXggKyAxKSA6IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuY2FjaGVbbmFtZV0gPSBbdGFyZ2V0LCBjb21tYW5kXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldCA9IGV4aXN0aW5nWzBdO1xuICAgICAgICAgICAgICBjb21tYW5kID0gZXhpc3RpbmdbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQXR0clN5bnRheChuYW1lLCB2YWx1ZSwgdGFyZ2V0LCBjb21tYW5kICYmIGNvbW1hbmQubGVuZ3RoID8gY29tbWFuZCA6IG51bGwpO1xuICAgICAgfVxuICB9XG5cbiAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcbiAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcbiAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBUSElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcbiAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcbiAgTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cblxuICBTZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcbiAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4gIGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gIH1cblxuICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1yZXNlcnZlZC1rZXl3b3Jkc1xuICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1hbnlcbiAgY2xhc3MgVGV4dEJpbmRpbmdJbnN0cnVjdGlvbiB7XG4gICAgICBjb25zdHJ1Y3Rvcihmcm9tKSB7XG4gICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBcImFcIiAvKiB0ZXh0QmluZGluZyAqLztcbiAgICAgIH1cbiAgfVxuICBjbGFzcyBJbnRlcnBvbGF0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgICB0aGlzLnR5cGUgPSBcImJcIiAvKiBpbnRlcnBvbGF0aW9uICovO1xuICAgICAgfVxuICB9XG4gIGNsYXNzIE9uZVRpbWVCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgICB0aGlzLnR5cGUgPSBcImNcIiAvKiBwcm9wZXJ0eUJpbmRpbmcgKi87XG4gICAgICAgICAgdGhpcy5vbmVUaW1lID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm1vZGUgPSBydW50aW1lLkJpbmRpbmdNb2RlLm9uZVRpbWU7XG4gICAgICB9XG4gIH1cbiAgY2xhc3MgVG9WaWV3QmluZGluZ0luc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJjXCIgLyogcHJvcGVydHlCaW5kaW5nICovO1xuICAgICAgICAgIHRoaXMub25lVGltZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMubW9kZSA9IHJ1bnRpbWUuQmluZGluZ01vZGUudG9WaWV3O1xuICAgICAgfVxuICB9XG4gIGNsYXNzIEZyb21WaWV3QmluZGluZ0luc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJjXCIgLyogcHJvcGVydHlCaW5kaW5nICovO1xuICAgICAgICAgIHRoaXMub25lVGltZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMubW9kZSA9IHJ1bnRpbWUuQmluZGluZ01vZGUuZnJvbVZpZXc7XG4gICAgICB9XG4gIH1cbiAgY2xhc3MgVHdvV2F5QmluZGluZ0luc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJjXCIgLyogcHJvcGVydHlCaW5kaW5nICovO1xuICAgICAgICAgIHRoaXMub25lVGltZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMubW9kZSA9IHJ1bnRpbWUuQmluZGluZ01vZGUudHdvV2F5O1xuICAgICAgfVxuICB9XG4gIGNsYXNzIEl0ZXJhdG9yQmluZGluZ0luc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJkXCIgLyogaXRlcmF0b3JCaW5kaW5nICovO1xuICAgICAgfVxuICB9XG4gIGNsYXNzIFRyaWdnZXJCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgICB0aGlzLnR5cGUgPSBcImVcIiAvKiBsaXN0ZW5lckJpbmRpbmcgKi87XG4gICAgICAgICAgdGhpcy5zdHJhdGVneSA9IHJ1bnRpbWUuRGVsZWdhdGlvblN0cmF0ZWd5Lm5vbmU7XG4gICAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG4gIH1cbiAgY2xhc3MgRGVsZWdhdGVCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgICB0aGlzLnR5cGUgPSBcImVcIiAvKiBsaXN0ZW5lckJpbmRpbmcgKi87XG4gICAgICAgICAgdGhpcy5zdHJhdGVneSA9IHJ1bnRpbWUuRGVsZWdhdGlvblN0cmF0ZWd5LmJ1YmJsaW5nO1xuICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICAgIH1cbiAgfVxuICBjbGFzcyBDYXB0dXJlQmluZGluZ0luc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJlXCIgLyogbGlzdGVuZXJCaW5kaW5nICovO1xuICAgICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBydW50aW1lLkRlbGVnYXRpb25TdHJhdGVneS5jYXB0dXJpbmc7XG4gICAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgfVxuICB9XG4gIGNsYXNzIENhbGxCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgICB0aGlzLnR5cGUgPSBcImZcIiAvKiBjYWxsQmluZGluZyAqLztcbiAgICAgIH1cbiAgfVxuICBjbGFzcyBSZWZCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgICAgY29uc3RydWN0b3IoZnJvbSkge1xuICAgICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJnXCIgLyogcmVmQmluZGluZyAqLztcbiAgICAgIH1cbiAgfVxuICBjbGFzcyBTdHlsZVByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJoXCIgLyogc3R5bGVQcm9wZXJ0eUJpbmRpbmcgKi87XG4gICAgICB9XG4gIH1cbiAgY2xhc3MgU2V0UHJvcGVydHlJbnN0cnVjdGlvbiB7XG4gICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG8pIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICAgIHRoaXMudHlwZSA9IFwiaVwiIC8qIHNldFByb3BlcnR5ICovO1xuICAgICAgfVxuICB9XG4gIGNsYXNzIFNldEF0dHJpYnV0ZUluc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0bykge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJqXCIgLyogc2V0QXR0cmlidXRlICovO1xuICAgICAgfVxuICB9XG4gIGNsYXNzIEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24ge1xuICAgICAgY29uc3RydWN0b3IocmVzLCBpbnN0cnVjdGlvbnMsIHBhcnRzLCBjb250ZW50T3ZlcnJpZGUpIHtcbiAgICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICAgICAgdGhpcy5jb250ZW50T3ZlcnJpZGUgPSBjb250ZW50T3ZlcnJpZGU7XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJrXCIgLyogaHlkcmF0ZUVsZW1lbnQgKi87XG4gICAgICB9XG4gIH1cbiAgY2xhc3MgSHlkcmF0ZUF0dHJpYnV0ZUluc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKHJlcywgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJsXCIgLyogaHlkcmF0ZUF0dHJpYnV0ZSAqLztcbiAgICAgIH1cbiAgfVxuICBjbGFzcyBIeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKGRlZiwgcmVzLCBpbnN0cnVjdGlvbnMsIGxpbmspIHtcbiAgICAgICAgICB0aGlzLmRlZiA9IGRlZjtcbiAgICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgICB0aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgICAgIHRoaXMudHlwZSA9IFwibVwiIC8qIGh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIgKi87XG4gICAgICB9XG4gIH1cbiAgY2xhc3MgTGV0RWxlbWVudEluc3RydWN0aW9uIHtcbiAgICAgIGNvbnN0cnVjdG9yKGluc3RydWN0aW9ucywgdG9WaWV3TW9kZWwpIHtcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgICB0aGlzLnRvVmlld01vZGVsID0gdG9WaWV3TW9kZWw7XG4gICAgICAgICAgdGhpcy50eXBlID0gXCJuXCIgLyogbGV0RWxlbWVudCAqLztcbiAgICAgIH1cbiAgfVxuICBjbGFzcyBMZXRCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgICB0aGlzLnR5cGUgPSBcIm9cIiAvKiBsZXRCaW5kaW5nICovO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmluZGluZ0NvbW1hbmQobmFtZU9yU291cmNlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBCaW5kaW5nQ29tbWFuZFJlc291cmNlLmRlZmluZShuYW1lT3JTb3VyY2UsIHRhcmdldCk7XG4gICAgICB9O1xuICB9XG4gIGNvbnN0IEJpbmRpbmdDb21tYW5kUmVzb3VyY2UgPSB7XG4gICAgICBuYW1lOiAnYmluZGluZy1jb21tYW5kJyxcbiAgICAgIGtleUZyb20obmFtZSkge1xuICAgICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9OiR7bmFtZX1gO1xuICAgICAgfSxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1yZXNlcnZlZC1rZXl3b3Jkc1xuICAgICAgaXNUeXBlKHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZS5raW5kID09PSB0aGlzO1xuICAgICAgfSxcbiAgICAgIGRlZmluZShuYW1lT3JTb3VyY2UsIGN0b3IpIHtcbiAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHR5cGVvZiBuYW1lT3JTb3VyY2UgPT09ICdzdHJpbmcnID8geyBuYW1lOiBuYW1lT3JTb3VyY2UsIHRhcmdldDogbnVsbCB9IDogbmFtZU9yU291cmNlO1xuICAgICAgICAgIGNvbnN0IFR5cGUgPSBjdG9yO1xuICAgICAgICAgIFR5cGUua2luZCA9IEJpbmRpbmdDb21tYW5kUmVzb3VyY2U7XG4gICAgICAgICAgVHlwZS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgIFR5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlcihrZXJuZWwuUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihUeXBlLmtpbmQua2V5RnJvbShkZXNjcmlwdGlvbi5uYW1lKSwgVHlwZSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgcHJvdG8gPSBUeXBlLnByb3RvdHlwZTtcbiAgICAgICAgICBwcm90by5oYW5kbGVzID0gcHJvdG8uaGFuZGxlcyB8fCBkZWZhdWx0SGFuZGxlcztcbiAgICAgICAgICByZXR1cm4gVHlwZTtcbiAgICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZGVmYXVsdEhhbmRsZXMoJHN5bWJvbCkge1xuICAgICAgcmV0dXJuICEkc3ltYm9sLmlzVGVtcGxhdGVDb250cm9sbGVyO1xuICB9XG4gIGV4cG9ydHMuT25lVGltZUJpbmRpbmdDb21tYW5kID0gY2xhc3MgT25lVGltZUJpbmRpbmdDb21tYW5kIHtcbiAgICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgfVxuICAgICAgY29tcGlsZSgkc3ltYm9sKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPbmVUaW1lQmluZGluZ0luc3RydWN0aW9uKHRoaXMucGFyc2VyLnBhcnNlKCRzeW1ib2wucmF3VmFsdWUsIDQ5IC8qIE9uZVRpbWVDb21tYW5kICovKSwgJHN5bWJvbC50byk7XG4gICAgICB9XG4gIH07XG4gIGV4cG9ydHMuT25lVGltZUJpbmRpbmdDb21tYW5kLmluamVjdCA9IFtydW50aW1lLklFeHByZXNzaW9uUGFyc2VyXTtcbiAgZXhwb3J0cy5PbmVUaW1lQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICAgIGJpbmRpbmdDb21tYW5kKCdvbmUtdGltZScpXG4gIF0sIGV4cG9ydHMuT25lVGltZUJpbmRpbmdDb21tYW5kKTtcbiAgZXhwb3J0cy5Ub1ZpZXdCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIFRvVmlld0JpbmRpbmdDb21tYW5kIHtcbiAgICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgfVxuICAgICAgY29tcGlsZSgkc3ltYm9sKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUb1ZpZXdCaW5kaW5nSW5zdHJ1Y3Rpb24odGhpcy5wYXJzZXIucGFyc2UoJHN5bWJvbC5yYXdWYWx1ZSwgNTAgLyogVG9WaWV3Q29tbWFuZCAqLyksICRzeW1ib2wudG8pO1xuICAgICAgfVxuICB9O1xuICBleHBvcnRzLlRvVmlld0JpbmRpbmdDb21tYW5kLmluamVjdCA9IFtydW50aW1lLklFeHByZXNzaW9uUGFyc2VyXTtcbiAgZXhwb3J0cy5Ub1ZpZXdCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgICAgYmluZGluZ0NvbW1hbmQoJ3RvLXZpZXcnKVxuICBdLCBleHBvcnRzLlRvVmlld0JpbmRpbmdDb21tYW5kKTtcbiAgZXhwb3J0cy5Gcm9tVmlld0JpbmRpbmdDb21tYW5kID0gY2xhc3MgRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCB7XG4gICAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGUoJHN5bWJvbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRnJvbVZpZXdCaW5kaW5nSW5zdHJ1Y3Rpb24odGhpcy5wYXJzZXIucGFyc2UoJHN5bWJvbC5yYXdWYWx1ZSwgNTEgLyogRnJvbVZpZXdDb21tYW5kICovKSwgJHN5bWJvbC50byk7XG4gICAgICB9XG4gIH07XG4gIGV4cG9ydHMuRnJvbVZpZXdCaW5kaW5nQ29tbWFuZC5pbmplY3QgPSBbcnVudGltZS5JRXhwcmVzc2lvblBhcnNlcl07XG4gIGV4cG9ydHMuRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgICAgYmluZGluZ0NvbW1hbmQoJ2Zyb20tdmlldycpXG4gIF0sIGV4cG9ydHMuRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCk7XG4gIGV4cG9ydHMuVHdvV2F5QmluZGluZ0NvbW1hbmQgPSBjbGFzcyBUd29XYXlCaW5kaW5nQ29tbWFuZCB7XG4gICAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGUoJHN5bWJvbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVHdvV2F5QmluZGluZ0luc3RydWN0aW9uKHRoaXMucGFyc2VyLnBhcnNlKCRzeW1ib2wucmF3VmFsdWUsIDUyIC8qIFR3b1dheUNvbW1hbmQgKi8pLCAkc3ltYm9sLnRvKTtcbiAgICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5Ud29XYXlCaW5kaW5nQ29tbWFuZC5pbmplY3QgPSBbcnVudGltZS5JRXhwcmVzc2lvblBhcnNlcl07XG4gIGV4cG9ydHMuVHdvV2F5QmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICAgIGJpbmRpbmdDb21tYW5kKCd0d28td2F5JylcbiAgXSwgZXhwb3J0cy5Ud29XYXlCaW5kaW5nQ29tbWFuZCk7XG4gIC8vIE5vdCBib3RoZXJpbmcgdG8gdGhyb3cgb24gbm9uLWV4aXN0aW5nIG1vZGVzLCBzaG91bGQgbmV2ZXIgaGFwcGVuIGFueXdheS5cbiAgLy8gS2VlcGluZyBhbGwgYXJyYXkgZWxlbWVudHMgb2YgdGhlIHNhbWUgdHlwZSBmb3IgYmV0dGVyIG9wdGltaXplYWJpbGl0eS5cbiAgY29uc3QgY29tcGlsZU1vZGUgPSBbJycsICckMScsICckMicsICcnLCAnJDQnLCAnJywgJyQ2J107XG4gIGV4cG9ydHMuRGVmYXVsdEJpbmRpbmdDb21tYW5kID0gY2xhc3MgRGVmYXVsdEJpbmRpbmdDb21tYW5kIHtcbiAgICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgfVxuICAgICAgY29tcGlsZSgkc3ltYm9sKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbY29tcGlsZU1vZGVbJHN5bWJvbC5tb2RlXV0oJHN5bWJvbCk7XG4gICAgICB9XG4gIH07XG4gIGV4cG9ydHMuRGVmYXVsdEJpbmRpbmdDb21tYW5kLmluamVjdCA9IFtydW50aW1lLklFeHByZXNzaW9uUGFyc2VyXTtcbiAgZXhwb3J0cy5EZWZhdWx0QmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICAgIGJpbmRpbmdDb21tYW5kKCdiaW5kJylcbiAgXSwgZXhwb3J0cy5EZWZhdWx0QmluZGluZ0NvbW1hbmQpO1xuICBleHBvcnRzLkRlZmF1bHRCaW5kaW5nQ29tbWFuZC5wcm90b3R5cGUuJDEgPSBleHBvcnRzLk9uZVRpbWVCaW5kaW5nQ29tbWFuZC5wcm90b3R5cGUuY29tcGlsZTtcbiAgZXhwb3J0cy5EZWZhdWx0QmluZGluZ0NvbW1hbmQucHJvdG90eXBlLiQyID0gZXhwb3J0cy5Ub1ZpZXdCaW5kaW5nQ29tbWFuZC5wcm90b3R5cGUuY29tcGlsZTtcbiAgZXhwb3J0cy5EZWZhdWx0QmluZGluZ0NvbW1hbmQucHJvdG90eXBlLiQ0ID0gZXhwb3J0cy5Gcm9tVmlld0JpbmRpbmdDb21tYW5kLnByb3RvdHlwZS5jb21waWxlO1xuICBleHBvcnRzLkRlZmF1bHRCaW5kaW5nQ29tbWFuZC5wcm90b3R5cGUuJDYgPSBleHBvcnRzLlR3b1dheUJpbmRpbmdDb21tYW5kLnByb3RvdHlwZS5jb21waWxlO1xuICBleHBvcnRzLlRyaWdnZXJCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIFRyaWdnZXJCaW5kaW5nQ29tbWFuZCB7XG4gICAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGUoJHN5bWJvbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVHJpZ2dlckJpbmRpbmdJbnN0cnVjdGlvbih0aGlzLnBhcnNlci5wYXJzZSgkc3ltYm9sLnJhd1ZhbHVlLCA4NiAvKiBUcmlnZ2VyQ29tbWFuZCAqLyksICRzeW1ib2wudG8pO1xuICAgICAgfVxuICB9O1xuICBleHBvcnRzLlRyaWdnZXJCaW5kaW5nQ29tbWFuZC5pbmplY3QgPSBbcnVudGltZS5JRXhwcmVzc2lvblBhcnNlcl07XG4gIGV4cG9ydHMuVHJpZ2dlckJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgICBiaW5kaW5nQ29tbWFuZCgndHJpZ2dlcicpXG4gIF0sIGV4cG9ydHMuVHJpZ2dlckJpbmRpbmdDb21tYW5kKTtcbiAgZXhwb3J0cy5EZWxlZ2F0ZUJpbmRpbmdDb21tYW5kID0gY2xhc3MgRGVsZWdhdGVCaW5kaW5nQ29tbWFuZCB7XG4gICAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGUoJHN5bWJvbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGVsZWdhdGVCaW5kaW5nSW5zdHJ1Y3Rpb24odGhpcy5wYXJzZXIucGFyc2UoJHN5bWJvbC5yYXdWYWx1ZSwgODggLyogRGVsZWdhdGVDb21tYW5kICovKSwgJHN5bWJvbC50byk7XG4gICAgICB9XG4gIH07XG4gIGV4cG9ydHMuRGVsZWdhdGVCaW5kaW5nQ29tbWFuZC5pbmplY3QgPSBbcnVudGltZS5JRXhwcmVzc2lvblBhcnNlcl07XG4gIGV4cG9ydHMuRGVsZWdhdGVCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgICAgYmluZGluZ0NvbW1hbmQoJ2RlbGVnYXRlJylcbiAgXSwgZXhwb3J0cy5EZWxlZ2F0ZUJpbmRpbmdDb21tYW5kKTtcbiAgZXhwb3J0cy5DYXB0dXJlQmluZGluZ0NvbW1hbmQgPSBjbGFzcyBDYXB0dXJlQmluZGluZ0NvbW1hbmQge1xuICAgICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICB9XG4gICAgICBjb21waWxlKCRzeW1ib2wpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENhcHR1cmVCaW5kaW5nSW5zdHJ1Y3Rpb24odGhpcy5wYXJzZXIucGFyc2UoJHN5bWJvbC5yYXdWYWx1ZSwgODcgLyogQ2FwdHVyZUNvbW1hbmQgKi8pLCAkc3ltYm9sLnRvKTtcbiAgICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5DYXB0dXJlQmluZGluZ0NvbW1hbmQuaW5qZWN0ID0gW3J1bnRpbWUuSUV4cHJlc3Npb25QYXJzZXJdO1xuICBleHBvcnRzLkNhcHR1cmVCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgICAgYmluZGluZ0NvbW1hbmQoJ2NhcHR1cmUnKVxuICBdLCBleHBvcnRzLkNhcHR1cmVCaW5kaW5nQ29tbWFuZCk7XG4gIGV4cG9ydHMuQ2FsbEJpbmRpbmdDb21tYW5kID0gY2xhc3MgQ2FsbEJpbmRpbmdDb21tYW5kIHtcbiAgICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgfVxuICAgICAgY29tcGlsZSgkc3ltYm9sKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDYWxsQmluZGluZ0luc3RydWN0aW9uKHRoaXMucGFyc2VyLnBhcnNlKCRzeW1ib2wucmF3VmFsdWUsIDE1MyAvKiBDYWxsQ29tbWFuZCAqLyksICRzeW1ib2wudG8pO1xuICAgICAgfVxuICB9O1xuICBleHBvcnRzLkNhbGxCaW5kaW5nQ29tbWFuZC5pbmplY3QgPSBbcnVudGltZS5JRXhwcmVzc2lvblBhcnNlcl07XG4gIGV4cG9ydHMuQ2FsbEJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgICBiaW5kaW5nQ29tbWFuZCgnY2FsbCcpXG4gIF0sIGV4cG9ydHMuQ2FsbEJpbmRpbmdDb21tYW5kKTtcbiAgZXhwb3J0cy5Gb3JCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIEZvckJpbmRpbmdDb21tYW5kIHtcbiAgICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgfVxuICAgICAgY29tcGlsZSgkc3ltYm9sKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0ge1xuICAgICAgICAgICAgICBuYW1lOiAncmVwZWF0JyxcbiAgICAgICAgICAgICAgdGVtcGxhdGU6ICRzeW1ib2wuJGVsZW1lbnQubm9kZSxcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIG5ldyBIeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyKGRlZiwgJ3JlcGVhdCcsIFtcbiAgICAgICAgICAgICAgbmV3IEl0ZXJhdG9yQmluZGluZ0luc3RydWN0aW9uKHRoaXMucGFyc2VyLnBhcnNlKCRzeW1ib2wucmF3VmFsdWUsIDUzOSAvKiBGb3JDb21tYW5kICovKSwgJ2l0ZW1zJyksXG4gICAgICAgICAgICAgIG5ldyBTZXRQcm9wZXJ0eUluc3RydWN0aW9uKCdpdGVtJywgJ2xvY2FsJylcbiAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmFsaWduXG4gICAgICAgICAgXSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgaGFuZGxlcygkc3ltYm9sKSB7XG4gICAgICAgICAgcmV0dXJuICRzeW1ib2wudGFyZ2V0ID09PSAncmVwZWF0JztcbiAgICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5Gb3JCaW5kaW5nQ29tbWFuZC5pbmplY3QgPSBbcnVudGltZS5JRXhwcmVzc2lvblBhcnNlcl07XG4gIGV4cG9ydHMuRm9yQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICAgIGJpbmRpbmdDb21tYW5kKCdmb3InKVxuICBdLCBleHBvcnRzLkZvckJpbmRpbmdDb21tYW5kKTtcblxuICAvKkBpbnRlcm5hbCovXG4gIGZ1bmN0aW9uIHVuZXNjYXBlQ29kZShjb2RlKSB7XG4gICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDk4IC8qIExvd2VyQiAqLzogcmV0dXJuIDggLyogQmFja3NwYWNlICovO1xuICAgICAgICAgIGNhc2UgMTE2IC8qIExvd2VyVCAqLzogcmV0dXJuIDkgLyogVGFiICovO1xuICAgICAgICAgIGNhc2UgMTEwIC8qIExvd2VyTiAqLzogcmV0dXJuIDEwIC8qIExpbmVGZWVkICovO1xuICAgICAgICAgIGNhc2UgMTE4IC8qIExvd2VyViAqLzogcmV0dXJuIDExIC8qIFZlcnRpY2FsVGFiICovO1xuICAgICAgICAgIGNhc2UgMTAyIC8qIExvd2VyRiAqLzogcmV0dXJuIDEyIC8qIEZvcm1GZWVkICovO1xuICAgICAgICAgIGNhc2UgMTE0IC8qIExvd2VyUiAqLzogcmV0dXJuIDEzIC8qIENhcnJpYWdlUmV0dXJuICovO1xuICAgICAgICAgIGNhc2UgMzQgLyogRG91YmxlUXVvdGUgKi86IHJldHVybiAzNCAvKiBEb3VibGVRdW90ZSAqLztcbiAgICAgICAgICBjYXNlIDM5IC8qIFNpbmdsZVF1b3RlICovOiByZXR1cm4gMzkgLyogU2luZ2xlUXVvdGUgKi87XG4gICAgICAgICAgY2FzZSA5MiAvKiBCYWNrc2xhc2ggKi86IHJldHVybiA5MiAvKiBCYWNrc2xhc2ggKi87XG4gICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGNvZGU7XG4gICAgICB9XG4gIH1cblxuICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1ub24tbnVsbC1hc3NlcnRpb25cbiAgY29uc3QgUGFyc2VyUmVnaXN0cmF0aW9uID0ge1xuICAgICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyVHJhbnNmb3JtZXIocnVudGltZS5JRXhwcmVzc2lvblBhcnNlciwgcGFyc2VyID0+IHtcbiAgICAgICAgICAgICAgcGFyc2VyWydwYXJzZUNvcmUnXSA9IHBhcnNlQ29yZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfTtcbiAgY29uc3QgJGZhbHNlID0gcnVudGltZS5QcmltaXRpdmVMaXRlcmFsLiRmYWxzZTtcbiAgY29uc3QgJHRydWUgPSBydW50aW1lLlByaW1pdGl2ZUxpdGVyYWwuJHRydWU7XG4gIGNvbnN0ICRudWxsID0gcnVudGltZS5QcmltaXRpdmVMaXRlcmFsLiRudWxsO1xuICBjb25zdCAkdW5kZWZpbmVkID0gcnVudGltZS5QcmltaXRpdmVMaXRlcmFsLiR1bmRlZmluZWQ7XG4gIGNvbnN0ICR0aGlzID0gcnVudGltZS5BY2Nlc3NUaGlzLiR0aGlzO1xuICBjb25zdCAkcGFyZW50ID0gcnVudGltZS5BY2Nlc3NUaGlzLiRwYXJlbnQ7XG4gIC8qQGludGVybmFsKi9cbiAgY2xhc3MgUGFyc2VyU3RhdGUge1xuICAgICAgZ2V0IHRva2VuUmF3KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnRJbmRleCwgdGhpcy5pbmRleCk7XG4gICAgICB9XG4gICAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IDE1NzI4NjQgLyogRU9GICovO1xuICAgICAgICAgIHRoaXMudG9rZW5WYWx1ZSA9ICcnO1xuICAgICAgICAgIHRoaXMuY3VycmVudENoYXIgPSBpbnB1dC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIHRoaXMuYXNzaWduYWJsZSA9IHRydWU7XG4gICAgICB9XG4gIH1cbiAgY29uc3QgJHN0YXRlID0gbmV3IFBhcnNlclN0YXRlKCcnKTtcbiAgLypAaW50ZXJuYWwqL1xuICBmdW5jdGlvbiBwYXJzZUNvcmUoaW5wdXQsIGJpbmRpbmdUeXBlKSB7XG4gICAgICAkc3RhdGUuaW5wdXQgPSBpbnB1dDtcbiAgICAgICRzdGF0ZS5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAkc3RhdGUuaW5kZXggPSAwO1xuICAgICAgJHN0YXRlLmN1cnJlbnRDaGFyID0gaW5wdXQuY2hhckNvZGVBdCgwKTtcbiAgICAgIHJldHVybiBwYXJzZSgkc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYxIC8qIFZhcmlhZGljICovLCBiaW5kaW5nVHlwZSA9PT0gdW5kZWZpbmVkID8gNTMgLyogQmluZENvbW1hbmQgKi8gOiBiaW5kaW5nVHlwZSk7XG4gIH1cbiAgLypAaW50ZXJuYWwqL1xuICBmdW5jdGlvbiBwYXJzZShzdGF0ZSwgYWNjZXNzLCBtaW5QcmVjZWRlbmNlLCBiaW5kaW5nVHlwZSkge1xuICAgICAgaWYgKHN0YXRlLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovKSB7XG4gICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50ZXJwb2xhdGlvbihzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAmIDEwNDg1NzYgLyogRXhwcmVzc2lvblRlcm1pbmFsICovKSB7XG4gICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDAgLyogSW52YWxpZEV4cHJlc3Npb25TdGFydCAqLywgeyBzdGF0ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gNDQ4IC8qIEJpbmFyeSAqLyA+IG1pblByZWNlZGVuY2U7XG4gICAgICBsZXQgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAmIDMyNzY4IC8qIFVuYXJ5T3AgKi8pIHtcbiAgICAgICAgICAvKiogcGFyc2VVbmFyeUV4cHJlc3Npb25cbiAgICAgICAgICAgKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy11bmFyeS1vcGVyYXRvcnNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFVuYXJ5RXhwcmVzc2lvbiA6XG4gICAgICAgICAgICogICAxLiBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXG4gICAgICAgICAgICogICAyLiB2b2lkIFVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgICAqICAgMy4gdHlwZW9mIFVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgICAqICAgNC4gKyBVbmFyeUV4cHJlc3Npb25cbiAgICAgICAgICAgKiAgIDUuIC0gVW5hcnlFeHByZXNzaW9uXG4gICAgICAgICAgICogICA2LiAhIFVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgICAqXG4gICAgICAgICAgICogSXNWYWxpZEFzc2lnbm1lbnRUYXJnZXRcbiAgICAgICAgICAgKiAgIDIsMyw0LDUsNiA9IGZhbHNlXG4gICAgICAgICAgICogICAxID0gc2VlIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuICAgICAgICAgICAqXG4gICAgICAgICAgICogTm90ZTogdGVjaG5pY2FsbHkgd2Ugc2hvdWxkIHRocm93IG9uICsrIC8gLS0gLyArKysgLyAtLS0sIGJ1dCB0aGVyZSdzIG5vdGhpbmcgdG8gZ2FpbiBmcm9tIHRoYXRcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBvcCA9IFRva2VuVmFsdWVzW3N0YXRlLmN1cnJlbnRUb2tlbiAmIDYzIC8qIFR5cGUgKi9dO1xuICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IHJ1bnRpbWUuVW5hcnkob3AsIHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDQ0OSAvKiBMZWZ0SGFuZFNpZGUgKi8sIGJpbmRpbmdUeXBlKSk7XG4gICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgLyoqIHBhcnNlUHJpbWFyeUV4cHJlc3Npb25cbiAgICAgICAgICAgKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcmltYXJ5LWV4cHJlc3Npb25cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFByaW1hcnlFeHByZXNzaW9uIDpcbiAgICAgICAgICAgKiAgIDEuIHRoaXNcbiAgICAgICAgICAgKiAgIDIuIElkZW50aWZpZXJOYW1lXG4gICAgICAgICAgICogICAzLiBMaXRlcmFsXG4gICAgICAgICAgICogICA0LiBBcnJheUxpdGVyYWxcbiAgICAgICAgICAgKiAgIDUuIE9iamVjdExpdGVyYWxcbiAgICAgICAgICAgKiAgIDYuIFRlbXBsYXRlTGl0ZXJhbFxuICAgICAgICAgICAqICAgNy4gUGFyZW50aGVzaXplZEV4cHJlc3Npb25cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIExpdGVyYWwgOlxuICAgICAgICAgICAqICAgIE51bGxMaXRlcmFsXG4gICAgICAgICAgICogICAgQm9vbGVhbkxpdGVyYWxcbiAgICAgICAgICAgKiAgICBOdW1lcmljTGl0ZXJhbFxuICAgICAgICAgICAqICAgIFN0cmluZ0xpdGVyYWxcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIDpcbiAgICAgICAgICAgKiAgICggQXNzaWdubWVudEV4cHJlc3Npb24gKVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogSXNWYWxpZEFzc2lnbm1lbnRUYXJnZXRcbiAgICAgICAgICAgKiAgIDEsMyw0LDUsNiw3ID0gZmFsc2VcbiAgICAgICAgICAgKiAgIDIgPSB0cnVlXG4gICAgICAgICAgICovXG4gICAgICAgICAgcHJpbWFyeTogc3dpdGNoIChzdGF0ZS5jdXJyZW50VG9rZW4pIHtcbiAgICAgICAgICAgICAgY2FzZSAzMDc3IC8qIFBhcmVudFNjb3BlICovOiAvLyAkcGFyZW50XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3MrKzsgLy8gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3VtZU9wdChzdGF0ZSwgMTYzOTIgLyogRG90ICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSAxNjM5MiAvKiBEb3QgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDIgLyogRG91YmxlRG90ICovLCB7IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiA9PT0gMTU3Mjg2NCAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDUgLyogRXhwZWN0ZWRJZGVudGlmaWVyICovLCB7IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gJiA1MjQyODggLyogQWNjZXNzU2NvcGVUZXJtaW5hbCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvciA9IGFjY2VzcyAmIDUxMSAvKiBBbmNlc3RvciAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYW5jZXN0b3IgPT09IDAgPyAkdGhpcyA6IGFuY2VzdG9yID09PSAxID8gJHBhcmVudCA6IG5ldyBydW50aW1lLkFjY2Vzc1RoaXMoYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3MgPSA1MTIgLyogVGhpcyAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcHJpbWFyeTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDMgLyogSW52YWxpZE1lbWJlckV4cHJlc3Npb24gKi8sIHsgc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoc3RhdGUuY3VycmVudFRva2VuID09PSAzMDc3IC8qIFBhcmVudFNjb3BlICovKTtcbiAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICBjYXNlIDEwMjQgLyogSWRlbnRpZmllciAqLzogLy8gaWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmdUeXBlICYgNTEyIC8qIElzSXRlcmF0b3IgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5CaW5kaW5nSWRlbnRpZmllcihzdGF0ZS50b2tlblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBydW50aW1lLkFjY2Vzc1Njb3BlKHN0YXRlLnRva2VuVmFsdWUsIGFjY2VzcyAmIDUxMSAvKiBBbmNlc3RvciAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gMTAyNCAvKiBTY29wZSAqLztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDMwNzYgLyogVGhpc1Njb3BlICovOiAvLyAkdGhpc1xuICAgICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICR0aGlzO1xuICAgICAgICAgICAgICAgICAgYWNjZXNzID0gNTEyIC8qIFRoaXMgKi87XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA2NzE3NTAgLyogT3BlblBhcmVuICovOiAvLyBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgICAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxODM1MDE4IC8qIENsb3NlUGFyZW4gKi8pO1xuICAgICAgICAgICAgICAgICAgYWNjZXNzID0gMCAvKiBSZXNldCAqLztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDY3MTc1NiAvKiBPcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlQXJyYXlMaXRlcmFsRXhwcmVzc2lvbihzdGF0ZSwgYWNjZXNzLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTMxMDc5IC8qIE9wZW5CcmFjZSAqLzpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24oc3RhdGUsIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGFjY2VzcyA9IDAgLyogUmVzZXQgKi87XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA1NDA3MTMgLyogVGVtcGxhdGVUYWlsICovOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IHJ1bnRpbWUuVGVtcGxhdGUoW3N0YXRlLnRva2VuVmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNTQwNzE0IC8qIFRlbXBsYXRlQ29udGludWF0aW9uICovOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VUZW1wbGF0ZShzdGF0ZSwgYWNjZXNzLCBiaW5kaW5nVHlwZSwgcmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDA5NiAvKiBTdHJpbmdMaXRlcmFsICovOlxuICAgICAgICAgICAgICBjYXNlIDgxOTIgLyogTnVtZXJpY0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5QcmltaXRpdmVMaXRlcmFsKHN0YXRlLnRva2VuVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIGFjY2VzcyA9IDAgLyogUmVzZXQgKi87XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyMDUwIC8qIE51bGxLZXl3b3JkICovOlxuICAgICAgICAgICAgICBjYXNlIDIwNTEgLyogVW5kZWZpbmVkS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgY2FzZSAyMDQ5IC8qIFRydWVLZXl3b3JkICovOlxuICAgICAgICAgICAgICBjYXNlIDIwNDggLyogRmFsc2VLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gVG9rZW5WYWx1ZXNbc3RhdGUuY3VycmVudFRva2VuICYgNjMgLyogVHlwZSAqL107XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgYWNjZXNzID0gMCAvKiBSZXNldCAqLztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmluZGV4ID49IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDQgLyogVW5leHBlY3RlZEVuZE9mRXhwcmVzc2lvbiAqLywgeyBzdGF0ZSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDEgLyogVW5jb25zdW1lZFRva2VuICovLCB7IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmluZGluZ1R5cGUgJiA1MTIgLyogSXNJdGVyYXRvciAqLykge1xuICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZvck9mU3RhdGVtZW50KHN0YXRlLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgaWYgKDQ0OSAvKiBMZWZ0SGFuZFNpZGUgKi8gPCBtaW5QcmVjZWRlbmNlKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIC8qKiBwYXJzZU1lbWJlckV4cHJlc3Npb24gKFRva2VuLkRvdCwgVG9rZW4uT3BlbkJyYWNrZXQsIFRva2VuLlRlbXBsYXRlQ29udGludWF0aW9uKVxuICAgICAgICAgICAqIE1lbWJlckV4cHJlc3Npb24gOlxuICAgICAgICAgICAqICAgMS4gUHJpbWFyeUV4cHJlc3Npb25cbiAgICAgICAgICAgKiAgIDIuIE1lbWJlckV4cHJlc3Npb24gWyBBc3NpZ25tZW50RXhwcmVzc2lvbiBdXG4gICAgICAgICAgICogICAzLiBNZW1iZXJFeHByZXNzaW9uIC4gSWRlbnRpZmllck5hbWVcbiAgICAgICAgICAgKiAgIDQuIE1lbWJlckV4cHJlc3Npb24gVGVtcGxhdGVMaXRlcmFsXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBJc1ZhbGlkQXNzaWdubWVudFRhcmdldFxuICAgICAgICAgICAqICAgMSw0ID0gZmFsc2VcbiAgICAgICAgICAgKiAgIDIsMyA9IHRydWVcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogcGFyc2VDYWxsRXhwcmVzc2lvbiAoVG9rZW4uT3BlblBhcmVuKVxuICAgICAgICAgICAqIENhbGxFeHByZXNzaW9uIDpcbiAgICAgICAgICAgKiAgIDEuIE1lbWJlckV4cHJlc3Npb24gQXJndW1lbnRzXG4gICAgICAgICAgICogICAyLiBDYWxsRXhwcmVzc2lvbiBBcmd1bWVudHNcbiAgICAgICAgICAgKiAgIDMuIENhbGxFeHByZXNzaW9uIFsgQXNzaWdubWVudEV4cHJlc3Npb24gXVxuICAgICAgICAgICAqICAgNC4gQ2FsbEV4cHJlc3Npb24gLiBJZGVudGlmaWVyTmFtZVxuICAgICAgICAgICAqICAgNS4gQ2FsbEV4cHJlc3Npb24gVGVtcGxhdGVMaXRlcmFsXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBJc1ZhbGlkQXNzaWdubWVudFRhcmdldFxuICAgICAgICAgICAqICAgMSwyLDUgPSBmYWxzZVxuICAgICAgICAgICAqICAgMyw0ID0gdHJ1ZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxldCBuYW1lID0gc3RhdGUudG9rZW5WYWx1ZTtcbiAgICAgICAgICB3aGlsZSAoKHN0YXRlLmN1cnJlbnRUb2tlbiAmIDE2Mzg0IC8qIExlZnRIYW5kU2lkZSAqLykgPiAwKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUuY3VycmVudFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDE2MzkyIC8qIERvdCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuY3VycmVudFRva2VuICYgMzA3MiAvKiBJZGVudGlmaWVyTmFtZSAqLykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDEwNSAvKiBFeHBlY3RlZElkZW50aWZpZXIgKi8sIHsgc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBzdGF0ZS50b2tlblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlICRUaGlzIHRvICRTY29wZSwgY2hhbmdlICRTY29wZSB0byAkTWVtYmVyLCBrZWVwICRNZW1iZXIgYXMtaXMsIGNoYW5nZSAkS2V5ZWQgdG8gJE1lbWJlciwgZGlzcmVnYXJkIG90aGVyIGZsYWdzXG4gICAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gKChhY2Nlc3MgJiAoNTEyIC8qIFRoaXMgKi8gfCAxMDI0IC8qIFNjb3BlICovKSkgPDwgMSkgfCAoYWNjZXNzICYgMjA0OCAvKiBNZW1iZXIgKi8pIHwgKChhY2Nlc3MgJiA0MDk2IC8qIEtleWVkICovKSA+PiAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSA2NzE3NTAgLyogT3BlblBhcmVuICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY2Nlc3MgPT09IDAgLyogUmVzZXQgKi8pIHsgLy8gaWYgdGhlIGxlZnQgaGFuZCBzaWRlIGlzIGEgbGl0ZXJhbCwgbWFrZSBzdXJlIHdlIHBhcnNlIGEgQ2FsbE1lbWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gMjA0OCAvKiBNZW1iZXIgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhY2Nlc3MgJiAxMDI0IC8qIFNjb3BlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBydW50aW1lLkFjY2Vzc1Njb3BlKG5hbWUsIHJlc3VsdC5hbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBpZiBpdCdzIG5vdCAkU2NvcGUsIGl0J3MgJE1lbWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5BY2Nlc3NNZW1iZXIocmVzdWx0LCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBjYXNlIDY3MTc1NiAvKiBPcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgIGFjY2VzcyA9IDQwOTYgLyogS2V5ZWQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IHJ1bnRpbWUuQWNjZXNzS2V5ZWQocmVzdWx0LCBwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWUoc3RhdGUsIDE4MzUwMjEgLyogQ2xvc2VCcmFja2V0ICovKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgNjcxNzUwIC8qIE9wZW5QYXJlbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmN1cnJlbnRUb2tlbiAhPT0gMTgzNTAxOCAvKiBDbG9zZVBhcmVuICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnN1bWVPcHQoc3RhdGUsIDE1NzI4NzUgLyogQ29tbWEgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxODM1MDE4IC8qIENsb3NlUGFyZW4gKi8pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhY2Nlc3MgJiAxMDI0IC8qIFNjb3BlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBydW50aW1lLkNhbGxTY29wZShuYW1lLCBhcmdzLCByZXN1bHQuYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhY2Nlc3MgJiAyMDQ4IC8qIE1lbWJlciAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5DYWxsTWVtYmVyKHJlc3VsdCwgbmFtZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5DYWxsRnVuY3Rpb24ocmVzdWx0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTQwNzEzIC8qIFRlbXBsYXRlVGFpbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5ncyA9IFtzdGF0ZS50b2tlblZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5UYWdnZWRUZW1wbGF0ZShzdHJpbmdzLCBzdHJpbmdzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDU0MDcxNCAvKiBUZW1wbGF0ZUNvbnRpbnVhdGlvbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZVRlbXBsYXRlKHN0YXRlLCBhY2Nlc3MsIGJpbmRpbmdUeXBlLCByZXN1bHQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgIGlmICg0NDggLyogQmluYXJ5ICovIDwgbWluUHJlY2VkZW5jZSlcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgLyoqIHBhcnNlQmluYXJ5RXhwcmVzc2lvblxuICAgICAgICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbXVsdGlwbGljYXRpdmUtb3BlcmF0b3JzXG4gICAgICAgKlxuICAgICAgICogTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uIDogKGxvY2FsIHByZWNlZGVuY2UgNilcbiAgICAgICAqICAgVW5hcnlFeHByZXNzaW9uXG4gICAgICAgKiAgIE11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbiAqIC8gJSBVbmFyeUV4cHJlc3Npb25cbiAgICAgICAqXG4gICAgICAgKiBBZGRpdGl2ZUV4cHJlc3Npb24gOiAobG9jYWwgcHJlY2VkZW5jZSA1KVxuICAgICAgICogICBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25cbiAgICAgICAqICAgQWRkaXRpdmVFeHByZXNzaW9uICsgLSBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb25cbiAgICAgICAqXG4gICAgICAgKiBSZWxhdGlvbmFsRXhwcmVzc2lvbiA6IChsb2NhbCBwcmVjZWRlbmNlIDQpXG4gICAgICAgKiAgIEFkZGl0aXZlRXhwcmVzc2lvblxuICAgICAgICogICBSZWxhdGlvbmFsRXhwcmVzc2lvbiA8ID4gPD0gPj0gaW5zdGFuY2VvZiBpbiBBZGRpdGl2ZUV4cHJlc3Npb25cbiAgICAgICAqXG4gICAgICAgKiBFcXVhbGl0eUV4cHJlc3Npb24gOiAobG9jYWwgcHJlY2VkZW5jZSAzKVxuICAgICAgICogICBSZWxhdGlvbmFsRXhwcmVzc2lvblxuICAgICAgICogICBFcXVhbGl0eUV4cHJlc3Npb24gPT0gIT0gPT09ICE9PSBSZWxhdGlvbmFsRXhwcmVzc2lvblxuICAgICAgICpcbiAgICAgICAqIExvZ2ljYWxBTkRFeHByZXNzaW9uIDogKGxvY2FsIHByZWNlZGVuY2UgMilcbiAgICAgICAqICAgRXF1YWxpdHlFeHByZXNzaW9uXG4gICAgICAgKiAgIExvZ2ljYWxBTkRFeHByZXNzaW9uICYmIEVxdWFsaXR5RXhwcmVzc2lvblxuICAgICAgICpcbiAgICAgICAqIExvZ2ljYWxPUkV4cHJlc3Npb24gOiAobG9jYWwgcHJlY2VkZW5jZSAxKVxuICAgICAgICogICBMb2dpY2FsQU5ERXhwcmVzc2lvblxuICAgICAgICogICBMb2dpY2FsT1JFeHByZXNzaW9uIHx8IExvZ2ljYWxBTkRFeHByZXNzaW9uXG4gICAgICAgKi9cbiAgICAgIHdoaWxlICgoc3RhdGUuY3VycmVudFRva2VuICYgNjU1MzYgLyogQmluYXJ5T3AgKi8pID4gMCkge1xuICAgICAgICAgIGNvbnN0IG9wVG9rZW4gPSBzdGF0ZS5jdXJyZW50VG9rZW47XG4gICAgICAgICAgaWYgKChvcFRva2VuICYgNDQ4IC8qIFByZWNlZGVuY2UgKi8pIDw9IG1pblByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IHJ1bnRpbWUuQmluYXJ5KFRva2VuVmFsdWVzW29wVG9rZW4gJiA2MyAvKiBUeXBlICovXSwgcmVzdWx0LCBwYXJzZShzdGF0ZSwgYWNjZXNzLCBvcFRva2VuICYgNDQ4IC8qIFByZWNlZGVuY2UgKi8sIGJpbmRpbmdUeXBlKSk7XG4gICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgaWYgKDYzIC8qIENvbmRpdGlvbmFsICovIDwgbWluUHJlY2VkZW5jZSlcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgLyoqXG4gICAgICAgKiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvblxuICAgICAgICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNwcm9kLUNvbmRpdGlvbmFsRXhwcmVzc2lvblxuICAgICAgICpcbiAgICAgICAqIENvbmRpdGlvbmFsRXhwcmVzc2lvbiA6XG4gICAgICAgKiAgIDEuIEJpbmFyeUV4cHJlc3Npb25cbiAgICAgICAqICAgMi4gQmluYXJ5RXhwcmVzc2lvbiA/IEFzc2lnbm1lbnRFeHByZXNzaW9uIDogQXNzaWdubWVudEV4cHJlc3Npb25cbiAgICAgICAqXG4gICAgICAgKiBJc1ZhbGlkQXNzaWdubWVudFRhcmdldFxuICAgICAgICogICAxLDIgPSBmYWxzZVxuICAgICAgICovXG4gICAgICBpZiAoY29uc3VtZU9wdChzdGF0ZSwgMTU3Mjg3OSAvKiBRdWVzdGlvbiAqLykpIHtcbiAgICAgICAgICBjb25zdCB5ZXMgPSBwYXJzZShzdGF0ZSwgYWNjZXNzLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxNTcyODc4IC8qIENvbG9uICovKTtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5Db25kaXRpb25hbChyZXN1bHQsIHllcywgcGFyc2Uoc3RhdGUsIGFjY2VzcywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgIGlmICg2MiAvKiBBc3NpZ24gKi8gPCBtaW5QcmVjZWRlbmNlKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAvKiogcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgICAgICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNwcm9kLUFzc2lnbm1lbnRFeHByZXNzaW9uXG4gICAgICAgKiBOb3RlOiBBc3NpZ25tZW50RXhwcmVzc2lvbiBoZXJlIGlzIGVxdWl2YWxlbnQgdG8gRVMgRXhwcmVzc2lvbiBiZWNhdXNlIHdlIGRvbid0IHBhcnNlIHRoZSBjb21tYSBvcGVyYXRvclxuICAgICAgICpcbiAgICAgICAqIEFzc2lnbm1lbnRFeHByZXNzaW9uIDpcbiAgICAgICAqICAgMS4gQ29uZGl0aW9uYWxFeHByZXNzaW9uXG4gICAgICAgKiAgIDIuIExlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgICAgICpcbiAgICAgICAqIElzVmFsaWRBc3NpZ25tZW50VGFyZ2V0XG4gICAgICAgKiAgIDEsMiA9IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIGlmIChjb25zdW1lT3B0KHN0YXRlLCAxMDQ4NjE1IC8qIEVxdWFscyAqLykpIHtcbiAgICAgICAgICBpZiAoIXN0YXRlLmFzc2lnbmFibGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDE1MCAvKiBOb3RBc3NpZ25hYmxlICovLCB7IHN0YXRlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5Bc3NpZ24ocmVzdWx0LCBwYXJzZShzdGF0ZSwgYWNjZXNzLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlKSk7XG4gICAgICB9XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICBpZiAoNjEgLyogVmFyaWFkaWMgKi8gPCBtaW5QcmVjZWRlbmNlKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAvKiogcGFyc2VWYWx1ZUNvbnZlcnRlclxuICAgICAgICovXG4gICAgICB3aGlsZSAoY29uc3VtZU9wdChzdGF0ZSwgMTU3Mjg4MyAvKiBCYXIgKi8pKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiA9PT0gMTU3Mjg2NCAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDExMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5hbWUgPSBzdGF0ZS50b2tlblZhbHVlO1xuICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgY29uc3QgYXJncyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgIHdoaWxlIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc4IC8qIENvbG9uICovKSkge1xuICAgICAgICAgICAgICBhcmdzLnB1c2gocGFyc2Uoc3RhdGUsIGFjY2VzcywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBuZXcgcnVudGltZS5WYWx1ZUNvbnZlcnRlcihyZXN1bHQsIG5hbWUsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgLyoqIHBhcnNlQmluZGluZ0JlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgIHdoaWxlIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODgwIC8qIEFtcGVyc2FuZCAqLykpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSAxNTcyODY0IC8qIEVPRiAqLykge1xuICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMTEzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHN0YXRlLnRva2VuVmFsdWU7XG4gICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgd2hpbGUgKGNvbnN1bWVPcHQoc3RhdGUsIDE1NzI4NzggLyogQ29sb24gKi8pKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZShzdGF0ZSwgYWNjZXNzLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBydW50aW1lLkJpbmRpbmdCZWhhdmlvcihyZXN1bHQsIG5hbWUsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAhPT0gMTU3Mjg2NCAvKiBFT0YgKi8pIHtcbiAgICAgICAgICBpZiAoYmluZGluZ1R5cGUgJiAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUudG9rZW5SYXcgPT09ICdvZicpIHtcbiAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDE1MSAvKiBVbmV4cGVjdGVkRm9yT2YgKi8sIHsgc3RhdGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDEgLyogVW5jb25zdW1lZFRva2VuICovLCB7IHN0YXRlIH0pO1xuICAgICAgfVxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogcGFyc2VBcnJheUxpdGVyYWxFeHByZXNzaW9uXG4gICAqIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jcHJvZC1BcnJheUxpdGVyYWxcbiAgICpcbiAgICogQXJyYXlMaXRlcmFsIDpcbiAgICogICBbIEVsaXNpb24ob3B0KSBdXG4gICAqICAgWyBFbGVtZW50TGlzdCBdXG4gICAqICAgWyBFbGVtZW50TGlzdCwgRWxpc2lvbihvcHQpIF1cbiAgICpcbiAgICogRWxlbWVudExpc3QgOlxuICAgKiAgIEVsaXNpb24ob3B0KSBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgKiAgIEVsZW1lbnRMaXN0LCBFbGlzaW9uKG9wdCkgQXNzaWdubWVudEV4cHJlc3Npb25cbiAgICpcbiAgICogRWxpc2lvbiA6XG4gICAqICAsXG4gICAqICBFbGlzaW9uICxcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXlMaXRlcmFsRXhwcmVzc2lvbihzdGF0ZSwgYWNjZXNzLCBiaW5kaW5nVHlwZSkge1xuICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IEFycmF5KCk7XG4gICAgICB3aGlsZSAoc3RhdGUuY3VycmVudFRva2VuICE9PSAxODM1MDIxIC8qIENsb3NlQnJhY2tldCAqLykge1xuICAgICAgICAgIGlmIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc1IC8qIENvbW1hICovKSkge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKCR1bmRlZmluZWQpO1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSAxODM1MDIxIC8qIENsb3NlQnJhY2tldCAqLykge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCgkdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUgJiB+NTEyIC8qIElzSXRlcmF0b3IgKi8pKTtcbiAgICAgICAgICAgICAgaWYgKGNvbnN1bWVPcHQoc3RhdGUsIDE1NzI4NzUgLyogQ29tbWEgKi8pKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSAxODM1MDIxIC8qIENsb3NlQnJhY2tldCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goJHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN1bWUoc3RhdGUsIDE4MzUwMjEgLyogQ2xvc2VCcmFja2V0ICovKTtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSAmIDUxMiAvKiBJc0l0ZXJhdG9yICovKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBydW50aW1lLkFycmF5QmluZGluZ1BhdHRlcm4oZWxlbWVudHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXcgcnVudGltZS5BcnJheUxpdGVyYWwoZWxlbWVudHMpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlRm9yT2ZTdGF0ZW1lbnQoc3RhdGUsIHJlc3VsdCkge1xuICAgICAgaWYgKChyZXN1bHQuJGtpbmQgJiA2NTUzNiAvKiBJc0ZvckRlY2xhcmF0aW9uICovKSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDYgLyogSW52YWxpZEZvckRlY2xhcmF0aW9uICovLCB7IHN0YXRlIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAhPT0gMTA1MTE3OSAvKiBPZktleXdvcmQgKi8pIHtcbiAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMTA2IC8qIEludmFsaWRGb3JEZWNsYXJhdGlvbiAqLywgeyBzdGF0ZSB9KTtcbiAgICAgIH1cbiAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHJlc3VsdDtcbiAgICAgIGNvbnN0IHN0YXRlbWVudCA9IHBhcnNlKHN0YXRlLCAwIC8qIFJlc2V0ICovLCA2MSAvKiBWYXJpYWRpYyAqLywgMCAvKiBOb25lICovKTtcbiAgICAgIHJldHVybiBuZXcgcnVudGltZS5Gb3JPZlN0YXRlbWVudChkZWNsYXJhdGlvbiwgc3RhdGVtZW50KTtcbiAgfVxuICAvKipcbiAgICogcGFyc2VPYmplY3RMaXRlcmFsRXhwcmVzc2lvblxuICAgKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3Byb2QtTGl0ZXJhbFxuICAgKlxuICAgKiBPYmplY3RMaXRlcmFsIDpcbiAgICogICB7IH1cbiAgICogICB7IFByb3BlcnR5RGVmaW5pdGlvbkxpc3QgfVxuICAgKlxuICAgKiBQcm9wZXJ0eURlZmluaXRpb25MaXN0IDpcbiAgICogICBQcm9wZXJ0eURlZmluaXRpb25cbiAgICogICBQcm9wZXJ0eURlZmluaXRpb25MaXN0LCBQcm9wZXJ0eURlZmluaXRpb25cbiAgICpcbiAgICogUHJvcGVydHlEZWZpbml0aW9uIDpcbiAgICogICBJZGVudGlmaWVyTmFtZVxuICAgKiAgIFByb3BlcnR5TmFtZSA6IEFzc2lnbm1lbnRFeHByZXNzaW9uXG4gICAqXG4gICAqIFByb3BlcnR5TmFtZSA6XG4gICAqICAgSWRlbnRpZmllck5hbWVcbiAgICogICBTdHJpbmdMaXRlcmFsXG4gICAqICAgTnVtZXJpY0xpdGVyYWxcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24oc3RhdGUsIGJpbmRpbmdUeXBlKSB7XG4gICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KCk7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICB3aGlsZSAoc3RhdGUuY3VycmVudFRva2VuICE9PSAxODM1MDE3IC8qIENsb3NlQnJhY2UgKi8pIHtcbiAgICAgICAgICBrZXlzLnB1c2goc3RhdGUudG9rZW5WYWx1ZSk7XG4gICAgICAgICAgLy8gTGl0ZXJhbCA9IG1hbmRhdG9yeSBjb2xvblxuICAgICAgICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gJiAxMjI4OCAvKiBTdHJpbmdPck51bWVyaWNMaXRlcmFsICovKSB7XG4gICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgIGNvbnN1bWUoc3RhdGUsIDE1NzI4NzggLyogQ29sb24gKi8pO1xuICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSAmIH41MTIgLyogSXNJdGVyYXRvciAqLykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gJiAzMDcyIC8qIElkZW50aWZpZXJOYW1lICovKSB7XG4gICAgICAgICAgICAgIC8vIElkZW50aWZpZXJOYW1lID0gb3B0aW9uYWwgY29sb25cbiAgICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50Q2hhciwgY3VycmVudFRva2VuLCBpbmRleCB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgIGlmIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc4IC8qIENvbG9uICovKSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2Uoc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUgJiB+NTEyIC8qIElzSXRlcmF0b3IgKi8pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNob3J0aGFuZFxuICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudENoYXIgPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRUb2tlbiA9IGN1cnJlbnRUb2tlbjtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNDUwIC8qIFByaW1hcnkgKi8sIGJpbmRpbmdUeXBlICYgfjUxMiAvKiBJc0l0ZXJhdG9yICovKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDcgLyogSW52YWxpZE9iamVjdExpdGVyYWxQcm9wZXJ0eURlZmluaXRpb24gKi8sIHsgc3RhdGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gIT09IDE4MzUwMTcgLyogQ2xvc2VCcmFjZSAqLykge1xuICAgICAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxNTcyODc1IC8qIENvbW1hICovKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdW1lKHN0YXRlLCAxODM1MDE3IC8qIENsb3NlQnJhY2UgKi8pO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgNTEyIC8qIElzSXRlcmF0b3IgKi8pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHJ1bnRpbWUuT2JqZWN0QmluZGluZ1BhdHRlcm4oa2V5cywgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV3IHJ1bnRpbWUuT2JqZWN0TGl0ZXJhbChrZXlzLCB2YWx1ZXMpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSW50ZXJwb2xhdGlvbihzdGF0ZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW107XG4gICAgICBjb25zdCBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICB3aGlsZSAoc3RhdGUuaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBzd2l0Y2ggKHN0YXRlLmN1cnJlbnRDaGFyKSB7XG4gICAgICAgICAgICAgIGNhc2UgMzYgLyogRG9sbGFyICovOlxuICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUuaW5kZXggKyAxKSA9PT0gMTIzIC8qIE9wZW5CcmFjZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRDaGFyID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2Uoc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYxIC8qIFZhcmlhZGljICovLCAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8pO1xuICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyQnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgOTIgLyogQmFja3NsYXNoICovOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodW5lc2NhcGVDb2RlKG5leHRDaGFyKHN0YXRlKSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGF0ZS5jdXJyZW50Q2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRDaGFyKHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBydW50aW1lLkludGVycG9sYXRpb24ocGFydHMsIGV4cHJlc3Npb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBwYXJzZVRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb25cbiAgICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNwcm9kLUxpdGVyYWxcbiAgICpcbiAgICogVGVtcGxhdGUgOlxuICAgKiAgIE5vU3Vic3RpdHV0aW9uVGVtcGxhdGVcbiAgICogICBUZW1wbGF0ZUhlYWRcbiAgICpcbiAgICogTm9TdWJzdGl0dXRpb25UZW1wbGF0ZSA6XG4gICAqICAgYCBUZW1wbGF0ZUNoYXJhY3RlcnMob3B0KSBgXG4gICAqXG4gICAqIFRlbXBsYXRlSGVhZCA6XG4gICAqICAgYCBUZW1wbGF0ZUNoYXJhY3RlcnMob3B0KSAke1xuICAgKlxuICAgKiBUZW1wbGF0ZVN1YnN0aXR1dGlvblRhaWwgOlxuICAgKiAgIFRlbXBsYXRlTWlkZGxlXG4gICAqICAgVGVtcGxhdGVUYWlsXG4gICAqXG4gICAqIFRlbXBsYXRlTWlkZGxlIDpcbiAgICogICB9IFRlbXBsYXRlQ2hhcmFjdGVycyhvcHQpICR7XG4gICAqXG4gICAqIFRlbXBsYXRlVGFpbCA6XG4gICAqICAgfSBUZW1wbGF0ZUNoYXJhY3RlcnMob3B0KSBgXG4gICAqXG4gICAqIFRlbXBsYXRlQ2hhcmFjdGVycyA6XG4gICAqICAgVGVtcGxhdGVDaGFyYWN0ZXIgVGVtcGxhdGVDaGFyYWN0ZXJzKG9wdClcbiAgICpcbiAgICogVGVtcGxhdGVDaGFyYWN0ZXIgOlxuICAgKiAgICQgW2xvb2thaGVhZCDiiaAge11cbiAgICogICBcXCBFc2NhcGVTZXF1ZW5jZVxuICAgKiAgIFNvdXJjZUNoYXJhY3RlciAoYnV0IG5vdCBvbmUgb2YgYCBvciBcXCBvciAkKVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZShzdGF0ZSwgYWNjZXNzLCBiaW5kaW5nVHlwZSwgcmVzdWx0LCB0YWdnZWQpIHtcbiAgICAgIGNvbnN0IGNvb2tlZCA9IFtzdGF0ZS50b2tlblZhbHVlXTtcbiAgICAgIC8vY29uc3QgcmF3ID0gW3N0YXRlLnRva2VuUmF3XTtcbiAgICAgIGNvbnN1bWUoc3RhdGUsIDU0MDcxNCAvKiBUZW1wbGF0ZUNvbnRpbnVhdGlvbiAqLyk7XG4gICAgICBjb25zdCBleHByZXNzaW9ucyA9IFtwYXJzZShzdGF0ZSwgYWNjZXNzLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlKV07XG4gICAgICB3aGlsZSAoKHN0YXRlLmN1cnJlbnRUb2tlbiA9IHNjYW5UZW1wbGF0ZVRhaWwoc3RhdGUpKSAhPT0gNTQwNzEzIC8qIFRlbXBsYXRlVGFpbCAqLykge1xuICAgICAgICAgIGNvb2tlZC5wdXNoKHN0YXRlLnRva2VuVmFsdWUpO1xuICAgICAgICAgIC8vIGlmICh0YWdnZWQpIHtcbiAgICAgICAgICAvLyAgIHJhdy5wdXNoKHN0YXRlLnRva2VuUmF3KTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgY29uc3VtZShzdGF0ZSwgNTQwNzE0IC8qIFRlbXBsYXRlQ29udGludWF0aW9uICovKTtcbiAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpKTtcbiAgICAgIH1cbiAgICAgIGNvb2tlZC5wdXNoKHN0YXRlLnRva2VuVmFsdWUpO1xuICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKHRhZ2dlZCkge1xuICAgICAgICAgIC8vcmF3LnB1c2goc3RhdGUudG9rZW5SYXcpO1xuICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBydW50aW1lLlRhZ2dlZFRlbXBsYXRlKGNvb2tlZCwgY29va2VkLCByZXN1bHQsIGV4cHJlc3Npb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBydW50aW1lLlRlbXBsYXRlKGNvb2tlZCwgZXhwcmVzc2lvbnMpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5leHRUb2tlbihzdGF0ZSkge1xuICAgICAgd2hpbGUgKHN0YXRlLmluZGV4IDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgc3RhdGUuc3RhcnRJbmRleCA9IHN0YXRlLmluZGV4O1xuICAgICAgICAgIGlmICgoc3RhdGUuY3VycmVudFRva2VuID0gQ2hhclNjYW5uZXJzW3N0YXRlLmN1cnJlbnRDaGFyXShzdGF0ZSkpICE9PSBudWxsKSB7IC8vIGEgbnVsbCB0b2tlbiBtZWFucyB0aGUgY2hhcmFjdGVyIG11c3QgYmUgc2tpcHBlZFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuY3VycmVudFRva2VuID0gMTU3Mjg2NCAvKiBFT0YgKi87XG4gIH1cbiAgZnVuY3Rpb24gbmV4dENoYXIoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5jdXJyZW50Q2hhciA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5pbmRleCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXIoc3RhdGUpIHtcbiAgICAgIC8vIHJ1biB0byB0aGUgbmV4dCBub24taWRQYXJ0XG4gICAgICB3aGlsZSAoSWRQYXJ0c1tuZXh0Q2hhcihzdGF0ZSldKVxuICAgICAgICAgIDtcbiAgICAgIGNvbnN0IHRva2VuID0gS2V5d29yZExvb2t1cFtzdGF0ZS50b2tlblZhbHVlID0gc3RhdGUudG9rZW5SYXddO1xuICAgICAgcmV0dXJuIHRva2VuID09PSB1bmRlZmluZWQgPyAxMDI0IC8qIElkZW50aWZpZXIgKi8gOiB0b2tlbjtcbiAgfVxuICBmdW5jdGlvbiBzY2FuTnVtYmVyKHN0YXRlLCBpc0Zsb2F0KSB7XG4gICAgICBsZXQgY2hhciA9IHN0YXRlLmN1cnJlbnRDaGFyO1xuICAgICAgaWYgKGlzRmxvYXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBjaGFyID0gbmV4dENoYXIoc3RhdGUpO1xuICAgICAgICAgIH0gd2hpbGUgKGNoYXIgPD0gNTcgLyogTmluZSAqLyAmJiBjaGFyID49IDQ4IC8qIFplcm8gKi8pO1xuICAgICAgICAgIGlmIChjaGFyICE9PSA0NiAvKiBEb3QgKi8pIHtcbiAgICAgICAgICAgICAgc3RhdGUudG9rZW5WYWx1ZSA9IHBhcnNlSW50KHN0YXRlLnRva2VuUmF3LCAxMCk7XG4gICAgICAgICAgICAgIHJldHVybiA4MTkyIC8qIE51bWVyaWNMaXRlcmFsICovO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBwYXN0IHRoaXMgcG9pbnQgaXQncyBhbHdheXMgYSBmbG9hdFxuICAgICAgICAgIGNoYXIgPSBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmluZGV4ID49IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyB1bmxlc3MgdGhlIG51bWJlciBlbmRzIHdpdGggYSBkb3QgLSB0aGF0IGJlaGF2ZXMgYSBsaXR0bGUgZGlmZmVyZW50IGluIG5hdGl2ZSBFUyBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAvLyBidXQgaW4gb3VyIEFTVCB0aGF0IGJlaGF2aW9yIGhhcyBubyBlZmZlY3QgYmVjYXVzZSBudW1iZXJzIGFyZSBhbHdheXMgc3RvcmVkIGluIHZhcmlhYmxlc1xuICAgICAgICAgICAgICBzdGF0ZS50b2tlblZhbHVlID0gcGFyc2VJbnQoc3RhdGUudG9rZW5SYXcuc2xpY2UoMCwgLTEpLCAxMCk7XG4gICAgICAgICAgICAgIHJldHVybiA4MTkyIC8qIE51bWVyaWNMaXRlcmFsICovO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGFyIDw9IDU3IC8qIE5pbmUgKi8gJiYgY2hhciA+PSA0OCAvKiBaZXJvICovKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBjaGFyID0gbmV4dENoYXIoc3RhdGUpO1xuICAgICAgICAgIH0gd2hpbGUgKGNoYXIgPD0gNTcgLyogTmluZSAqLyAmJiBjaGFyID49IDQ4IC8qIFplcm8gKi8pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RhdGUuY3VycmVudENoYXIgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KC0tc3RhdGUuaW5kZXgpO1xuICAgICAgfVxuICAgICAgc3RhdGUudG9rZW5WYWx1ZSA9IHBhcnNlRmxvYXQoc3RhdGUudG9rZW5SYXcpO1xuICAgICAgcmV0dXJuIDgxOTIgLyogTnVtZXJpY0xpdGVyYWwgKi87XG4gIH1cbiAgZnVuY3Rpb24gc2NhblN0cmluZyhzdGF0ZSkge1xuICAgICAgY29uc3QgcXVvdGUgPSBzdGF0ZS5jdXJyZW50Q2hhcjtcbiAgICAgIG5leHRDaGFyKHN0YXRlKTsgLy8gU2tpcCBpbml0aWFsIHF1b3RlLlxuICAgICAgbGV0IHVuZXNjYXBlZCA9IDA7XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoKTtcbiAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5pbmRleDtcbiAgICAgIHdoaWxlIChzdGF0ZS5jdXJyZW50Q2hhciAhPT0gcXVvdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudENoYXIgPT09IDkyIC8qIEJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgICBidWZmZXIucHVzaChzdGF0ZS5pbnB1dC5zbGljZShtYXJrZXIsIHN0YXRlLmluZGV4KSk7XG4gICAgICAgICAgICAgIG5leHRDaGFyKHN0YXRlKTtcbiAgICAgICAgICAgICAgdW5lc2NhcGVkID0gdW5lc2NhcGVDb2RlKHN0YXRlLmN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgICAgbmV4dENoYXIoc3RhdGUpO1xuICAgICAgICAgICAgICBidWZmZXIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHVuZXNjYXBlZCkpO1xuICAgICAgICAgICAgICBtYXJrZXIgPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc3RhdGUuaW5kZXggPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDggLyogVW50ZXJtaW5hdGVkUXVvdGUgKi8sIHsgc3RhdGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGFzdCA9IHN0YXRlLmlucHV0LnNsaWNlKG1hcmtlciwgc3RhdGUuaW5kZXgpO1xuICAgICAgbmV4dENoYXIoc3RhdGUpOyAvLyBTa2lwIHRlcm1pbmF0aW5nIHF1b3RlLlxuICAgICAgLy8gQ29tcHV0ZSB0aGUgdW5lc2NhcGVkIHN0cmluZyB2YWx1ZS5cbiAgICAgIGJ1ZmZlci5wdXNoKGxhc3QpO1xuICAgICAgY29uc3QgdW5lc2NhcGVkU3RyID0gYnVmZmVyLmpvaW4oJycpO1xuICAgICAgc3RhdGUudG9rZW5WYWx1ZSA9IHVuZXNjYXBlZFN0cjtcbiAgICAgIHJldHVybiA0MDk2IC8qIFN0cmluZ0xpdGVyYWwgKi87XG4gIH1cbiAgZnVuY3Rpb24gc2NhblRlbXBsYXRlKHN0YXRlKSB7XG4gICAgICBsZXQgdGFpbCA9IHRydWU7XG4gICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICB3aGlsZSAobmV4dENoYXIoc3RhdGUpICE9PSA5NiAvKiBCYWNrdGljayAqLykge1xuICAgICAgICAgIGlmIChzdGF0ZS5jdXJyZW50Q2hhciA9PT0gMzYgLyogRG9sbGFyICovKSB7XG4gICAgICAgICAgICAgIGlmICgoc3RhdGUuaW5kZXggKyAxKSA8IHN0YXRlLmxlbmd0aCAmJiBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLmluZGV4ICsgMSkgPT09IDEyMyAvKiBPcGVuQnJhY2UgKi8pIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB0YWlsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnJCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc3RhdGUuY3VycmVudENoYXIgPT09IDkyIC8qIEJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmVzY2FwZUNvZGUobmV4dENoYXIoc3RhdGUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaW5kZXggPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMTA5IC8qIFVudGVybWluYXRlZFRlbXBsYXRlICovLCB7IHN0YXRlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXRlLmN1cnJlbnRDaGFyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgICBzdGF0ZS50b2tlblZhbHVlID0gcmVzdWx0O1xuICAgICAgaWYgKHRhaWwpIHtcbiAgICAgICAgICByZXR1cm4gNTQwNzEzIC8qIFRlbXBsYXRlVGFpbCAqLztcbiAgICAgIH1cbiAgICAgIHJldHVybiA1NDA3MTQgLyogVGVtcGxhdGVDb250aW51YXRpb24gKi87XG4gIH1cbiAgZnVuY3Rpb24gc2NhblRlbXBsYXRlVGFpbChzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLmluZGV4ID49IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMDkgLyogVW50ZXJtaW5hdGVkVGVtcGxhdGUgKi8sIHsgc3RhdGUgfSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5pbmRleC0tO1xuICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZShzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gY29uc3VtZU9wdChzdGF0ZSwgdG9rZW4pIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwb3NzaWJsZS10aW1pbmctYXR0YWNrXG4gICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSB0b2tlbikge1xuICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gY29uc3VtZShzdGF0ZSwgdG9rZW4pIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwb3NzaWJsZS10aW1pbmctYXR0YWNrXG4gICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSB0b2tlbikge1xuICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMTEwIC8qIE1pc3NpbmdFeHBlY3RlZFRva2VuICovLCB7IHN0YXRlLCBleHBlY3RlZDogdG9rZW4gfSk7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFycmF5IGZvciBtYXBwaW5nIHRva2VucyB0byB0b2tlbiB2YWx1ZXMuIFRoZSBpbmRpY2VzIG9mIHRoZSB2YWx1ZXNcbiAgICogY29ycmVzcG9uZCB0byB0aGUgdG9rZW4gYml0cyAwLTM4LlxuICAgKiBGb3IgdGhpcyB0byB3b3JrIHByb3Blcmx5LCB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBtdXN0IGJlIGtlcHQgaW5cbiAgICogdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHRva2VuIGJpdHMuXG4gICAqIFVzYWdlOiBUb2tlblZhbHVlc1t0b2tlbiAmIFRva2VuLlR5cGVdXG4gICAqL1xuICBjb25zdCBUb2tlblZhbHVlcyA9IFtcbiAgICAgICRmYWxzZSwgJHRydWUsICRudWxsLCAkdW5kZWZpbmVkLCAnJHRoaXMnLCAnJHBhcmVudCcsXG4gICAgICAnKCcsICd7JywgJy4nLCAnfScsICcpJywgJywnLCAnWycsICddJywgJzonLCAnPycsICdcXCcnLCAnXCInLFxuICAgICAgJyYnLCAnfCcsICd8fCcsICcmJicsICc9PScsICchPScsICc9PT0nLCAnIT09JywgJzwnLCAnPicsXG4gICAgICAnPD0nLCAnPj0nLCAnaW4nLCAnaW5zdGFuY2VvZicsICcrJywgJy0nLCAndHlwZW9mJywgJ3ZvaWQnLCAnKicsICclJywgJy8nLCAnPScsICchJyxcbiAgICAgIDU0MDcxMyAvKiBUZW1wbGF0ZVRhaWwgKi8sIDU0MDcxNCAvKiBUZW1wbGF0ZUNvbnRpbnVhdGlvbiAqLyxcbiAgICAgICdvZidcbiAgXTtcbiAgY29uc3QgS2V5d29yZExvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEtleXdvcmRMb29rdXAudHJ1ZSA9IDIwNDkgLyogVHJ1ZUtleXdvcmQgKi87XG4gIEtleXdvcmRMb29rdXAubnVsbCA9IDIwNTAgLyogTnVsbEtleXdvcmQgKi87XG4gIEtleXdvcmRMb29rdXAuZmFsc2UgPSAyMDQ4IC8qIEZhbHNlS2V5d29yZCAqLztcbiAgS2V5d29yZExvb2t1cC51bmRlZmluZWQgPSAyMDUxIC8qIFVuZGVmaW5lZEtleXdvcmQgKi87XG4gIEtleXdvcmRMb29rdXAuJHRoaXMgPSAzMDc2IC8qIFRoaXNTY29wZSAqLztcbiAgS2V5d29yZExvb2t1cC4kcGFyZW50ID0gMzA3NyAvKiBQYXJlbnRTY29wZSAqLztcbiAgS2V5d29yZExvb2t1cC5pbiA9IDE2NDA3OTggLyogSW5LZXl3b3JkICovO1xuICBLZXl3b3JkTG9va3VwLmluc3RhbmNlb2YgPSAxNjQwNzk5IC8qIEluc3RhbmNlT2ZLZXl3b3JkICovO1xuICBLZXl3b3JkTG9va3VwLnR5cGVvZiA9IDM0ODUwIC8qIFR5cGVvZktleXdvcmQgKi87XG4gIEtleXdvcmRMb29rdXAudm9pZCA9IDM0ODUxIC8qIFZvaWRLZXl3b3JkICovO1xuICBLZXl3b3JkTG9va3VwLm9mID0gMTA1MTE3OSAvKiBPZktleXdvcmQgKi87XG4gIC8qKlxuICAgKiBSYW5nZXMgb2YgY29kZSBwb2ludHMgaW4gcGFpcnMgb2YgMiAoZWcgMHg0MS0weDVCLCAweDYxLTB4N0IsIC4uLikgd2hlcmUgdGhlIHNlY29uZCB2YWx1ZSBpcyBub3QgaW5jbHVzaXZlICg1LTcgbWVhbnMgNSBhbmQgNilcbiAgICogU2luZ2xlIHZhbHVlcyBhcmUgZGVub3RlZCBieSB0aGUgc2Vjb25kIHZhbHVlIGJlaW5nIGEgMFxuICAgKlxuICAgKiBDb3BpZWQgZnJvbSBvdXRwdXQgZ2VuZXJhdGVkIHdpdGggXCJub2RlIGJ1aWxkL2dlbmVyYXRlLXVuaWNvZGUuanNcIlxuICAgKlxuICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvVW5pY29kZS9DaGFyYWN0ZXJfcmVmZXJlbmNlLzAwMDAtMEZGRlxuICAgKi9cbiAgY29uc3QgY29kZXMgPSB7XG4gICAgICAvKiBbJDAtOUEtWmFfYS16XSAqL1xuICAgICAgQXNjaWlJZFBhcnQ6IFsweDI0LCAwLCAweDMwLCAweDNBLCAweDQxLCAweDVCLCAweDVGLCAwLCAweDYxLCAweDdCXSxcbiAgICAgIElkU3RhcnQ6IC8qSWRlbnRpZmllclN0YXJ0Ki8gWzB4MjQsIDAsIDB4NDEsIDB4NUIsIDB4NUYsIDAsIDB4NjEsIDB4N0IsIDB4QUEsIDAsIDB4QkEsIDAsIDB4QzAsIDB4RDcsIDB4RDgsIDB4RjcsIDB4RjgsIDB4MkI5LCAweDJFMCwgMHgyRTUsIDB4MUQwMCwgMHgxRDI2LCAweDFEMkMsIDB4MUQ1RCwgMHgxRDYyLCAweDFENjYsIDB4MUQ2QiwgMHgxRDc4LCAweDFENzksIDB4MURCRiwgMHgxRTAwLCAweDFGMDAsIDB4MjA3MSwgMCwgMHgyMDdGLCAwLCAweDIwOTAsIDB4MjA5RCwgMHgyMTJBLCAweDIxMkMsIDB4MjEzMiwgMCwgMHgyMTRFLCAwLCAweDIxNjAsIDB4MjE4OSwgMHgyQzYwLCAweDJDODAsIDB4QTcyMiwgMHhBNzg4LCAweEE3OEIsIDB4QTdBRiwgMHhBN0IwLCAweEE3QjgsIDB4QTdGNywgMHhBODAwLCAweEFCMzAsIDB4QUI1QiwgMHhBQjVDLCAweEFCNjUsIDB4RkIwMCwgMHhGQjA3LCAweEZGMjEsIDB4RkYzQiwgMHhGRjQxLCAweEZGNUJdLFxuICAgICAgRGlnaXQ6IC8qRGVjaW1hbE51bWJlciovIFsweDMwLCAweDNBXSxcbiAgICAgIFNraXA6IC8qU2tpcHBhYmxlKi8gWzAsIDB4MjEsIDB4N0YsIDB4QTFdXG4gIH07XG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIHRoZSByYW5nZXMgaW50byBhbiBhcnJheSBvZiBudW1iZXJzIHNvIHRoYXQgdGhlIGNoYXIgY29kZVxuICAgKiBjYW4gYmUgdXNlZCBhcyBhbiBpbmRleCB0byB0aGUgbG9va3VwXG4gICAqL1xuICBmdW5jdGlvbiBkZWNvbXByZXNzKGxvb2t1cCwgJHNldCwgY29tcHJlc3NlZCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHJhbmdlQ291bnQgPSBjb21wcmVzc2VkLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VDb3VudDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBjb21wcmVzc2VkW2ldO1xuICAgICAgICAgIGxldCBlbmQgPSBjb21wcmVzc2VkW2kgKyAxXTtcbiAgICAgICAgICBlbmQgPSBlbmQgPiAwID8gZW5kIDogc3RhcnQgKyAxO1xuICAgICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgICAgbG9va3VwLmZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJHNldCkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBjaCA9IHN0YXJ0OyBjaCA8IGVuZDsgY2grKykge1xuICAgICAgICAgICAgICAgICAgJHNldC5hZGQoY2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIC8vIENoYXJGdW5jTG9va3VwIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiByZXR1cm5Ub2tlbih0b2tlbikge1xuICAgICAgcmV0dXJuIHMgPT4ge1xuICAgICAgICAgIG5leHRDaGFyKHMpO1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH07XG4gIH1cbiAgY29uc3QgdW5leHBlY3RlZENoYXJhY3RlciA9IHMgPT4ge1xuICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDExMSAvKiBVbmV4cGVjdGVkQ2hhcmFjdGVyICovLCB7IHN0YXRlOiBzIH0pO1xuICB9O1xuICB1bmV4cGVjdGVkQ2hhcmFjdGVyLm5vdE1hcHBlZCA9IHRydWU7XG4gIC8vIEFTQ0lJIElkZW50aWZpZXJQYXJ0IGxvb2t1cFxuICBjb25zdCBBc2NpaUlkUGFydHMgPSBuZXcgU2V0KCk7XG4gIGRlY29tcHJlc3MobnVsbCwgQXNjaWlJZFBhcnRzLCBjb2Rlcy5Bc2NpaUlkUGFydCwgdHJ1ZSk7XG4gIC8vIElkZW50aWZpZXJQYXJ0IGxvb2t1cFxuICBjb25zdCBJZFBhcnRzID0gbmV3IFVpbnQ4QXJyYXkoMHhGRkZGKTtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICBkZWNvbXByZXNzKElkUGFydHMsIG51bGwsIGNvZGVzLklkU3RhcnQsIDEpO1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gIGRlY29tcHJlc3MoSWRQYXJ0cywgbnVsbCwgY29kZXMuRGlnaXQsIDEpO1xuICAvLyBDaGFyYWN0ZXIgc2Nhbm5pbmcgZnVuY3Rpb24gbG9va3VwXG4gIGNvbnN0IENoYXJTY2FubmVycyA9IG5ldyBBcnJheSgweEZGRkYpO1xuICBDaGFyU2Nhbm5lcnMuZmlsbCh1bmV4cGVjdGVkQ2hhcmFjdGVyLCAwLCAweEZGRkYpO1xuICBkZWNvbXByZXNzKENoYXJTY2FubmVycywgbnVsbCwgY29kZXMuU2tpcCwgcyA9PiB7XG4gICAgICBuZXh0Q2hhcihzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgZGVjb21wcmVzcyhDaGFyU2Nhbm5lcnMsIG51bGwsIGNvZGVzLklkU3RhcnQsIHNjYW5JZGVudGlmaWVyKTtcbiAgZGVjb21wcmVzcyhDaGFyU2Nhbm5lcnMsIG51bGwsIGNvZGVzLkRpZ2l0LCBzID0+IHNjYW5OdW1iZXIocywgZmFsc2UpKTtcbiAgQ2hhclNjYW5uZXJzWzM0IC8qIERvdWJsZVF1b3RlICovXSA9XG4gICAgICBDaGFyU2Nhbm5lcnNbMzkgLyogU2luZ2xlUXVvdGUgKi9dID0gcyA9PiB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmcocyk7XG4gICAgICB9O1xuICBDaGFyU2Nhbm5lcnNbOTYgLyogQmFja3RpY2sgKi9dID0gcyA9PiB7XG4gICAgICByZXR1cm4gc2NhblRlbXBsYXRlKHMpO1xuICB9O1xuICAvLyAhLCAhPSwgIT09XG4gIENoYXJTY2FubmVyc1szMyAvKiBFeGNsYW1hdGlvbiAqL10gPSBzID0+IHtcbiAgICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gNjEgLyogRXF1YWxzICovKSB7XG4gICAgICAgICAgcmV0dXJuIDMyODA4IC8qIEV4Y2xhbWF0aW9uICovO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRDaGFyKHMpICE9PSA2MSAvKiBFcXVhbHMgKi8pIHtcbiAgICAgICAgICByZXR1cm4gMTYzODY3OSAvKiBFeGNsYW1hdGlvbkVxdWFscyAqLztcbiAgICAgIH1cbiAgICAgIG5leHRDaGFyKHMpO1xuICAgICAgcmV0dXJuIDE2Mzg2ODEgLyogRXhjbGFtYXRpb25FcXVhbHNFcXVhbHMgKi87XG4gIH07XG4gIC8vID0sID09LCA9PT1cbiAgQ2hhclNjYW5uZXJzWzYxIC8qIEVxdWFscyAqL10gPSBzID0+IHtcbiAgICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gNjEgLyogRXF1YWxzICovKSB7XG4gICAgICAgICAgcmV0dXJuIDEwNDg2MTUgLyogRXF1YWxzICovO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRDaGFyKHMpICE9PSA2MSAvKiBFcXVhbHMgKi8pIHtcbiAgICAgICAgICByZXR1cm4gMTYzODY3OCAvKiBFcXVhbHNFcXVhbHMgKi87XG4gICAgICB9XG4gICAgICBuZXh0Q2hhcihzKTtcbiAgICAgIHJldHVybiAxNjM4NjgwIC8qIEVxdWFsc0VxdWFsc0VxdWFscyAqLztcbiAgfTtcbiAgLy8gJiwgJiZcbiAgQ2hhclNjYW5uZXJzWzM4IC8qIEFtcGVyc2FuZCAqL10gPSBzID0+IHtcbiAgICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gMzggLyogQW1wZXJzYW5kICovKSB7XG4gICAgICAgICAgcmV0dXJuIDE1NzI4ODAgLyogQW1wZXJzYW5kICovO1xuICAgICAgfVxuICAgICAgbmV4dENoYXIocyk7XG4gICAgICByZXR1cm4gMTYzODYxMyAvKiBBbXBlcnNhbmRBbXBlcnNhbmQgKi87XG4gIH07XG4gIC8vIHwsIHx8XG4gIENoYXJTY2FubmVyc1sxMjQgLyogQmFyICovXSA9IHMgPT4ge1xuICAgICAgaWYgKG5leHRDaGFyKHMpICE9PSAxMjQgLyogQmFyICovKSB7XG4gICAgICAgICAgcmV0dXJuIDE1NzI4ODMgLyogQmFyICovO1xuICAgICAgfVxuICAgICAgbmV4dENoYXIocyk7XG4gICAgICByZXR1cm4gMTYzODU0OCAvKiBCYXJCYXIgKi87XG4gIH07XG4gIC8vIC5cbiAgQ2hhclNjYW5uZXJzWzQ2IC8qIERvdCAqL10gPSBzID0+IHtcbiAgICAgIGlmIChuZXh0Q2hhcihzKSA8PSA1NyAvKiBOaW5lICovICYmIHMuY3VycmVudENoYXIgPj0gNDggLyogWmVybyAqLykge1xuICAgICAgICAgIHJldHVybiBzY2FuTnVtYmVyKHMsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDE2MzkyIC8qIERvdCAqLztcbiAgfTtcbiAgLy8gPCwgPD1cbiAgQ2hhclNjYW5uZXJzWzYwIC8qIExlc3NUaGFuICovXSA9IHMgPT4ge1xuICAgICAgaWYgKG5leHRDaGFyKHMpICE9PSA2MSAvKiBFcXVhbHMgKi8pIHtcbiAgICAgICAgICByZXR1cm4gMTYzODc0NiAvKiBMZXNzVGhhbiAqLztcbiAgICAgIH1cbiAgICAgIG5leHRDaGFyKHMpO1xuICAgICAgcmV0dXJuIDE2Mzg3NDggLyogTGVzc1RoYW5FcXVhbHMgKi87XG4gIH07XG4gIC8vID4sID49XG4gIENoYXJTY2FubmVyc1s2MiAvKiBHcmVhdGVyVGhhbiAqL10gPSBzID0+IHtcbiAgICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gNjEgLyogRXF1YWxzICovKSB7XG4gICAgICAgICAgcmV0dXJuIDE2Mzg3NDcgLyogR3JlYXRlclRoYW4gKi87XG4gICAgICB9XG4gICAgICBuZXh0Q2hhcihzKTtcbiAgICAgIHJldHVybiAxNjM4NzQ5IC8qIEdyZWF0ZXJUaGFuRXF1YWxzICovO1xuICB9O1xuICBDaGFyU2Nhbm5lcnNbMzcgLyogUGVyY2VudCAqL10gPSByZXR1cm5Ub2tlbigxNjM4ODg1IC8qIFBlcmNlbnQgKi8pO1xuICBDaGFyU2Nhbm5lcnNbNDAgLyogT3BlblBhcmVuICovXSA9IHJldHVyblRva2VuKDY3MTc1MCAvKiBPcGVuUGFyZW4gKi8pO1xuICBDaGFyU2Nhbm5lcnNbNDEgLyogQ2xvc2VQYXJlbiAqL10gPSByZXR1cm5Ub2tlbigxODM1MDE4IC8qIENsb3NlUGFyZW4gKi8pO1xuICBDaGFyU2Nhbm5lcnNbNDIgLyogQXN0ZXJpc2sgKi9dID0gcmV0dXJuVG9rZW4oMTYzODg4NCAvKiBBc3RlcmlzayAqLyk7XG4gIENoYXJTY2FubmVyc1s0MyAvKiBQbHVzICovXSA9IHJldHVyblRva2VuKDYyMzAwOCAvKiBQbHVzICovKTtcbiAgQ2hhclNjYW5uZXJzWzQ0IC8qIENvbW1hICovXSA9IHJldHVyblRva2VuKDE1NzI4NzUgLyogQ29tbWEgKi8pO1xuICBDaGFyU2Nhbm5lcnNbNDUgLyogTWludXMgKi9dID0gcmV0dXJuVG9rZW4oNjIzMDA5IC8qIE1pbnVzICovKTtcbiAgQ2hhclNjYW5uZXJzWzQ3IC8qIFNsYXNoICovXSA9IHJldHVyblRva2VuKDE2Mzg4ODYgLyogU2xhc2ggKi8pO1xuICBDaGFyU2Nhbm5lcnNbNTggLyogQ29sb24gKi9dID0gcmV0dXJuVG9rZW4oMTU3Mjg3OCAvKiBDb2xvbiAqLyk7XG4gIENoYXJTY2FubmVyc1s2MyAvKiBRdWVzdGlvbiAqL10gPSByZXR1cm5Ub2tlbigxNTcyODc5IC8qIFF1ZXN0aW9uICovKTtcbiAgQ2hhclNjYW5uZXJzWzkxIC8qIE9wZW5CcmFja2V0ICovXSA9IHJldHVyblRva2VuKDY3MTc1NiAvKiBPcGVuQnJhY2tldCAqLyk7XG4gIENoYXJTY2FubmVyc1s5MyAvKiBDbG9zZUJyYWNrZXQgKi9dID0gcmV0dXJuVG9rZW4oMTgzNTAyMSAvKiBDbG9zZUJyYWNrZXQgKi8pO1xuICBDaGFyU2Nhbm5lcnNbMTIzIC8qIE9wZW5CcmFjZSAqL10gPSByZXR1cm5Ub2tlbigxMzEwNzkgLyogT3BlbkJyYWNlICovKTtcbiAgQ2hhclNjYW5uZXJzWzEyNSAvKiBDbG9zZUJyYWNlICovXSA9IHJldHVyblRva2VuKDE4MzUwMTcgLyogQ2xvc2VCcmFjZSAqLyk7XG5cbiAgY29uc3QgZG9tUGFyc2VyID0gcnVudGltZS5ET00uY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IG1hcmtlciA9IHJ1bnRpbWUuRE9NLmNyZWF0ZUVsZW1lbnQoJ2F1LW1hcmtlcicpO1xuICBtYXJrZXIuY2xhc3NMaXN0LmFkZCgnYXUnKTtcbiAgY29uc3QgY3JlYXRlTWFya2VyID0gbWFya2VyLmNsb25lTm9kZS5iaW5kKG1hcmtlciwgZmFsc2UpO1xuICBjbGFzcyBFbGVtZW50U3ludGF4IHtcbiAgICAgIGNvbnN0cnVjdG9yKG5vZGUsIG5hbWUsICRjb250ZW50LCAkY2hpbGRyZW4sICRhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuJGNvbnRlbnQgPSAkY29udGVudDtcbiAgICAgICAgICB0aGlzLiRjaGlsZHJlbiA9ICRjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLiRhdHRyaWJ1dGVzID0gJGF0dHJpYnV0ZXM7XG4gICAgICB9XG4gICAgICBzdGF0aWMgY3JlYXRlTWFya2VyKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudFN5bnRheChjcmVhdGVNYXJrZXIoKSwgJ2F1LW1hcmtlcicsIG51bGwsIGtlcm5lbC5QTEFURk9STS5lbXB0eUFycmF5LCBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheSk7XG4gICAgICB9XG4gIH1cbiAgY29uc3QgSUVsZW1lbnRQYXJzZXIgPSBrZXJuZWwuREkuY3JlYXRlSW50ZXJmYWNlKClcbiAgICAgIC53aXRoRGVmYXVsdCh4ID0+IHguc2luZ2xldG9uKGV4cG9ydHMuRWxlbWVudFBhcnNlcikpO1xuICAvKkBpbnRlcm5hbCovXG4gIGV4cG9ydHMuRWxlbWVudFBhcnNlciA9IGNsYXNzIEVsZW1lbnRQYXJzZXIge1xuICAgICAgY29uc3RydWN0b3IoYXR0clBhcnNlcikge1xuICAgICAgICAgIHRoaXMuYXR0clBhcnNlciA9IGF0dHJQYXJzZXI7XG4gICAgICB9XG4gICAgICBwYXJzZShtYXJrdXBPck5vZGUpIHtcbiAgICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcmt1cE9yTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgZG9tUGFyc2VyLmlubmVySFRNTCA9IG1hcmt1cE9yTm9kZTtcbiAgICAgICAgICAgICAgbm9kZSA9IGRvbVBhcnNlci5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgICAgZG9tUGFyc2VyLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZSA9IG1hcmt1cE9yTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnBhcnNlKG5vZGUuY29udGVudCk7XG4gICAgICAgICAgICAgIGNoaWxkcmVuID0ga2VybmVsLlBMQVRGT1JNLmVtcHR5QXJyYXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZUNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGVMZW4gPSBub2RlQ2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmIChub2RlTGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBBcnJheShub2RlTGVuKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG5vZGVMZW47IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSB0aGlzLnBhcnNlKG5vZGVDaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0ga2VybmVsLlBMQVRGT1JNLmVtcHR5QXJyYXk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgY29uc3Qgbm9kZUF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgY29uc3QgYXR0ckxlbiA9IG5vZGVBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgPyAwIDogbm9kZUF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChhdHRyTGVuID4gMCkge1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gQXJyYXkoYXR0ckxlbik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGF0dHJMZW47IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gbm9kZUF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2ldID0gdGhpcy5hdHRyUGFyc2VyLnBhcnNlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U3ludGF4KG5vZGUsIG5vZGUubm9kZU5hbWUsIGNvbnRlbnQsIGNoaWxkcmVuLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5FbGVtZW50UGFyc2VyID0gX19kZWNvcmF0ZShbXG4gICAgICBrZXJuZWwuaW5qZWN0KElBdHRyaWJ1dGVQYXJzZXIpXG4gIF0sIGV4cG9ydHMuRWxlbWVudFBhcnNlcik7XG5cbiAgY2xhc3MgU2VtYW50aWNNb2RlbCB7XG4gICAgICBjb25zdHJ1Y3RvcihkZWZpbml0aW9uLCByZXNvdXJjZXMsIGF0dHJQYXJzZXIsIGVsUGFyc2VyLCBleHByUGFyc2VyKSB7XG4gICAgICAgICAgdGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG4gICAgICAgICAgdGhpcy5hdHRyUGFyc2VyID0gYXR0clBhcnNlcjtcbiAgICAgICAgICB0aGlzLmVsUGFyc2VyID0gZWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5leHByUGFyc2VyID0gZXhwclBhcnNlcjtcbiAgICAgICAgICB0aGlzLmlzU2VtYW50aWNNb2RlbCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hdHRyRGVmQ2FjaGUgPSB7fTtcbiAgICAgICAgICB0aGlzLmVsRGVmQ2FjaGUgPSB7fTtcbiAgICAgICAgICB0aGlzLmNvbW1hbmRDYWNoZSA9IHt9O1xuICAgICAgICAgIGNvbnN0IHN5bnRheCA9IHRoaXMuZWxQYXJzZXIucGFyc2UoZGVmaW5pdGlvbi50ZW1wbGF0ZSk7XG4gICAgICAgICAgZGVmaW5pdGlvbi50ZW1wbGF0ZSA9IHN5bnRheC5ub2RlO1xuICAgICAgICAgIHRoaXMucm9vdCA9IG5ldyBFbGVtZW50U3ltYm9sKFxuICAgICAgICAgIC8qICAgc2VtYW50aWNNb2RlbCovIHRoaXMsIFxuICAgICAgICAgIC8qaXNEZWZpbml0aW9uUm9vdCovIHRydWUsIFxuICAgICAgICAgIC8qICRkZWZpbml0aW9uUm9vdCovIG51bGwsIFxuICAgICAgICAgIC8qICAgICAgICAgJHBhcmVudCovIG51bGwsIFxuICAgICAgICAgIC8qICAgICAgICAgIHN5bnRheCovIHN5bnRheCwgXG4gICAgICAgICAgLyogICAgICBkZWZpbml0aW9uKi8gZGVmaW5pdGlvbik7XG4gICAgICB9XG4gICAgICBzdGF0aWMgY3JlYXRlKGRlZmluaXRpb24sIHJlc291cmNlcywgYXR0clBhcnNlciwgZWxQYXJzZXIsIGV4cHJQYXJzZXIpIHtcbiAgICAgICAgICBpZiAoJ2dldCcgaW4gYXR0clBhcnNlcikge1xuICAgICAgICAgICAgICBjb25zdCBsb2NhdG9yID0gYXR0clBhcnNlcjtcbiAgICAgICAgICAgICAgYXR0clBhcnNlciA9IGxvY2F0b3IuZ2V0KElBdHRyaWJ1dGVQYXJzZXIpO1xuICAgICAgICAgICAgICBlbFBhcnNlciA9IGxvY2F0b3IuZ2V0KElFbGVtZW50UGFyc2VyKTtcbiAgICAgICAgICAgICAgZXhwclBhcnNlciA9IGxvY2F0b3IuZ2V0KHJ1bnRpbWUuSUV4cHJlc3Npb25QYXJzZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFNlbWFudGljTW9kZWwoZGVmaW5pdGlvbiwgcmVzb3VyY2VzLCBhdHRyUGFyc2VyLCBlbFBhcnNlciwgZXhwclBhcnNlcik7XG4gICAgICB9XG4gICAgICBnZXRBdHRyaWJ1dGVEZWZpbml0aW9uKG5hbWUpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuYXR0ckRlZkNhY2hlW25hbWVdO1xuICAgICAgICAgIGlmIChleGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMucmVzb3VyY2VzLmZpbmQocnVudGltZS5DdXN0b21BdHRyaWJ1dGVSZXNvdXJjZSwgbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0ckRlZkNhY2hlW25hbWVdID0gZGVmaW5pdGlvbiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlZmluaXRpb247XG4gICAgICB9XG4gICAgICBnZXRFbGVtZW50RGVmaW5pdGlvbihuYW1lKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmVsRGVmQ2FjaGVbbmFtZV07XG4gICAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5yZXNvdXJjZXMuZmluZChydW50aW1lLkN1c3RvbUVsZW1lbnRSZXNvdXJjZSwgbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWxEZWZDYWNoZVtuYW1lXSA9IGRlZmluaXRpb24gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWZpbml0aW9uO1xuICAgICAgfVxuICAgICAgZ2V0QmluZGluZ0NvbW1hbmQobmFtZSkge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5jb21tYW5kQ2FjaGVbbmFtZV07XG4gICAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMucmVzb3VyY2VzLmNyZWF0ZShCaW5kaW5nQ29tbWFuZFJlc291cmNlLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kQ2FjaGVbbmFtZV0gPSBpbnN0YW5jZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGluc3RhbmNlO1xuICAgICAgfVxuICAgICAgZ2V0QXR0cmlidXRlU3ltYm9sKHN5bnRheCwgZWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZURlZmluaXRpb24oa2VybmVsLlBMQVRGT1JNLmNhbWVsQ2FzZShzeW50YXgudGFyZ2V0KSk7XG4gICAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuZ2V0QmluZGluZ0NvbW1hbmQoc3ludGF4LmNvbW1hbmQpO1xuICAgICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlU3ltYm9sKHRoaXMsIGVsZW1lbnQsIHN5bnRheCwgZGVmaW5pdGlvbiwgY29tbWFuZCk7XG4gICAgICB9XG4gICAgICBnZXRNdWx0aUF0dHJCaW5kaW5nU3ltYm9sKHN5bnRheCwgcGFyZW50KSB7XG4gICAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuZ2V0QmluZGluZ0NvbW1hbmQoc3ludGF4LmNvbW1hbmQpO1xuICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlBdHRyaWJ1dGVCaW5kaW5nU3ltYm9sKHRoaXMsIHBhcmVudCwgc3ludGF4LCBjb21tYW5kKTtcbiAgICAgIH1cbiAgICAgIGdldEVsZW1lbnRTeW1ib2woc3ludGF4LCBwYXJlbnQpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gc3ludGF4Lm5vZGU7XG4gICAgICAgICAgbGV0IGRlZmluaXRpb247XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudCAqLykge1xuICAgICAgICAgICAgICBjb25zdCByZXNvdXJjZUtleSA9IChub2RlLmdldEF0dHJpYnV0ZSgnYXMtZWxlbWVudCcpIHx8IG5vZGUubm9kZU5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLmdldEVsZW1lbnREZWZpbml0aW9uKHJlc291cmNlS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U3ltYm9sKFxuICAgICAgICAgIC8qICAgc2VtYW50aWNNb2RlbCovIHRoaXMsIFxuICAgICAgICAgIC8qaXNEZWZpbml0aW9uUm9vdCovIGZhbHNlLCBcbiAgICAgICAgICAvKiAkZGVmaW5pdGlvblJvb3QqLyBwYXJlbnQuJHJvb3QsIFxuICAgICAgICAgIC8qICAgICAgICAgJHBhcmVudCovIHBhcmVudCwgXG4gICAgICAgICAgLyogICAgICAgICAgc3ludGF4Ki8gc3ludGF4LCBcbiAgICAgICAgICAvKiAgICAgIGRlZmluaXRpb24qLyBkZWZpbml0aW9uKTtcbiAgICAgIH1cbiAgICAgIGdldFRlbXBsYXRlRWxlbWVudFN5bWJvbChzeW50YXgsIHBhcmVudCwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvblJvb3QpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRTeW1ib2woXG4gICAgICAgICAgLyogICBzZW1hbnRpY01vZGVsKi8gdGhpcywgXG4gICAgICAgICAgLyppc0RlZmluaXRpb25Sb290Ki8gdHJ1ZSwgXG4gICAgICAgICAgLyogJGRlZmluaXRpb25Sb290Ki8gZGVmaW5pdGlvblJvb3QsIFxuICAgICAgICAgIC8qICAgICAgICAgJHBhcmVudCovIHBhcmVudCwgXG4gICAgICAgICAgLyogICAgICAgICAgc3ludGF4Ki8gc3ludGF4LCBcbiAgICAgICAgICAvKiAgICAgIGRlZmluaXRpb24qLyBkZWZpbml0aW9uKTtcbiAgICAgIH1cbiAgfVxuICBjbGFzcyBNdWx0aUF0dHJpYnV0ZUJpbmRpbmdTeW1ib2wge1xuICAgICAgY29uc3RydWN0b3Ioc2VtYW50aWNNb2RlbCwgJHBhcmVudCwgc3ludGF4LCBjb21tYW5kKSB7XG4gICAgICAgICAgdGhpcy5zZW1hbnRpY01vZGVsID0gc2VtYW50aWNNb2RlbDtcbiAgICAgICAgICB0aGlzLiRwYXJlbnQgPSAkcGFyZW50O1xuICAgICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4O1xuICAgICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgICAgdGhpcy5pc011bHRpQXR0ckJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmJpbmRhYmxlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmlzVGVtcGxhdGVDb250cm9sbGVyID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5pc0N1c3RvbUF0dHJpYnV0ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5pc0F0dHJpYnV0ZUJpbmRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5pc0RlZmF1bHRBdHRyaWJ1dGVCaW5kYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMub25DdXN0b21FbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5pc0VsZW1lbnRCaW5kYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gc3ludGF4LnRhcmdldDtcbiAgICAgICAgICB0aGlzLnJhd05hbWUgPSBzeW50YXgucmF3TmFtZTtcbiAgICAgICAgICB0aGlzLnJhd1ZhbHVlID0gc3ludGF4LnJhd1ZhbHVlO1xuICAgICAgICAgIHRoaXMucmF3Q29tbWFuZCA9IHN5bnRheC5jb21tYW5kO1xuICAgICAgICAgIHRoaXMuaGFzQmluZGluZ0NvbW1hbmQgPSAhIWNvbW1hbmQ7XG4gICAgICAgICAgdGhpcy5pc0hhbmRsZWRCeUJpbmRpbmdDb21tYW5kID0gdGhpcy5oYXNCaW5kaW5nQ29tbWFuZCAmJiBjb21tYW5kLmhhbmRsZXModGhpcyk7XG4gICAgICAgICAgY29uc3QgYmluZGFibGVzID0gJHBhcmVudC5kZWZpbml0aW9uLmJpbmRhYmxlcztcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gYmluZGFibGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGIgPSBiaW5kYWJsZXNbcHJvcF07XG4gICAgICAgICAgICAgIGlmIChiLnByb3BlcnR5ID09PSBzeW50YXgudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRvID0gYi5wcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgIHRoaXMubW9kZSA9IChiLm1vZGUgIT09IHVuZGVmaW5lZCAmJiBiLm1vZGUgIT09IHJ1bnRpbWUuQmluZGluZ01vZGUuZGVmYXVsdCkgPyBiLm1vZGUgOiBydW50aW1lLkJpbmRpbmdNb2RlLnRvVmlldztcbiAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGFibGUgPSBiO1xuICAgICAgICAgICAgICAgICAgdGhpcy5pc0F0dHJpYnV0ZUJpbmRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5pc0F0dHJpYnV0ZUJpbmRhYmxlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRCaW5kaW5nTW9kZSA9ICRwYXJlbnQuZGVmaW5pdGlvbi5kZWZhdWx0QmluZGluZ01vZGU7XG4gICAgICAgICAgICAgIHRoaXMudG8gPSBzeW50YXgudGFyZ2V0O1xuICAgICAgICAgICAgICB0aGlzLm1vZGUgPSBkZWZhdWx0QmluZGluZ01vZGUgPT09IHVuZGVmaW5lZCA/IHJ1bnRpbWUuQmluZGluZ01vZGUudG9WaWV3IDogZGVmYXVsdEJpbmRpbmdNb2RlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICBjbGFzcyBBdHRyaWJ1dGVTeW1ib2wge1xuICAgICAgY29uc3RydWN0b3Ioc2VtYW50aWNNb2RlbCwgJGVsZW1lbnQsIHN5bnRheCwgZGVmaW5pdGlvbiwgY29tbWFuZCkge1xuICAgICAgICAgIHRoaXMuc2VtYW50aWNNb2RlbCA9IHNlbWFudGljTW9kZWw7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xuICAgICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4O1xuICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcbiAgICAgICAgICB0aGlzLmlzTXVsdGlBdHRyQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmJpbmRhYmxlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmlzQXR0cmlidXRlQmluZGFibGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzRGVmYXVsdEF0dHJpYnV0ZUJpbmRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5pc0VsZW1lbnRCaW5kYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaXNCaW5kYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaXNUZW1wbGF0ZUNvbnRyb2xsZXIgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRhcmdldCA9IHN5bnRheC50YXJnZXQ7XG4gICAgICAgICAgdGhpcy5yYXdOYW1lID0gc3ludGF4LnJhd05hbWU7XG4gICAgICAgICAgdGhpcy5yYXdWYWx1ZSA9IHN5bnRheC5yYXdWYWx1ZTtcbiAgICAgICAgICB0aGlzLnJhd0NvbW1hbmQgPSBzeW50YXguY29tbWFuZDtcbiAgICAgICAgICB0aGlzLmlzQ3VzdG9tQXR0cmlidXRlID0gISFkZWZpbml0aW9uO1xuICAgICAgICAgIHRoaXMuaGFzQmluZGluZ0NvbW1hbmQgPSAhIWNvbW1hbmQ7XG4gICAgICAgICAgdGhpcy5pc0hhbmRsZWRCeUJpbmRpbmdDb21tYW5kID0gdGhpcy5oYXNCaW5kaW5nQ29tbWFuZCAmJiBjb21tYW5kLmhhbmRsZXModGhpcyk7XG4gICAgICAgICAgdGhpcy5vbkN1c3RvbUVsZW1lbnQgPSAkZWxlbWVudC5pc0N1c3RvbUVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5faXNQcm9jZXNzZWQgPSB0aGlzLnJhd05hbWUgPT09ICdhcy1lbGVtZW50JzsgLy8gYXMtZWxlbWVudCBpcyBwcm9jZXNzZWQgYnkgdGhlIHNlbWFudGljIG1vZGVsIGFuZCBzaG91bGRuJ3QgYmUgcHJvY2Vzc2VkIGJ5IHRoZSB0ZW1wbGF0ZSBjb21waWxlclxuICAgICAgICAgIGlmICh0aGlzLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuaXNUZW1wbGF0ZUNvbnRyb2xsZXIgPSAhIWRlZmluaXRpb24uaXNUZW1wbGF0ZUNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgIHRoaXMucmVzID0gZGVmaW5pdGlvbi5uYW1lO1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN5bnRheC5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgIGxldCBtdWx0aUF0dHJCaW5kaW5ncztcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmFsdWUubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJDb2RlQXQoaSkgPT09IDU5IC8qIFNlbWljb2xvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc011bHRpQXR0ckJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlBdHRyQmluZGluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc011bHRpQXR0ckJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lckF0dHIgPSB2YWx1ZS5zbGljZShsYXN0SW5kZXgsIGkpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJBdHRyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gaW5uZXJBdHRyLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyQXR0ci5jaGFyQ29kZUF0KGopID09PSA1OCAvKiBDb2xvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5uZXJBdHRyTmFtZSA9IGlubmVyQXR0ci5zbGljZSgwLCBqKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lckF0dHJWYWx1ZSA9IGlubmVyQXR0ci5zbGljZShqICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5uZXJBdHRyU3ludGF4ID0gdGhpcy5zZW1hbnRpY01vZGVsLmF0dHJQYXJzZXIucGFyc2UoaW5uZXJBdHRyTmFtZSwgaW5uZXJBdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlBdHRyQmluZGluZ3MucHVzaCh0aGlzLnNlbWFudGljTW9kZWwuZ2V0TXVsdGlBdHRyQmluZGluZ1N5bWJvbChpbm5lckF0dHJTeW50YXgsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLiRtdWx0aUF0dHJCaW5kaW5ncyA9IHRoaXMuaXNNdWx0aUF0dHJCaW5kaW5nID8gbXVsdGlBdHRyQmluZGluZ3MgOiBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheTtcbiAgICAgICAgICAgICAgY29uc3QgYmluZGFibGVzID0gZGVmaW5pdGlvbi5iaW5kYWJsZXM7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5pc011bHRpQXR0ckJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBiaW5kYWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gYmluZGFibGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSBiLnByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZSA9IChiLm1vZGUgIT09IHVuZGVmaW5lZCAmJiBiLm1vZGUgIT09IHJ1bnRpbWUuQmluZGluZ01vZGUuZGVmYXVsdCkgPyBiLm1vZGUgOiAoZGVmaW5pdGlvbi5kZWZhdWx0QmluZGluZ01vZGUgfHwgcnVudGltZS5CaW5kaW5nTW9kZS50b1ZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGFibGUgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNCaW5kYWJsZSA9IHRoaXMuaXNBdHRyaWJ1dGVCaW5kYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNBdHRyaWJ1dGVCaW5kYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRCaW5kaW5nTW9kZSA9IGRlZmluaXRpb24uZGVmYXVsdEJpbmRpbmdNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSAndmFsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZSA9IGRlZmF1bHRCaW5kaW5nTW9kZSA9PT0gdW5kZWZpbmVkID8gcnVudGltZS5CaW5kaW5nTW9kZS50b1ZpZXcgOiBkZWZhdWx0QmluZGluZ01vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0JpbmRhYmxlID0gdGhpcy5pc0F0dHJpYnV0ZUJpbmRhYmxlID0gdGhpcy5pc0RlZmF1bHRBdHRyaWJ1dGVCaW5kYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoJGVsZW1lbnQuaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJpbmRhYmxlcyA9ICRlbGVtZW50LmRlZmluaXRpb24uYmluZGFibGVzO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gYmluZGFibGVzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBiID0gYmluZGFibGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgaWYgKGIuYXR0cmlidXRlID09PSBzeW50YXgudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IGIucHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlID0gKGIubW9kZSAhPT0gdW5kZWZpbmVkICYmIGIubW9kZSAhPT0gcnVudGltZS5CaW5kaW5nTW9kZS5kZWZhdWx0KSA/IGIubW9kZSA6IHJ1bnRpbWUuQmluZGluZ01vZGUudG9WaWV3O1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGFibGUgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNCaW5kYWJsZSA9IHRoaXMuaXNFbGVtZW50QmluZGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGhpcy5pc0VsZW1lbnRCaW5kYWJsZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHN5bnRheC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1vZGUgPSBydW50aW1lLkJpbmRpbmdNb2RlLnRvVmlldztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy50byA9IHN5bnRheC50YXJnZXQ7XG4gICAgICAgICAgICAgIHRoaXMubW9kZSA9IHJ1bnRpbWUuQmluZGluZ01vZGUudG9WaWV3O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdldCBpc1Byb2Nlc3NlZCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faXNQcm9jZXNzZWQ7XG4gICAgICB9XG4gICAgICBtYXJrQXNQcm9jZXNzZWQoKSB7XG4gICAgICAgICAgdGhpcy5faXNQcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLmlzVGVtcGxhdGVDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQubm9kZS5yZW1vdmVBdHRyaWJ1dGUodGhpcy5yYXdOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgY2xhc3MgRWxlbWVudFN5bWJvbCB7XG4gICAgICBjb25zdHJ1Y3RvcihzZW1hbnRpY01vZGVsLCBpc1Jvb3QsICRyb290LCAkcGFyZW50LCBzeW50YXgsIGRlZmluaXRpb24pIHtcbiAgICAgICAgICB0aGlzLnNlbWFudGljTW9kZWwgPSBzZW1hbnRpY01vZGVsO1xuICAgICAgICAgIHRoaXMuaXNSb290ID0gaXNSb290O1xuICAgICAgICAgIHRoaXMuJHJvb3QgPSAkcm9vdDtcbiAgICAgICAgICB0aGlzLiRwYXJlbnQgPSAkcGFyZW50O1xuICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgICAgdGhpcy5fJGNvbnRlbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2lzTWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5faXNUZW1wbGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2lzU2xvdCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2lzTGV0ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5faXNMaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLiRyb290ID0gaXNSb290ID8gdGhpcyA6ICRyb290O1xuICAgICAgICAgIHRoaXMuX25vZGUgPSBzeW50YXgubm9kZTtcbiAgICAgICAgICB0aGlzLl9zeW50YXggPSBzeW50YXg7XG4gICAgICAgICAgdGhpcy5fbmFtZSA9IHRoaXMubm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICBjYXNlICdURU1QTEFURSc6XG4gICAgICAgICAgICAgICAgICB0aGlzLl9pc1RlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuXyRjb250ZW50ID0gdGhpcy5zZW1hbnRpY01vZGVsLmdldEVsZW1lbnRTeW1ib2woc3ludGF4LiRjb250ZW50LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdTTE9UJzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2lzU2xvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnTEVUJzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2lzTGV0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faXNDdXN0b21FbGVtZW50ID0gIWlzUm9vdCAmJiAhIWRlZmluaXRpb247XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHN5bnRheC4kYXR0cmlidXRlcztcbiAgICAgICAgICBjb25zdCBhdHRyTGVuID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGF0dHJMZW4gPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJTeW1ib2xzID0gQXJyYXkoYXR0ckxlbik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGF0dHJMZW47IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICBhdHRyU3ltYm9sc1tpXSA9IHRoaXMuc2VtYW50aWNNb2RlbC5nZXRBdHRyaWJ1dGVTeW1ib2woYXR0cmlidXRlc1tpXSwgdGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy4kYXR0cmlidXRlcyA9IGF0dHJTeW1ib2xzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy4kYXR0cmlidXRlcyA9IGtlcm5lbC5QTEFURk9STS5lbXB0eUFycmF5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHN5bnRheC4kY2hpbGRyZW47XG4gICAgICAgICAgY29uc3QgY2hpbGRMZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNoaWxkTGVuID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBjaGlsZFN5bWJvbHMgPSBBcnJheShjaGlsZExlbik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoaWxkTGVuOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgY2hpbGRTeW1ib2xzW2ldID0gdGhpcy5zZW1hbnRpY01vZGVsLmdldEVsZW1lbnRTeW1ib2woY2hpbGRyZW5baV0sIHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuJGNoaWxkcmVuID0gY2hpbGRTeW1ib2xzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy4kY2hpbGRyZW4gPSBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXQgJGNvbnRlbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuXyRjb250ZW50O1xuICAgICAgfVxuICAgICAgZ2V0IGlzTWFya2VyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pc01hcmtlcjtcbiAgICAgIH1cbiAgICAgIGdldCBpc1RlbXBsYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pc1RlbXBsYXRlO1xuICAgICAgfVxuICAgICAgZ2V0IGlzU2xvdCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faXNTbG90O1xuICAgICAgfVxuICAgICAgZ2V0IGlzTGV0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xldDtcbiAgICAgIH1cbiAgICAgIGdldCBub2RlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgfVxuICAgICAgZ2V0IHN5bnRheCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3ludGF4O1xuICAgICAgfVxuICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICB9XG4gICAgICBnZXQgaXNDdXN0b21FbGVtZW50KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pc0N1c3RvbUVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiRwYXJlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy4kcGFyZW50LiRjaGlsZHJlbjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzaWJsaW5ncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChzaWJsaW5nc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBzaWJsaW5nc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGdldCBmaXJzdENoaWxkKCkge1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLiRjaGlsZHJlblswXTtcbiAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBnZXQgY29tcG9uZW50Um9vdCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZW1hbnRpY01vZGVsLnJvb3Q7XG4gICAgICB9XG4gICAgICBnZXQgaXNMaWZ0ZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTGlmdGVkO1xuICAgICAgfVxuICAgICAgbWFrZVRhcmdldCgpIHtcbiAgICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXUnKTtcbiAgICAgIH1cbiAgICAgIHJlcGxhY2VUZXh0Tm9kZVdpdGhNYXJrZXIoKSB7XG4gICAgICAgICAgY29uc3QgbWFya2VyID0gRWxlbWVudFN5bnRheC5jcmVhdGVNYXJrZXIoKTtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobWFya2VyLm5vZGUsIG5vZGUpO1xuICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSAnICc7XG4gICAgICAgICAgd2hpbGUgKG5vZGUubmV4dFNpYmxpbmcgJiYgbm9kZS5uZXh0U2libGluZy5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0ICovKSB7XG4gICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRUb01hcmtlcihtYXJrZXIpO1xuICAgICAgfVxuICAgICAgcmVwbGFjZU5vZGVXaXRoTWFya2VyKCkge1xuICAgICAgICAgIGNvbnN0IG1hcmtlciA9IEVsZW1lbnRTeW50YXguY3JlYXRlTWFya2VyKCk7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobWFya2VyLm5vZGUsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50LmFwcGVuZENoaWxkKG1hcmtlci5ub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRUb01hcmtlcihtYXJrZXIpO1xuICAgICAgfVxuICAgICAgbGlmdChpbnN0cnVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gaW5zdHJ1Y3Rpb24uZGVmLnRlbXBsYXRlID0gcnVudGltZS5ET00uY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLmlzVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgLy8gY29weSByZW1haW5pbmcgYXR0cmlidXRlcyBvdmVyIHRvIHRoZSBuZXdseSBjcmVhdGVkIHRlbXBsYXRlXG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgIHdoaWxlIChhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbMF07XG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChub2RlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VOb2RlV2l0aE1hcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlTm9kZVdpdGhNYXJrZXIoKTtcbiAgICAgICAgICAgICAgdGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hZGRJbnN0cnVjdGlvbnMoW2luc3RydWN0aW9uXSk7XG4gICAgICAgICAgdGhpcy5faXNMaWZ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbWFudGljTW9kZWwuZ2V0VGVtcGxhdGVFbGVtZW50U3ltYm9sKHRoaXMuc2VtYW50aWNNb2RlbC5lbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSksIHRoaXMsIGluc3RydWN0aW9uLmRlZiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBhZGRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0gdGhpcy4kcm9vdC5kZWZpbml0aW9uO1xuICAgICAgICAgIGlmIChkZWYuaW5zdHJ1Y3Rpb25zID09PSBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheSkge1xuICAgICAgICAgICAgICBkZWYuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZi5pbnN0cnVjdGlvbnMucHVzaChpbnN0cnVjdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2V0VG9NYXJrZXIobWFya2VyKSB7XG4gICAgICAgICAgdGhpcy5fJGNvbnRlbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2lzQ3VzdG9tRWxlbWVudCA9IHRoaXMuX2lzTGV0ID0gdGhpcy5faXNTbG90ID0gdGhpcy5faXNUZW1wbGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2lzTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9uYW1lID0gJ0FVLU1BUktFUic7XG4gICAgICAgICAgdGhpcy5fbm9kZSA9IG1hcmtlci5ub2RlO1xuICAgICAgICAgIHRoaXMuX3N5bnRheCA9IG1hcmtlcjtcbiAgICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMuVGVtcGxhdGVDb21waWxlciA9IGNsYXNzIFRlbXBsYXRlQ29tcGlsZXIge1xuICAgICAgY29uc3RydWN0b3IoZXhwclBhcnNlciwgZWxQYXJzZXIsIGF0dHJQYXJzZXIpIHtcbiAgICAgICAgICB0aGlzLmV4cHJQYXJzZXIgPSBleHByUGFyc2VyO1xuICAgICAgICAgIHRoaXMuZWxQYXJzZXIgPSBlbFBhcnNlcjtcbiAgICAgICAgICB0aGlzLmF0dHJQYXJzZXIgPSBhdHRyUGFyc2VyO1xuICAgICAgfVxuICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgcmV0dXJuICdkZWZhdWx0JztcbiAgICAgIH1cbiAgICAgIGNvbXBpbGUoZGVmaW5pdGlvbiwgcmVzb3VyY2VzLCBmbGFncykge1xuICAgICAgICAgIGNvbnN0IG1vZGVsID0gU2VtYW50aWNNb2RlbC5jcmVhdGUoZGVmaW5pdGlvbiwgcmVzb3VyY2VzLCB0aGlzLmF0dHJQYXJzZXIsIHRoaXMuZWxQYXJzZXIsIHRoaXMuZXhwclBhcnNlcik7XG4gICAgICAgICAgY29uc3Qgcm9vdCA9IG1vZGVsLnJvb3Q7XG4gICAgICAgICAgbGV0ICRlbCA9IHJvb3QuaXNUZW1wbGF0ZSA/IHJvb3QuJGNvbnRlbnQgOiByb290O1xuICAgICAgICAgIHdoaWxlICgkZWwgPSB0aGlzLmNvbXBpbGVOb2RlKCRlbCkpXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAvLyB0aGUgZmxhZyBzaG91bGQgYmUgcGFzc2VkIGNvcnJlY3RseSBmcm9tIHJlbmRlcmluZyBlbmdpbmVcbiAgICAgICAgICBpZiAocm9vdC5pc1RlbXBsYXRlICYmIChmbGFncyAmIHJ1bnRpbWUuVmlld0NvbXBpbGVGbGFncy5zdXJyb2dhdGUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcGlsZVN1cnJvZ2F0ZShyb290KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICB9XG4gICAgICBjb21waWxlTm9kZSgkZWwpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gJGVsLm5vZGU7XG4gICAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSAkZWwubmV4dFNpYmxpbmc7XG4gICAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMSAvKiBFbGVtZW50ICovOlxuICAgICAgICAgICAgICAgICAgaWYgKCRlbC5pc1Nsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkZWwuJHJvb3QuZGVmaW5pdGlvbi5oYXNTbG90cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICgkZWwuaXNMZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVMZXRFbGVtZW50KCRlbCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICgkZWwuaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlQ3VzdG9tRWxlbWVudCgkZWwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlRWxlbWVudE5vZGUoJGVsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghJGVsLmlzTGlmdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0ICRjaGlsZCA9ICRlbC5maXJzdENoaWxkIHx8ICRlbC4kY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoJGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICRjaGlsZCA9IHRoaXMuY29tcGlsZU5vZGUoJGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIGNhc2UgMyAvKiBUZXh0ICovOlxuICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMuZXhwclBhcnNlci5wYXJzZSgkZWwubm9kZS53aG9sZVRleHQsIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyk7XG4gICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoJGVsID0gJGVsLm5leHRTaWJsaW5nKSAmJiAkZWwubm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRlbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICRlbC5yZXBsYWNlVGV4dE5vZGVXaXRoTWFya2VyKCk7XG4gICAgICAgICAgICAgICAgICAkZWwuYWRkSW5zdHJ1Y3Rpb25zKFtuZXcgVGV4dEJpbmRpbmdJbnN0cnVjdGlvbihleHByZXNzaW9uKV0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICBjYXNlIDggLyogQ29tbWVudCAqLzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgY2FzZSA5IC8qIERvY3VtZW50ICovOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICRlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBjYXNlIDEwIC8qIERvY3VtZW50VHlwZSAqLzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgY2FzZSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICRlbC5maXJzdENoaWxkO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbXBpbGVTdXJyb2dhdGUoJGVsKSB7XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9ICRlbC4kYXR0cmlidXRlcztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgY29uc3QgJGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgICBpZiAoJGF0dHIuaXNUZW1wbGF0ZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgdGVtcGxhdGUgY29udHJvbGxlciBvbiBzdXJyb2dhdGUgZWxlbWVudC4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHRoaXMuY29tcGlsZUF0dHJpYnV0ZSgkYXR0cik7XG4gICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgJGVsLmRlZmluaXRpb24uc3Vycm9nYXRlcy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGxldCBhdHRySW5zdDtcbiAgICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgdGhlc2UgcHJvcGVydGllcyBhcyB0aGV5IG5lZWQgdG8gYmUgdW5pcXVlXG4gICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gJGF0dHIudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdpZCcgJiYgbmFtZSAhPT0gJ3BhcnQnICYmIG5hbWUgIT09ICdyZXBsYWNlLXBhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSBzaW1wbGUgc3Vycm9nYXRlIHN0eWxlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRySW5zdCA9IG5ldyBTZXRBdHRyaWJ1dGVJbnN0cnVjdGlvbigkYXR0ci5yYXdWYWx1ZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJJbnN0ID0gbmV3IFNldEF0dHJpYnV0ZUluc3RydWN0aW9uKCRhdHRyLnJhd1ZhbHVlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgJGVsLmRlZmluaXRpb24uc3Vycm9nYXRlcy5wdXNoKGF0dHJJbnN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdXJyb2dhdGUgYXR0cmlidXRlOiAke25hbWV9YCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb21waWxlRWxlbWVudE5vZGUoJGVsKSB7XG4gICAgICAgICAgaWYgKCRlbC4kYXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gJGVsLiRhdHRyaWJ1dGVzO1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZUluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICBjb25zdCAkYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgIGlmICgkYXR0ci5pc1Byb2Nlc3NlZClcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAkYXR0ci5tYXJrQXNQcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgaWYgKCRhdHRyLmlzVGVtcGxhdGVDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb24gPSB0aGlzLmNvbXBpbGVBdHRyaWJ1dGUoJGF0dHIpO1xuICAgICAgICAgICAgICAgICAgLy8gY29tcGlsZUF0dHJpYnV0ZSB3aWxsIHJldHVybiBhIEh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIgaWYgdGhlcmUgaXMgYSBiaW5kaW5nIGNvbW1hbmQgcmVnaXN0ZXJlZCB0aGF0IHByb2R1Y2VzIG9uZSAoaW4gb3VyIGNhc2Ugb25seSBcImZvclwiKVxuICAgICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnR5cGUgIT09IFwibVwiIC8qIGh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gJGF0dHIucmVzO1xuICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gbmV3IEh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIoeyBuYW1lLCBpbnN0cnVjdGlvbnM6IFtdIH0sIG5hbWUsIFtpbnN0cnVjdGlvbl0sIG5hbWUgPT09ICdlbHNlJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBhbGwgYXR0cmlidXRlIGluc3RydWN0aW9ucyBwcmVjZWRpbmcgdGhlIHRlbXBsYXRlIGNvbnRyb2xsZXIgYmVjb21lIGNoaWxkcmVuIG9mIHRoZSBoeWRyYXRlIGluc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbnMucHVzaCguLi5hdHRyaWJ1dGVJbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlTm9kZSgkZWwubGlmdChpbnN0cnVjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCRhdHRyLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnN0cnVjdGlvbnMucHVzaCh0aGlzLmNvbXBpbGVDdXN0b21BdHRyaWJ1dGUoJGF0dHIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gdGhpcy5jb21waWxlQXR0cmlidXRlKCRhdHRyKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUluc3RydWN0aW9ucy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlSW5zdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAkZWwuYWRkSW5zdHJ1Y3Rpb25zKGF0dHJpYnV0ZUluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICAgICRlbC5tYWtlVGFyZ2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tcGlsZUN1c3RvbUVsZW1lbnQoJGVsKSB7XG4gICAgICAgICAgaWYgKCRlbC4kYXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgJGVsLmFkZEluc3RydWN0aW9ucyhbbmV3IEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24oJGVsLmRlZmluaXRpb24ubmFtZSwga2VybmVsLlBMQVRGT1JNLmVtcHR5QXJyYXkpXSk7XG4gICAgICAgICAgICAgIGlmICgkZWwuZGVmaW5pdGlvbi5jb250YWluZXJsZXNzKSB7XG4gICAgICAgICAgICAgICAgICAkZWwucmVwbGFjZU5vZGVXaXRoTWFya2VyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkZWwubWFrZVRhcmdldCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBjdXN0b20gZWxlbWVudCwgdGhlbiBvbmx5IHRoZSBhdHRyaWJ1dGVzIHRoYXQgbWFwIHRvIGJpbmRhYmxlcyBiZWNvbWUgY2hpbGRyZW4gb2YgdGhlIGh5ZHJhdGUgaW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZXkgYmVjb21lIHNpYmxpbmcgaW5zdHJ1Y3Rpb25zOyBpZiB0aGVyZSBpcyBubyBjdXN0b20gZWxlbWVudCwgdGhlbiBzaWJsaW5nIGluc3RydWN0aW9ucyBhcmUgbmV2ZXIgYXBwZW5kZWQgdG9cbiAgICAgICAgICBjb25zdCBzaWJsaW5nSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9ICRlbC4kYXR0cmlidXRlcztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgY29uc3QgJGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgICBpZiAoJGF0dHIuaXNQcm9jZXNzZWQpXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgJGF0dHIubWFya0FzUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIGlmICgkYXR0ci5pc1RlbXBsYXRlQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgbGV0IGluc3RydWN0aW9uID0gdGhpcy5jb21waWxlQXR0cmlidXRlKCRhdHRyKTtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVBdHRyaWJ1dGUgd2lsbCByZXR1cm4gYSBIeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyIGlmIHRoZXJlIGlzIGEgYmluZGluZyBjb21tYW5kIHJlZ2lzdGVyZWQgdGhhdCBwcm9kdWNlcyBvbmUgKGluIG91ciBjYXNlIG9ubHkgXCJmb3JcIilcbiAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi50eXBlICE9PSBcIm1cIiAvKiBoeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9ICRhdHRyLnJlcztcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IG5ldyBIeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyKHsgbmFtZSwgaW5zdHJ1Y3Rpb25zOiBbXSB9LCBuYW1lLCBbaW5zdHJ1Y3Rpb25dLCBuYW1lID09PSAnZWxzZScpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gYWxsIGF0dHJpYnV0ZSBpbnN0cnVjdGlvbnMgcHJlY2VkaW5nIHRoZSB0ZW1wbGF0ZSBjb250cm9sbGVyIGJlY29tZSBjaGlsZHJlbiBvZiB0aGUgaHlkcmF0ZSBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2goLi4uYXR0cmlidXRlSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZU5vZGUoJGVsLmxpZnQoaW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICgkYXR0ci5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCRhdHRyLmlzQXR0cmlidXRlQmluZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5jb21waWxlQ3VzdG9tQXR0cmlidXRlKCRhdHRyKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnN0cnVjdGlvbnMucHVzaCh0aGlzLmNvbXBpbGVDdXN0b21BdHRyaWJ1dGUoJGF0dHIpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gdGhpcy5jb21waWxlQXR0cmlidXRlKCRhdHRyKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghJGF0dHIuaXNFbGVtZW50QmluZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ0luc3RydWN0aW9ucy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUluc3RydWN0aW9ucy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgJGVsLmFkZEluc3RydWN0aW9ucyhbbmV3IEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24oJGVsLmRlZmluaXRpb24ubmFtZSwgYXR0cmlidXRlSW5zdHJ1Y3Rpb25zKSwgLi4uc2libGluZ0luc3RydWN0aW9uc10pO1xuICAgICAgICAgIGlmICgkZWwuZGVmaW5pdGlvbi5jb250YWluZXJsZXNzKSB7XG4gICAgICAgICAgICAgICRlbC5yZXBsYWNlTm9kZVdpdGhNYXJrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICRlbC5tYWtlVGFyZ2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tcGlsZUN1c3RvbUF0dHJpYnV0ZSgkYXR0cikge1xuICAgICAgICAgIGNvbnN0IGNoaWxkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgaWYgKCRhdHRyLmlzTXVsdGlBdHRyQmluZGluZykge1xuICAgICAgICAgICAgICBjb25zdCBtQmluZGluZ3MgPSAkYXR0ci4kbXVsdGlBdHRyQmluZGluZ3M7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IG1CaW5kaW5ncy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZEluc3RydWN0aW9ucy5wdXNoKHRoaXMuY29tcGlsZUF0dHJpYnV0ZShtQmluZGluZ3Nbal0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY2hpbGRJbnN0cnVjdGlvbnMucHVzaCh0aGlzLmNvbXBpbGVBdHRyaWJ1dGUoJGF0dHIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBIeWRyYXRlQXR0cmlidXRlSW5zdHJ1Y3Rpb24oJGF0dHIucmVzLCBjaGlsZEluc3RydWN0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb21waWxlTGV0RWxlbWVudCgkZWwpIHtcbiAgICAgICAgICBjb25zdCBsZXRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gJGVsLiRhdHRyaWJ1dGVzO1xuICAgICAgICAgIGxldCB0b1ZpZXdNb2RlbCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpaSA+IGk7ICsraSkge1xuICAgICAgICAgICAgICBjb25zdCAkYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgIGNvbnN0IHRvID0ga2VybmVsLlBMQVRGT1JNLmNhbWVsQ2FzZSgkYXR0ci50byk7XG4gICAgICAgICAgICAgIGlmICgkYXR0ci5oYXNCaW5kaW5nQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuZXhwclBhcnNlci5wYXJzZSgkYXR0ci5yYXdWYWx1ZSwgNTMgLyogQmluZENvbW1hbmQgKi8pO1xuICAgICAgICAgICAgICAgICAgbGV0SW5zdHJ1Y3Rpb25zLnB1c2gobmV3IExldEJpbmRpbmdJbnN0cnVjdGlvbihleHByLCB0bykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCRhdHRyLnJhd05hbWUgPT09ICd0by12aWV3LW1vZGVsJykge1xuICAgICAgICAgICAgICAgICAgdG9WaWV3TW9kZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgJGVsLm5vZGUucmVtb3ZlQXR0cmlidXRlKCd0by12aWV3LW1vZGVsJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBleHByID0gdGhpcy5leHByUGFyc2VyLnBhcnNlKCRhdHRyLnJhd1ZhbHVlLCAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8pO1xuICAgICAgICAgICAgICAgICAgaWYgKGV4cHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQganVzdCBiZSBhIHdhcm5pbmcsIGJ1dCB0aHJvdyBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGxldCBiaW5kaW5nLiBTdHJpbmcgbGl0ZXJuYWwgZ2l2ZW4gZm9yIGF0dHJpYnV0ZTogJHskYXR0ci50b31gKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldEluc3RydWN0aW9ucy5wdXNoKG5ldyBMZXRCaW5kaW5nSW5zdHJ1Y3Rpb24oZXhwciwgdG8pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAkZWwuYWRkSW5zdHJ1Y3Rpb25zKFtuZXcgTGV0RWxlbWVudEluc3RydWN0aW9uKGxldEluc3RydWN0aW9ucywgdG9WaWV3TW9kZWwpXSk7XG4gICAgICAgICAgLy8gdGhlb3JldGljYWxseSB0aGVyZSdzIG5vIG5lZWQgdG8gcmVwbGFjZSwgYnV0IHRvIGtlZXAgaXQgY29uc2lzdGVudFxuICAgICAgICAgICRlbC5yZXBsYWNlTm9kZVdpdGhNYXJrZXIoKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVBdHRyaWJ1dGUoJGF0dHIpIHtcbiAgICAgICAgICAvLyBiaW5kaW5nIGNvbW1hbmRzIGdldCBwcmlvcml0eSBvdmVyIGFsbDsgdGhleSBtYXkgb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvcnNcbiAgICAgICAgICAvLyBpdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGltcGxlbWVudG9yIHRvIGVuc3VyZSB0aGV5IGZpbHRlciBvdXQgc3R1ZmYgdGhleSBzaG91bGRuJ3Qgb3ZlcnJpZGVcbiAgICAgICAgICBpZiAoJGF0dHIuaXNIYW5kbGVkQnlCaW5kaW5nQ29tbWFuZCkge1xuICAgICAgICAgICAgICByZXR1cm4gJGF0dHIuY29tbWFuZC5jb21waWxlKCRhdHRyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2ltcGxlIHBhdGggZm9yIHJlZiBiaW5kaW5nXG4gICAgICAgICAgY29uc3QgcGFyc2VyID0gdGhpcy5leHByUGFyc2VyO1xuICAgICAgICAgIGlmICgkYXR0ci50YXJnZXQgPT09ICdyZWYnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmVmQmluZGluZ0luc3RydWN0aW9uKHBhcnNlci5wYXJzZSgkYXR0ci5yYXdWYWx1ZSwgMTI4MCAvKiBJc1JlZiAqLykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzaW1wbGUgcGF0aCBmb3Igc3R5bGUgYmluZGluZ3MgKFRPRE86IHRoaXMgZG9lc250IHdvcmssIGJ1dCB3ZSBuZWVkIHRvIHVzZSBTdHlsZVByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uIHJpZ2h0PylcbiAgICAgICAgICAvLyBpZiAodGFyZ2V0ID09PSAnc3R5bGUnIHx8IHRhcmdldCA9PT0gJ2NzcycpIHtcbiAgICAgICAgICAvLyAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZXIucGFyc2UodmFsdWUsIEJpbmRpbmdUeXBlLkludGVycG9sYXRpb24pO1xuICAgICAgICAgIC8vICAgaWYgKGV4cHJlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgICAvLyAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICByZXR1cm4gbmV3IFN0eWxlUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24oZXhwcmVzc2lvbiwgdGFyZ2V0KTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgLy8gcGxhaW4gY3VzdG9tIGF0dHJpYnV0ZSBvbiBhbnkga2luZCBvZiBlbGVtZW50XG4gICAgICAgICAgaWYgKCRhdHRyLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIGlmICghJGF0dHIuaGFzQmluZGluZ0NvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZXIucGFyc2UoJGF0dHIucmF3VmFsdWUsIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyk7XG4gICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkluc3RydWN0aW9uKGV4cHJlc3Npb24sICRhdHRyLnRvKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICgkYXR0ci5pc011bHRpQXR0ckJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNldFByb3BlcnR5SW5zdHJ1Y3Rpb24oJGF0dHIucmF3VmFsdWUsICRhdHRyLnRvKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpbnRlbnRpb25hbCBuZXN0ZWQgYmxvY2sgd2l0aG91dCBhIHN0YXRlbWVudCB0byBlbnN1cmUgdGhlIGV4cHJlc3Npb24gdmFyaWFibGUgaXNuJ3Qgc2hhZG93ZWRcbiAgICAgICAgICAgICAgLy8gKHdlJ3JlIG5vdCBkZWNsYXJpbmcgaXQgYXQgdGhlIG91dGVyIGJsb2NrIGZvciBiZXR0ZXIgdHlwaW5nIHdpdGhvdXQgZXhwbGljaXQgY2FzdGluZylcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlci5wYXJzZSgkYXR0ci5yYXdWYWx1ZSwgNTAgLyogVG9WaWV3Q29tbWFuZCAqLyk7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKCRhdHRyLm1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIHJ1bnRpbWUuQmluZGluZ01vZGUub25lVGltZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPbmVUaW1lQmluZGluZ0luc3RydWN0aW9uKGV4cHJlc3Npb24sICRhdHRyLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIHJ1bnRpbWUuQmluZGluZ01vZGUuZnJvbVZpZXc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnJvbVZpZXdCaW5kaW5nSW5zdHJ1Y3Rpb24oZXhwcmVzc2lvbiwgJGF0dHIudG8pO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgcnVudGltZS5CaW5kaW5nTW9kZS50d29XYXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHdvV2F5QmluZGluZ0luc3RydWN0aW9uKGV4cHJlc3Npb24sICRhdHRyLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIHJ1bnRpbWUuQmluZGluZ01vZGUudG9WaWV3OlxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVG9WaWV3QmluZGluZ0luc3RydWN0aW9uKGV4cHJlc3Npb24sICRhdHRyLnRvKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBwbGFpbiBhdHRyaWJ1dGUgb24gYSBjdXN0b20gZWxlbWVudFxuICAgICAgICAgIGlmICgkYXR0ci5vbkN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgLy8gYmluZGFibGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgIGlmICgkYXR0ci5pc0VsZW1lbnRCaW5kYWJsZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlci5wYXJzZSgkYXR0ci5yYXdWYWx1ZSwgMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gbm8gaW50ZXJwb2xhdGlvbiAtPiBtYWtlIGl0IGEgc2V0UHJvcGVydHkgb24gdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2V0UHJvcGVydHlJbnN0cnVjdGlvbigkYXR0ci5yYXdWYWx1ZSwgJGF0dHIudG8pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gaW50ZXJwb2xhdGlvbiAtPiBiZWhhdmUgbGlrZSB0b1ZpZXcgKGUuZy4gZm9vPVwiJHtzb21lUHJvcH1cIilcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkluc3RydWN0aW9uKGV4cHJlc3Npb24sICRhdHRyLnRvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIHBsYWluIGF0dHJpYnV0ZSBvbiBhIG5vcm1hbCBlbGVtZW50XG4gICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZXIucGFyc2UoJGF0dHIucmF3VmFsdWUsIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyk7XG4gICAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBubyBpbnRlcnBvbGF0aW9uIC0+IGRvIG5vdCByZXR1cm4gYW4gaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGludGVycG9sYXRpb24gLT4gYmVoYXZlIGxpa2UgdG9WaWV3IChlLmcuIGlkPVwiJHtzb21lSWR9XCIpXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkluc3RydWN0aW9uKGV4cHJlc3Npb24sICRhdHRyLnRvKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH07XG4gIGV4cG9ydHMuVGVtcGxhdGVDb21waWxlciA9IF9fZGVjb3JhdGUoW1xuICAgICAga2VybmVsLmluamVjdChydW50aW1lLklFeHByZXNzaW9uUGFyc2VyLCBJRWxlbWVudFBhcnNlciwgSUF0dHJpYnV0ZVBhcnNlcilcbiAgXSwgZXhwb3J0cy5UZW1wbGF0ZUNvbXBpbGVyKTtcblxuICBjb25zdCBnbG9iYWxSZXNvdXJjZXMgPSBbXG4gICAgICBydW50aW1lLkNvbXBvc2UsXG4gICAgICBydW50aW1lLklmLFxuICAgICAgcnVudGltZS5FbHNlLFxuICAgICAgcnVudGltZS5SZXBlYXQsXG4gICAgICBydW50aW1lLlJlcGxhY2VhYmxlLFxuICAgICAgcnVudGltZS5XaXRoLFxuICAgICAgcnVudGltZS5TYW5pdGl6ZVZhbHVlQ29udmVydGVyLFxuICAgICAgcnVudGltZS5BdHRyQmluZGluZ0JlaGF2aW9yLFxuICAgICAgcnVudGltZS5EZWJvdW5jZUJpbmRpbmdCZWhhdmlvcixcbiAgICAgIHJ1bnRpbWUuT25lVGltZUJpbmRpbmdCZWhhdmlvcixcbiAgICAgIHJ1bnRpbWUuVG9WaWV3QmluZGluZ0JlaGF2aW9yLFxuICAgICAgcnVudGltZS5Gcm9tVmlld0JpbmRpbmdCZWhhdmlvcixcbiAgICAgIHJ1bnRpbWUuU2VsZkJpbmRpbmdCZWhhdmlvcixcbiAgICAgIHJ1bnRpbWUuU2lnbmFsQmluZGluZ0JlaGF2aW9yLFxuICAgICAgcnVudGltZS5UaHJvdHRsZUJpbmRpbmdCZWhhdmlvcixcbiAgICAgIHJ1bnRpbWUuVHdvV2F5QmluZGluZ0JlaGF2aW9yLFxuICAgICAgcnVudGltZS5VcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yXG4gIF07XG4gIGNvbnN0IGRlZmF1bHRCaW5kaW5nTGFuZ3VhZ2UgPSBbXG4gICAgICBleHBvcnRzLkRlZmF1bHRCaW5kaW5nQ29tbWFuZCxcbiAgICAgIGV4cG9ydHMuT25lVGltZUJpbmRpbmdDb21tYW5kLFxuICAgICAgZXhwb3J0cy5Ub1ZpZXdCaW5kaW5nQ29tbWFuZCxcbiAgICAgIGV4cG9ydHMuRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCxcbiAgICAgIGV4cG9ydHMuVHdvV2F5QmluZGluZ0NvbW1hbmQsXG4gICAgICBleHBvcnRzLlRyaWdnZXJCaW5kaW5nQ29tbWFuZCxcbiAgICAgIGV4cG9ydHMuRGVsZWdhdGVCaW5kaW5nQ29tbWFuZCxcbiAgICAgIGV4cG9ydHMuQ2FwdHVyZUJpbmRpbmdDb21tYW5kLFxuICAgICAgZXhwb3J0cy5DYWxsQmluZGluZ0NvbW1hbmQsXG4gICAgICBleHBvcnRzLkZvckJpbmRpbmdDb21tYW5kXG4gIF07XG4gIGNvbnN0IEJhc2ljQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlcihQYXJzZXJSZWdpc3RyYXRpb24sIGtlcm5lbC5SZWdpc3RyYXRpb24uc2luZ2xldG9uKHJ1bnRpbWUuSVRlbXBsYXRlQ29tcGlsZXIsIGV4cG9ydHMuVGVtcGxhdGVDb21waWxlciksIC4uLmdsb2JhbFJlc291cmNlcywgLi4uZGVmYXVsdEJpbmRpbmdMYW5ndWFnZSk7XG4gICAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5BdHRyU3ludGF4ID0gQXR0clN5bnRheDtcbiAgZXhwb3J0cy5JQXR0cmlidXRlUGFyc2VyID0gSUF0dHJpYnV0ZVBhcnNlcjtcbiAgZXhwb3J0cy5BdHRyaWJ1dGVQYXJzZXIgPSBBdHRyaWJ1dGVQYXJzZXI7XG4gIGV4cG9ydHMuYmluZGluZ0NvbW1hbmQgPSBiaW5kaW5nQ29tbWFuZDtcbiAgZXhwb3J0cy5CaW5kaW5nQ29tbWFuZFJlc291cmNlID0gQmluZGluZ0NvbW1hbmRSZXNvdXJjZTtcbiAgZXhwb3J0cy51bmVzY2FwZUNvZGUgPSB1bmVzY2FwZUNvZGU7XG4gIGV4cG9ydHMuQmFzaWNDb25maWd1cmF0aW9uID0gQmFzaWNDb25maWd1cmF0aW9uO1xuICBleHBvcnRzLkVsZW1lbnRTeW50YXggPSBFbGVtZW50U3ludGF4O1xuICBleHBvcnRzLklFbGVtZW50UGFyc2VyID0gSUVsZW1lbnRQYXJzZXI7XG4gIGV4cG9ydHMuUGFyc2VyUmVnaXN0cmF0aW9uID0gUGFyc2VyUmVnaXN0cmF0aW9uO1xuICBleHBvcnRzLlBhcnNlclN0YXRlID0gUGFyc2VyU3RhdGU7XG4gIGV4cG9ydHMucGFyc2VDb3JlID0gcGFyc2VDb3JlO1xuICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gIGV4cG9ydHMuVGV4dEJpbmRpbmdJbnN0cnVjdGlvbiA9IFRleHRCaW5kaW5nSW5zdHJ1Y3Rpb247XG4gIGV4cG9ydHMuSW50ZXJwb2xhdGlvbkluc3RydWN0aW9uID0gSW50ZXJwb2xhdGlvbkluc3RydWN0aW9uO1xuICBleHBvcnRzLk9uZVRpbWVCaW5kaW5nSW5zdHJ1Y3Rpb24gPSBPbmVUaW1lQmluZGluZ0luc3RydWN0aW9uO1xuICBleHBvcnRzLlRvVmlld0JpbmRpbmdJbnN0cnVjdGlvbiA9IFRvVmlld0JpbmRpbmdJbnN0cnVjdGlvbjtcbiAgZXhwb3J0cy5Gcm9tVmlld0JpbmRpbmdJbnN0cnVjdGlvbiA9IEZyb21WaWV3QmluZGluZ0luc3RydWN0aW9uO1xuICBleHBvcnRzLlR3b1dheUJpbmRpbmdJbnN0cnVjdGlvbiA9IFR3b1dheUJpbmRpbmdJbnN0cnVjdGlvbjtcbiAgZXhwb3J0cy5JdGVyYXRvckJpbmRpbmdJbnN0cnVjdGlvbiA9IEl0ZXJhdG9yQmluZGluZ0luc3RydWN0aW9uO1xuICBleHBvcnRzLlRyaWdnZXJCaW5kaW5nSW5zdHJ1Y3Rpb24gPSBUcmlnZ2VyQmluZGluZ0luc3RydWN0aW9uO1xuICBleHBvcnRzLkRlbGVnYXRlQmluZGluZ0luc3RydWN0aW9uID0gRGVsZWdhdGVCaW5kaW5nSW5zdHJ1Y3Rpb247XG4gIGV4cG9ydHMuQ2FwdHVyZUJpbmRpbmdJbnN0cnVjdGlvbiA9IENhcHR1cmVCaW5kaW5nSW5zdHJ1Y3Rpb247XG4gIGV4cG9ydHMuQ2FsbEJpbmRpbmdJbnN0cnVjdGlvbiA9IENhbGxCaW5kaW5nSW5zdHJ1Y3Rpb247XG4gIGV4cG9ydHMuUmVmQmluZGluZ0luc3RydWN0aW9uID0gUmVmQmluZGluZ0luc3RydWN0aW9uO1xuICBleHBvcnRzLlN0eWxlUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24gPSBTdHlsZVByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uO1xuICBleHBvcnRzLlNldFByb3BlcnR5SW5zdHJ1Y3Rpb24gPSBTZXRQcm9wZXJ0eUluc3RydWN0aW9uO1xuICBleHBvcnRzLlNldEF0dHJpYnV0ZUluc3RydWN0aW9uID0gU2V0QXR0cmlidXRlSW5zdHJ1Y3Rpb247XG4gIGV4cG9ydHMuSHlkcmF0ZUVsZW1lbnRJbnN0cnVjdGlvbiA9IEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb247XG4gIGV4cG9ydHMuSHlkcmF0ZUF0dHJpYnV0ZUluc3RydWN0aW9uID0gSHlkcmF0ZUF0dHJpYnV0ZUluc3RydWN0aW9uO1xuICBleHBvcnRzLkh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIgPSBIeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyO1xuICBleHBvcnRzLkxldEVsZW1lbnRJbnN0cnVjdGlvbiA9IExldEVsZW1lbnRJbnN0cnVjdGlvbjtcbiAgZXhwb3J0cy5MZXRCaW5kaW5nSW5zdHJ1Y3Rpb24gPSBMZXRCaW5kaW5nSW5zdHJ1Y3Rpb247XG4gIGV4cG9ydHMuU2VtYW50aWNNb2RlbCA9IFNlbWFudGljTW9kZWw7XG4gIGV4cG9ydHMuTXVsdGlBdHRyaWJ1dGVCaW5kaW5nU3ltYm9sID0gTXVsdGlBdHRyaWJ1dGVCaW5kaW5nU3ltYm9sO1xuICBleHBvcnRzLkF0dHJpYnV0ZVN5bWJvbCA9IEF0dHJpYnV0ZVN5bWJvbDtcbiAgZXhwb3J0cy5FbGVtZW50U3ltYm9sID0gRWxlbWVudFN5bWJvbDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgudW1kLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@aurelia/jit/dist/index.umd.js\n");

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/index.umd.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/index.umd.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  const camelCaseLookup = {};\n  const kebabCaseLookup = {};\n  const PLATFORM = {\n      global: (function () {\n          // Workers don’t have `window`, only `self`\n          // https://github.com/Microsoft/tslint-microsoft-contrib/issues/415\n          // tslint:disable-next-line:no-typeof-undefined\n          if (typeof self !== 'undefined') {\n              return self;\n          }\n          // https://github.com/Microsoft/tslint-microsoft-contrib/issues/415\n          // tslint:disable-next-line:no-typeof-undefined\n          if (typeof global !== 'undefined') {\n              return global;\n          }\n          // Not all environments allow eval and Function\n          // Use only as a last resort:\n          // tslint:disable-next-line:no-function-constructor-with-string-args\n          return new Function('return this')();\n      })(),\n      emptyArray: Object.freeze([]),\n      emptyObject: Object.freeze({}),\n      /* tslint:disable-next-line:no-empty */\n      noop() { },\n      now() {\n          return performance.now();\n      },\n      camelCase(input) {\n          // benchmark: http://jsben.ch/qIz4Z\n          let value = camelCaseLookup[input];\n          if (value !== undefined)\n              return value;\n          value = '';\n          let first = true;\n          let sep = false;\n          let char;\n          for (let i = 0, ii = input.length; i < ii; ++i) {\n              char = input.charAt(i);\n              if (char === '-' || char === '.' || char === '_') {\n                  sep = true; // skip separators\n              }\n              else {\n                  value = value + (first ? char.toLowerCase() : (sep ? char.toUpperCase() : char));\n                  sep = false;\n              }\n              first = false;\n          }\n          return camelCaseLookup[input] = value;\n      },\n      kebabCase(input) {\n          // benchmark: http://jsben.ch/v7K9T\n          let value = kebabCaseLookup[input];\n          if (value !== undefined)\n              return value;\n          value = '';\n          let first = true;\n          let char, lower;\n          for (let i = 0, ii = input.length; i < ii; ++i) {\n              char = input.charAt(i);\n              lower = char.toLowerCase();\n              value = value + (first ? lower : (char !== lower ? `-${lower}` : lower));\n              first = false;\n          }\n          return kebabCaseLookup[input] = value;\n      },\n      toArray(input) {\n          // benchmark: http://jsben.ch/xjsyF\n          const len = input.length;\n          const arr = Array(len);\n          for (let i = 0; i < len; ++i) {\n              arr[i] = input[i];\n          }\n          return arr;\n      },\n      requestAnimationFrame(callback) {\n          return requestAnimationFrame(callback);\n      }\n  };\n\n  const Reporter = {\n      /* tslint:disable-next-line:no-empty */\n      write(code, ...params) { },\n      error(code, ...params) { return new Error(`Code ${code}`); }\n  };\n\n  // Shims to augment the Reflect object with methods used from the Reflect Metadata API proposal:\n  // https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\n  // https://rbuckton.github.io/reflect-metadata/\n  // As the official spec proposal uses \"any\", we use it here as well and suppress related typedef linting warnings.\n  if (!('getOwnMetadata' in Reflect)) {\n      // tslint:disable-next-line:no-any\n      Reflect.getOwnMetadata = function (metadataKey, target) {\n          return target[metadataKey];\n      };\n      // tslint:disable-next-line:no-any\n      Reflect.metadata = function (metadataKey, metadataValue) {\n          return function (target) {\n              target[metadataKey] = metadataValue;\n          };\n      };\n  }\n  const DI = {\n      createContainer() {\n          return new Container();\n      },\n      getDesignParamTypes(target) {\n          return Reflect.getOwnMetadata('design:paramtypes', target) || PLATFORM.emptyArray;\n      },\n      getDependencies(type) {\n          let dependencies;\n          if (type.inject === undefined) {\n              dependencies = DI.getDesignParamTypes(type);\n          }\n          else {\n              dependencies = [];\n              let ctor = type;\n              while (typeof ctor === 'function') {\n                  if (ctor.hasOwnProperty('inject')) {\n                      dependencies.push(...ctor.inject);\n                  }\n                  ctor = Object.getPrototypeOf(ctor);\n              }\n          }\n          return dependencies;\n      },\n      createInterface(friendlyName) {\n          const Key = function (target, property, index) {\n              Key.friendlyName = friendlyName || 'Interface';\n              (target.inject || (target.inject = []))[index] = Key;\n              return target;\n          };\n          Key.noDefault = function () {\n              return Key;\n          };\n          Key.withDefault = function (configure) {\n              Key.withDefault = function () {\n                  throw Reporter.error(17, Key);\n              };\n              Key.register = function (container, key) {\n                  const trueKey = key || Key;\n                  return configure({\n                      instance(value) {\n                          return container.registerResolver(trueKey, new Resolver(trueKey, 0 /* instance */, value));\n                      },\n                      singleton(value) {\n                          return container.registerResolver(trueKey, new Resolver(trueKey, 1 /* singleton */, value));\n                      },\n                      transient(value) {\n                          return container.registerResolver(trueKey, new Resolver(trueKey, 2 /* transient */, value));\n                      },\n                      callback(value) {\n                          return container.registerResolver(trueKey, new Resolver(trueKey, 3 /* callback */, value));\n                      },\n                      aliasTo(destinationKey) {\n                          return container.registerResolver(trueKey, new Resolver(trueKey, 5 /* alias */, destinationKey));\n                      },\n                  });\n              };\n              return Key;\n          };\n          return Key;\n      },\n      inject(...dependencies) {\n          return function (target, key, descriptor) {\n              if (typeof descriptor === 'number') { // It's a parameter decorator.\n                  if (!target.hasOwnProperty('inject')) {\n                      target.inject = DI.getDesignParamTypes(target).slice();\n                  }\n                  if (dependencies.length === 1) {\n                      target.inject[descriptor] = dependencies[0];\n                  }\n              }\n              else if (key) { // It's a property decorator. Not supported by the container without plugins.\n                  const actualTarget = target.constructor;\n                  (actualTarget.inject || (actualTarget.inject = {}))[key] = dependencies[0];\n              }\n              else if (descriptor) { // It's a function decorator (not a Class constructor)\n                  const fn = descriptor.value;\n                  fn.inject = dependencies;\n              }\n              else { // It's a class decorator.\n                  if (!dependencies || dependencies.length === 0) {\n                      target.inject = DI.getDesignParamTypes(target).slice();\n                  }\n                  else {\n                      target.inject = dependencies;\n                  }\n              }\n          };\n      },\n      // tslint:disable:jsdoc-format\n      /**\n       * Registers the `target` class as a transient dependency; each time the dependency is resolved\n       * a new instance will be created.\n       *\n       * @param target The class / constructor function to register as transient.\n       * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n       *\n       * Example usage:\n    ```ts\n    // On an existing class\n    class Foo { }\n    DI.transient(Foo);\n    \n    // Inline declaration\n    const Foo = DI.transient(class { });\n    // Foo is now strongly typed with register\n    Foo.register(container);\n    ```\n       */\n      // tslint:enable:jsdoc-format\n      transient(target) {\n          target.register = function register(container) {\n              return Registration.transient(target, target).register(container, target);\n          };\n          return target;\n      },\n      // tslint:disable:jsdoc-format\n      /**\n       * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n       * consecutive time the dependency is resolved, the same instance will be returned.\n       *\n       * @param target The class / constructor function to register as a singleton.\n       * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n       * Example usage:\n    ```ts\n    // On an existing class\n    class Foo { }\n    DI.singleton(Foo);\n    \n    // Inline declaration\n    const Foo = DI.singleton(class { });\n    // Foo is now strongly typed with register\n    Foo.register(container);\n    ```\n       */\n      // tslint:enable:jsdoc-format\n      singleton(target) {\n          target.register = function register(container) {\n              return Registration.singleton(target, target).register(container, target);\n          };\n          return target;\n      }\n  };\n  const IContainer = DI.createInterface().noDefault();\n  const IServiceLocator = IContainer;\n  function createResolver(getter) {\n      return function (key) {\n          const Key = function Key(target, property, descriptor) {\n              return DI.inject(Key)(target, property, descriptor);\n          };\n          Key.resolve = function (handler, requestor) {\n              return getter(key, handler, requestor);\n          };\n          return Key;\n      };\n  }\n  const inject = DI.inject;\n  function transientDecorator(target) {\n      return DI.transient(target);\n  }\n  function transient(target) {\n      return target === undefined ? transientDecorator : transientDecorator(target);\n  }\n  function singletonDecorator(target) {\n      return DI.singleton(target);\n  }\n  function singleton(target) {\n      return target === undefined ? singletonDecorator : singletonDecorator(target);\n  }\n  const all = createResolver((key, handler, requestor) => requestor.getAll(key));\n  const lazy = createResolver((key, handler, requestor) => {\n      let instance = null; // cache locally so that lazy always returns the same instance once resolved\n      return () => {\n          if (instance === null) {\n              instance = requestor.get(key);\n          }\n          return instance;\n      };\n  });\n  const optional = createResolver((key, handler, requestor) => {\n      if (requestor.has(key, true)) {\n          return requestor.get(key);\n      }\n      else {\n          return null;\n      }\n  });\n  /*@internal*/\n  class Resolver {\n      constructor(key, strategy, state) {\n          this.key = key;\n          this.strategy = strategy;\n          this.state = state;\n      }\n      register(container, key) {\n          return container.registerResolver(key || this.key, this);\n      }\n      resolve(handler, requestor) {\n          switch (this.strategy) {\n              case 0 /* instance */:\n                  return this.state;\n              case 1 /* singleton */:\n                  this.strategy = 0 /* instance */;\n                  return this.state = handler.getFactory(this.state).construct(handler);\n              case 2 /* transient */:\n                  // Always create transients from the requesting container\n                  return handler.getFactory(this.state).construct(requestor);\n              case 3 /* callback */:\n                  return this.state(handler, requestor, this);\n              case 4 /* array */:\n                  return this.state[0].resolve(handler, requestor);\n              case 5 /* alias */:\n                  return handler.get(this.state);\n              default:\n                  throw Reporter.error(6, this.strategy);\n          }\n      }\n      getFactory(container) {\n          switch (this.strategy) {\n              case 1 /* singleton */:\n              case 2 /* transient */:\n                  return container.getFactory(this.state);\n              default:\n                  return null;\n          }\n      }\n  }\n  /*@internal*/\n  class Factory {\n      constructor(type, invoker, dependencies) {\n          this.type = type;\n          this.invoker = invoker;\n          this.dependencies = dependencies;\n          this.transformers = null;\n      }\n      static create(type) {\n          const dependencies = DI.getDependencies(type);\n          const invoker = classInvokers[dependencies.length] || fallbackInvoker;\n          return new Factory(type, invoker, dependencies);\n      }\n      construct(container, dynamicDependencies) {\n          const transformers = this.transformers;\n          let instance = dynamicDependencies !== undefined\n              ? this.invoker.invokeWithDynamicDependencies(container, this.type, this.dependencies, dynamicDependencies)\n              : this.invoker.invoke(container, this.type, this.dependencies);\n          if (transformers === null) {\n              return instance;\n          }\n          for (let i = 0, ii = transformers.length; i < ii; ++i) {\n              instance = transformers[i](instance);\n          }\n          return instance;\n      }\n      registerTransformer(transformer) {\n          if (this.transformers === null) {\n              this.transformers = [];\n          }\n          this.transformers.push(transformer);\n          return true;\n      }\n  }\n  const containerResolver = {\n      resolve(handler, requestor) {\n          return requestor;\n      }\n  };\n  function isRegistry(obj) {\n      return typeof obj.register === 'function';\n  }\n  /*@internal*/\n  class Container {\n      constructor(configuration = {}) {\n          this.parent = null;\n          this.resolvers = new Map();\n          this.configuration = configuration;\n          this.factories = configuration.factories || (configuration.factories = new Map());\n          this.resolvers.set(IContainer, containerResolver);\n      }\n      register(...params) {\n          for (let i = 0, ii = params.length; i < ii; ++i) {\n              const current = params[i];\n              if (isRegistry(current)) {\n                  current.register(this);\n              }\n              else {\n                  const keys = Object.keys(current);\n                  for (let j = 0, jj = keys.length; j < jj; ++j) {\n                      const value = current[keys[j]];\n                      // note: we could remove this if-branch and call this.register directly\n                      // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n                      if (isRegistry(value)) {\n                          value.register(this);\n                      }\n                      else {\n                          this.register(value);\n                      }\n                  }\n              }\n          }\n      }\n      registerResolver(key, resolver) {\n          validateKey(key);\n          const resolvers = this.resolvers;\n          const result = resolvers.get(key);\n          if (result === undefined) {\n              resolvers.set(key, resolver);\n          }\n          else if (result instanceof Resolver && result.strategy === 4 /* array */) {\n              result.state.push(resolver);\n          }\n          else {\n              resolvers.set(key, new Resolver(key, 4 /* array */, [result, resolver]));\n          }\n          return resolver;\n      }\n      registerTransformer(key, transformer) {\n          const resolver = this.getResolver(key);\n          if (resolver === null) {\n              return false;\n          }\n          if (resolver.getFactory) {\n              const handler = resolver.getFactory(this);\n              if (handler === null) {\n                  return false;\n              }\n              return handler.registerTransformer(transformer);\n          }\n          return false;\n      }\n      getResolver(key, autoRegister = true) {\n          validateKey(key);\n          if (key.resolve) {\n              return key;\n          }\n          let current = this;\n          while (current !== null) {\n              const resolver = current.resolvers.get(key);\n              if (resolver === undefined) {\n                  if (current.parent === null) {\n                      return autoRegister ? this.jitRegister(key, current) : null;\n                  }\n                  current = current.parent;\n              }\n              else {\n                  return resolver;\n              }\n          }\n          return null;\n      }\n      has(key, searchAncestors = false) {\n          return this.resolvers.has(key)\n              ? true\n              : searchAncestors && this.parent !== null\n                  ? this.parent.has(key, true)\n                  : false;\n      }\n      get(key) {\n          validateKey(key);\n          if (key.resolve) {\n              return key.resolve(this, this);\n          }\n          let current = this;\n          while (current !== null) {\n              const resolver = current.resolvers.get(key);\n              if (resolver === undefined) {\n                  if (current.parent === null) {\n                      return this.jitRegister(key, current).resolve(current, this);\n                  }\n                  current = current.parent;\n              }\n              else {\n                  return resolver.resolve(current, this);\n              }\n          }\n      }\n      getAll(key) {\n          validateKey(key);\n          let current = this;\n          while (current !== null) {\n              const resolver = current.resolvers.get(key);\n              if (resolver === undefined) {\n                  if (this.parent === null) {\n                      return PLATFORM.emptyArray;\n                  }\n                  current = current.parent;\n              }\n              else {\n                  return buildAllResponse(resolver, current, this);\n              }\n          }\n          return PLATFORM.emptyArray;\n      }\n      getFactory(type) {\n          let factory = this.factories.get(type);\n          if (factory === undefined) {\n              factory = Factory.create(type);\n              this.factories.set(type, factory);\n          }\n          return factory;\n      }\n      createChild() {\n          const child = new Container(this.configuration);\n          child.parent = this;\n          return child;\n      }\n      jitRegister(keyAsValue, handler) {\n          if (keyAsValue.register) {\n              const registrationResolver = keyAsValue.register(handler, keyAsValue);\n              if (!(registrationResolver && registrationResolver.resolve)) {\n                  throw Reporter.error(40); // did not return a valid resolver from the static register method\n              }\n              return registrationResolver;\n          }\n          const resolver = new Resolver(keyAsValue, 1 /* singleton */, keyAsValue);\n          handler.resolvers.set(keyAsValue, resolver);\n          return resolver;\n      }\n  }\n  const Registration = {\n      instance(key, value) {\n          return new Resolver(key, 0 /* instance */, value);\n      },\n      singleton(key, value) {\n          return new Resolver(key, 1 /* singleton */, value);\n      },\n      transient(key, value) {\n          return new Resolver(key, 2 /* transient */, value);\n      },\n      callback(key, callback) {\n          return new Resolver(key, 3 /* callback */, callback);\n      },\n      alias(originalKey, aliasKey) {\n          return new Resolver(aliasKey, 5 /* alias */, originalKey);\n      },\n      interpret(interpreterKey, ...rest) {\n          return {\n              register(container) {\n                  const resolver = container.getResolver(interpreterKey);\n                  if (resolver !== null) {\n                      let registry = null;\n                      if (resolver.getFactory) {\n                          const factory = resolver.getFactory(container);\n                          if (factory !== null) {\n                              registry = factory.construct(container, rest);\n                          }\n                      }\n                      else {\n                          registry = resolver.resolve(container, container);\n                      }\n                      if (registry !== null) {\n                          registry.register(container);\n                      }\n                  }\n              }\n          };\n      }\n  };\n  /*@internal*/\n  function validateKey(key) {\n      // note: design:paramTypes which will default to Object if the param types cannot be statically analyzed by tsc\n      // this check is intended to properly report on that problem - under no circumstance should Object be a valid key anyway\n      if (key === null || key === undefined || key === Object) {\n          throw Reporter.error(5);\n      }\n  }\n  function buildAllResponse(resolver, handler, requestor) {\n      if (resolver instanceof Resolver && resolver.strategy === 4 /* array */) {\n          const state = resolver.state;\n          let i = state.length;\n          const results = new Array(i);\n          while (i--) {\n              results[i] = state[i].get(handler, requestor);\n          }\n          return results;\n      }\n      return [resolver.resolve(handler, requestor)];\n  }\n  /*@internal*/\n  const classInvokers = [\n      {\n          invoke(container, Type) {\n              return new Type();\n          },\n          invokeWithDynamicDependencies\n      },\n      {\n          invoke(container, Type, deps) {\n              return new Type(container.get(deps[0]));\n          },\n          invokeWithDynamicDependencies\n      },\n      {\n          invoke(container, Type, deps) {\n              return new Type(container.get(deps[0]), container.get(deps[1]));\n          },\n          invokeWithDynamicDependencies\n      },\n      {\n          invoke(container, Type, deps) {\n              return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));\n          },\n          invokeWithDynamicDependencies\n      },\n      {\n          invoke(container, Type, deps) {\n              return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));\n          },\n          invokeWithDynamicDependencies\n      },\n      {\n          invoke(container, Type, deps) {\n              return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));\n          },\n          invokeWithDynamicDependencies\n      }\n  ];\n  /*@internal*/\n  const fallbackInvoker = {\n      invoke: invokeWithDynamicDependencies,\n      invokeWithDynamicDependencies\n  };\n  /*@internal*/\n  function invokeWithDynamicDependencies(container, Type, staticDependencies, dynamicDependencies) {\n      let i = staticDependencies.length;\n      let args = new Array(i);\n      let lookup;\n      while (i--) {\n          lookup = staticDependencies[i];\n          if (lookup === null || lookup === undefined) {\n              throw Reporter.error(7, `Index ${i}.`);\n          }\n          else {\n              args[i] = container.get(lookup);\n          }\n      }\n      if (dynamicDependencies !== undefined) {\n          args = args.concat(dynamicDependencies);\n      }\n      return Reflect.construct(Type, args);\n  }\n\n  exports.DI = DI;\n  exports.IContainer = IContainer;\n  exports.IServiceLocator = IServiceLocator;\n  exports.inject = inject;\n  exports.transient = transient;\n  exports.singleton = singleton;\n  exports.all = all;\n  exports.lazy = lazy;\n  exports.optional = optional;\n  exports.Resolver = Resolver;\n  exports.Factory = Factory;\n  exports.Container = Container;\n  exports.Registration = Registration;\n  exports.validateKey = validateKey;\n  exports.classInvokers = classInvokers;\n  exports.fallbackInvoker = fallbackInvoker;\n  exports.invokeWithDynamicDependencies = invokeWithDynamicDependencies;\n  exports.PLATFORM = PLATFORM;\n  exports.Reporter = Reporter;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.umd.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEva2VybmVsL2Rpc3QvaW5kZXgudW1kLmpzP2FkYTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsU0FDK0I7QUFDakMsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQyw4QkFBOEIsMEJBQTBCLEtBQUssR0FBRztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELGNBQWM7O0FBRTlELENBQUM7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9rZXJuZWwvZGlzdC9pbmRleC51bWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwua2VybmVsID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgY2FtZWxDYXNlTG9va3VwID0ge307XG4gIGNvbnN0IGtlYmFiQ2FzZUxvb2t1cCA9IHt9O1xuICBjb25zdCBQTEFURk9STSA9IHtcbiAgICAgIGdsb2JhbDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXb3JrZXJzIGRvbuKAmXQgaGF2ZSBgd2luZG93YCwgb25seSBgc2VsZmBcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L3RzbGludC1taWNyb3NvZnQtY29udHJpYi9pc3N1ZXMvNDE1XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXR5cGVvZi11bmRlZmluZWRcbiAgICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L3RzbGludC1taWNyb3NvZnQtY29udHJpYi9pc3N1ZXMvNDE1XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXR5cGVvZi11bmRlZmluZWRcbiAgICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90IGFsbCBlbnZpcm9ubWVudHMgYWxsb3cgZXZhbCBhbmQgRnVuY3Rpb25cbiAgICAgICAgICAvLyBVc2Ugb25seSBhcyBhIGxhc3QgcmVzb3J0OlxuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mdW5jdGlvbi1jb25zdHJ1Y3Rvci13aXRoLXN0cmluZy1hcmdzXG4gICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgICAgfSkoKSxcbiAgICAgIGVtcHR5QXJyYXk6IE9iamVjdC5mcmVlemUoW10pLFxuICAgICAgZW1wdHlPYmplY3Q6IE9iamVjdC5mcmVlemUoe30pLFxuICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5ICovXG4gICAgICBub29wKCkgeyB9LFxuICAgICAgbm93KCkge1xuICAgICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH0sXG4gICAgICBjYW1lbENhc2UoaW5wdXQpIHtcbiAgICAgICAgICAvLyBiZW5jaG1hcms6IGh0dHA6Ly9qc2Jlbi5jaC9xSXo0WlxuICAgICAgICAgIGxldCB2YWx1ZSA9IGNhbWVsQ2FzZUxvb2t1cFtpbnB1dF07XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgbGV0IHNlcCA9IGZhbHNlO1xuICAgICAgICAgIGxldCBjaGFyO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgY2hhciA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICctJyB8fCBjaGFyID09PSAnLicgfHwgY2hhciA9PT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgICBzZXAgPSB0cnVlOyAvLyBza2lwIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAoZmlyc3QgPyBjaGFyLnRvTG93ZXJDYXNlKCkgOiAoc2VwID8gY2hhci50b1VwcGVyQ2FzZSgpIDogY2hhcikpO1xuICAgICAgICAgICAgICAgICAgc2VwID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbWVsQ2FzZUxvb2t1cFtpbnB1dF0gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBrZWJhYkNhc2UoaW5wdXQpIHtcbiAgICAgICAgICAvLyBiZW5jaG1hcms6IGh0dHA6Ly9qc2Jlbi5jaC92N0s5VFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGtlYmFiQ2FzZUxvb2t1cFtpbnB1dF07XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgbGV0IGNoYXIsIGxvd2VyO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgY2hhciA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgbG93ZXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAoZmlyc3QgPyBsb3dlciA6IChjaGFyICE9PSBsb3dlciA/IGAtJHtsb3dlcn1gIDogbG93ZXIpKTtcbiAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtlYmFiQ2FzZUxvb2t1cFtpbnB1dF0gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICB0b0FycmF5KGlucHV0KSB7XG4gICAgICAgICAgLy8gYmVuY2htYXJrOiBodHRwOi8vanNiZW4uY2gveGpzeUZcbiAgICAgICAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgYXJyID0gQXJyYXkobGVuKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIGFycltpXSA9IGlucHV0W2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgfVxuICB9O1xuXG4gIGNvbnN0IFJlcG9ydGVyID0ge1xuICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5ICovXG4gICAgICB3cml0ZShjb2RlLCAuLi5wYXJhbXMpIHsgfSxcbiAgICAgIGVycm9yKGNvZGUsIC4uLnBhcmFtcykgeyByZXR1cm4gbmV3IEVycm9yKGBDb2RlICR7Y29kZX1gKTsgfVxuICB9O1xuXG4gIC8vIFNoaW1zIHRvIGF1Z21lbnQgdGhlIFJlZmxlY3Qgb2JqZWN0IHdpdGggbWV0aG9kcyB1c2VkIGZyb20gdGhlIFJlZmxlY3QgTWV0YWRhdGEgQVBJIHByb3Bvc2FsOlxuICAvLyBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9kZWNvcmF0b3JzLmh0bWwjbWV0YWRhdGFcbiAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS9cbiAgLy8gQXMgdGhlIG9mZmljaWFsIHNwZWMgcHJvcG9zYWwgdXNlcyBcImFueVwiLCB3ZSB1c2UgaXQgaGVyZSBhcyB3ZWxsIGFuZCBzdXBwcmVzcyByZWxhdGVkIHR5cGVkZWYgbGludGluZyB3YXJuaW5ncy5cbiAgaWYgKCEoJ2dldE93bk1ldGFkYXRhJyBpbiBSZWZsZWN0KSkge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgUmVmbGVjdC5nZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFttZXRhZGF0YUtleV07XG4gICAgICB9O1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgUmVmbGVjdC5tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHRhcmdldFttZXRhZGF0YUtleV0gPSBtZXRhZGF0YVZhbHVlO1xuICAgICAgICAgIH07XG4gICAgICB9O1xuICB9XG4gIGNvbnN0IERJID0ge1xuICAgICAgY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKCk7XG4gICAgICB9LFxuICAgICAgZ2V0RGVzaWduUGFyYW1UeXBlcyh0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCB0YXJnZXQpIHx8IFBMQVRGT1JNLmVtcHR5QXJyYXk7XG4gICAgICB9LFxuICAgICAgZ2V0RGVwZW5kZW5jaWVzKHR5cGUpIHtcbiAgICAgICAgICBsZXQgZGVwZW5kZW5jaWVzO1xuICAgICAgICAgIGlmICh0eXBlLmluamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IERJLmdldERlc2lnblBhcmFtVHlwZXModHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgICAgICAgbGV0IGN0b3IgPSB0eXBlO1xuICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIGN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdG9yLmhhc093blByb3BlcnR5KCdpbmplY3QnKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKC4uLmN0b3IuaW5qZWN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIH0sXG4gICAgICBjcmVhdGVJbnRlcmZhY2UoZnJpZW5kbHlOYW1lKSB7XG4gICAgICAgICAgY29uc3QgS2V5ID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIGluZGV4KSB7XG4gICAgICAgICAgICAgIEtleS5mcmllbmRseU5hbWUgPSBmcmllbmRseU5hbWUgfHwgJ0ludGVyZmFjZSc7XG4gICAgICAgICAgICAgICh0YXJnZXQuaW5qZWN0IHx8ICh0YXJnZXQuaW5qZWN0ID0gW10pKVtpbmRleF0gPSBLZXk7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBLZXkubm9EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gS2V5O1xuICAgICAgICAgIH07XG4gICAgICAgICAgS2V5LndpdGhEZWZhdWx0ID0gZnVuY3Rpb24gKGNvbmZpZ3VyZSkge1xuICAgICAgICAgICAgICBLZXkud2l0aERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBSZXBvcnRlci5lcnJvcigxNywgS2V5KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgS2V5LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwga2V5KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0cnVlS2V5ID0ga2V5IHx8IEtleTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcih0cnVlS2V5LCBuZXcgUmVzb2x2ZXIodHJ1ZUtleSwgMCAvKiBpbnN0YW5jZSAqLywgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZXRvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIodHJ1ZUtleSwgbmV3IFJlc29sdmVyKHRydWVLZXksIDEgLyogc2luZ2xldG9uICovLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpZW50KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcih0cnVlS2V5LCBuZXcgUmVzb2x2ZXIodHJ1ZUtleSwgMiAvKiB0cmFuc2llbnQgKi8sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIodHJ1ZUtleSwgbmV3IFJlc29sdmVyKHRydWVLZXksIDMgLyogY2FsbGJhY2sgKi8sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBhbGlhc1RvKGRlc3RpbmF0aW9uS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcih0cnVlS2V5LCBuZXcgUmVzb2x2ZXIodHJ1ZUtleSwgNSAvKiBhbGlhcyAqLywgZGVzdGluYXRpb25LZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBLZXk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gS2V5O1xuICAgICAgfSxcbiAgICAgIGluamVjdCguLi5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ251bWJlcicpIHsgLy8gSXQncyBhIHBhcmFtZXRlciBkZWNvcmF0b3IuXG4gICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eSgnaW5qZWN0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaW5qZWN0ID0gREkuZ2V0RGVzaWduUGFyYW1UeXBlcyh0YXJnZXQpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5pbmplY3RbZGVzY3JpcHRvcl0gPSBkZXBlbmRlbmNpZXNbMF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5KSB7IC8vIEl0J3MgYSBwcm9wZXJ0eSBkZWNvcmF0b3IuIE5vdCBzdXBwb3J0ZWQgYnkgdGhlIGNvbnRhaW5lciB3aXRob3V0IHBsdWdpbnMuXG4gICAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxUYXJnZXQgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgICAoYWN0dWFsVGFyZ2V0LmluamVjdCB8fCAoYWN0dWFsVGFyZ2V0LmluamVjdCA9IHt9KSlba2V5XSA9IGRlcGVuZGVuY2llc1swXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yKSB7IC8vIEl0J3MgYSBmdW5jdGlvbiBkZWNvcmF0b3IgKG5vdCBhIENsYXNzIGNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgZm4uaW5qZWN0ID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAvLyBJdCdzIGEgY2xhc3MgZGVjb3JhdG9yLlxuICAgICAgICAgICAgICAgICAgaWYgKCFkZXBlbmRlbmNpZXMgfHwgZGVwZW5kZW5jaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5pbmplY3QgPSBESS5nZXREZXNpZ25QYXJhbVR5cGVzKHRhcmdldCkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5pbmplY3QgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlOmpzZG9jLWZvcm1hdFxuICAgICAgLyoqXG4gICAgICAgKiBSZWdpc3RlcnMgdGhlIGB0YXJnZXRgIGNsYXNzIGFzIGEgdHJhbnNpZW50IGRlcGVuZGVuY3k7IGVhY2ggdGltZSB0aGUgZGVwZW5kZW5jeSBpcyByZXNvbHZlZFxuICAgICAgICogYSBuZXcgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIGNsYXNzIC8gY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgYXMgdHJhbnNpZW50LlxuICAgICAgICogQHJldHVybnMgVGhlIHNhbWUgY2xhc3MsIHdpdGggYSBzdGF0aWMgYHJlZ2lzdGVyYCBtZXRob2QgdGhhdCB0YWtlcyBhIGNvbnRhaW5lciBhbmQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgcmVzb2x2ZXIuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZSB1c2FnZTpcbiAgICBgYGB0c1xuICAgIC8vIE9uIGFuIGV4aXN0aW5nIGNsYXNzXG4gICAgY2xhc3MgRm9vIHsgfVxuICAgIERJLnRyYW5zaWVudChGb28pO1xuICAgIFxuICAgIC8vIElubGluZSBkZWNsYXJhdGlvblxuICAgIGNvbnN0IEZvbyA9IERJLnRyYW5zaWVudChjbGFzcyB7IH0pO1xuICAgIC8vIEZvbyBpcyBub3cgc3Ryb25nbHkgdHlwZWQgd2l0aCByZWdpc3RlclxuICAgIEZvby5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgIGBgYFxuICAgICAgICovXG4gICAgICAvLyB0c2xpbnQ6ZW5hYmxlOmpzZG9jLWZvcm1hdFxuICAgICAgdHJhbnNpZW50KHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldC5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICByZXR1cm4gUmVnaXN0cmF0aW9uLnRyYW5zaWVudCh0YXJnZXQsIHRhcmdldCkucmVnaXN0ZXIoY29udGFpbmVyLCB0YXJnZXQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0sXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpqc2RvYy1mb3JtYXRcbiAgICAgIC8qKlxuICAgICAgICogUmVnaXN0ZXJzIHRoZSBgdGFyZ2V0YCBjbGFzcyBhcyBhIHNpbmdsZXRvbiBkZXBlbmRlbmN5OyB0aGUgY2xhc3Mgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgb25jZS4gRWFjaFxuICAgICAgICogY29uc2VjdXRpdmUgdGltZSB0aGUgZGVwZW5kZW5jeSBpcyByZXNvbHZlZCwgdGhlIHNhbWUgaW5zdGFuY2Ugd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBjbGFzcyAvIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGFzIGEgc2luZ2xldG9uLlxuICAgICAgICogQHJldHVybnMgVGhlIHNhbWUgY2xhc3MsIHdpdGggYSBzdGF0aWMgYHJlZ2lzdGVyYCBtZXRob2QgdGhhdCB0YWtlcyBhIGNvbnRhaW5lciBhbmQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgcmVzb2x2ZXIuXG4gICAgICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgIGBgYHRzXG4gICAgLy8gT24gYW4gZXhpc3RpbmcgY2xhc3NcbiAgICBjbGFzcyBGb28geyB9XG4gICAgREkuc2luZ2xldG9uKEZvbyk7XG4gICAgXG4gICAgLy8gSW5saW5lIGRlY2xhcmF0aW9uXG4gICAgY29uc3QgRm9vID0gREkuc2luZ2xldG9uKGNsYXNzIHsgfSk7XG4gICAgLy8gRm9vIGlzIG5vdyBzdHJvbmdseSB0eXBlZCB3aXRoIHJlZ2lzdGVyXG4gICAgRm9vLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgYGBgXG4gICAgICAgKi9cbiAgICAgIC8vIHRzbGludDplbmFibGU6anNkb2MtZm9ybWF0XG4gICAgICBzaW5nbGV0b24odGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0LnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBSZWdpc3RyYXRpb24uc2luZ2xldG9uKHRhcmdldCwgdGFyZ2V0KS5yZWdpc3Rlcihjb250YWluZXIsIHRhcmdldCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICB9O1xuICBjb25zdCBJQ29udGFpbmVyID0gREkuY3JlYXRlSW50ZXJmYWNlKCkubm9EZWZhdWx0KCk7XG4gIGNvbnN0IElTZXJ2aWNlTG9jYXRvciA9IElDb250YWluZXI7XG4gIGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKGdldHRlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBjb25zdCBLZXkgPSBmdW5jdGlvbiBLZXkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICByZXR1cm4gREkuaW5qZWN0KEtleSkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBLZXkucmVzb2x2ZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcihrZXksIGhhbmRsZXIsIHJlcXVlc3Rvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gS2V5O1xuICAgICAgfTtcbiAgfVxuICBjb25zdCBpbmplY3QgPSBESS5pbmplY3Q7XG4gIGZ1bmN0aW9uIHRyYW5zaWVudERlY29yYXRvcih0YXJnZXQpIHtcbiAgICAgIHJldHVybiBESS50cmFuc2llbnQodGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2llbnQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0ID09PSB1bmRlZmluZWQgPyB0cmFuc2llbnREZWNvcmF0b3IgOiB0cmFuc2llbnREZWNvcmF0b3IodGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBzaW5nbGV0b25EZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gREkuc2luZ2xldG9uKHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gc2luZ2xldG9uKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldCA9PT0gdW5kZWZpbmVkID8gc2luZ2xldG9uRGVjb3JhdG9yIDogc2luZ2xldG9uRGVjb3JhdG9yKHRhcmdldCk7XG4gIH1cbiAgY29uc3QgYWxsID0gY3JlYXRlUmVzb2x2ZXIoKGtleSwgaGFuZGxlciwgcmVxdWVzdG9yKSA9PiByZXF1ZXN0b3IuZ2V0QWxsKGtleSkpO1xuICBjb25zdCBsYXp5ID0gY3JlYXRlUmVzb2x2ZXIoKGtleSwgaGFuZGxlciwgcmVxdWVzdG9yKSA9PiB7XG4gICAgICBsZXQgaW5zdGFuY2UgPSBudWxsOyAvLyBjYWNoZSBsb2NhbGx5IHNvIHRoYXQgbGF6eSBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBpbnN0YW5jZSBvbmNlIHJlc29sdmVkXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbnN0YW5jZSA9IHJlcXVlc3Rvci5nZXQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfTtcbiAgfSk7XG4gIGNvbnN0IG9wdGlvbmFsID0gY3JlYXRlUmVzb2x2ZXIoKGtleSwgaGFuZGxlciwgcmVxdWVzdG9yKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdG9yLmhhcyhrZXksIHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcXVlc3Rvci5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9KTtcbiAgLypAaW50ZXJuYWwqL1xuICBjbGFzcyBSZXNvbHZlciB7XG4gICAgICBjb25zdHJ1Y3RvcihrZXksIHN0cmF0ZWd5LCBzdGF0ZSkge1xuICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICB9XG4gICAgICByZWdpc3Rlcihjb250YWluZXIsIGtleSkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihrZXkgfHwgdGhpcy5rZXksIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgICAgY2FzZSAwIC8qIGluc3RhbmNlICovOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgIGNhc2UgMSAvKiBzaW5nbGV0b24gKi86XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gMCAvKiBpbnN0YW5jZSAqLztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gaGFuZGxlci5nZXRGYWN0b3J5KHRoaXMuc3RhdGUpLmNvbnN0cnVjdChoYW5kbGVyKTtcbiAgICAgICAgICAgICAgY2FzZSAyIC8qIHRyYW5zaWVudCAqLzpcbiAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBjcmVhdGUgdHJhbnNpZW50cyBmcm9tIHRoZSByZXF1ZXN0aW5nIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0RmFjdG9yeSh0aGlzLnN0YXRlKS5jb25zdHJ1Y3QocmVxdWVzdG9yKTtcbiAgICAgICAgICAgICAgY2FzZSAzIC8qIGNhbGxiYWNrICovOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUoaGFuZGxlciwgcmVxdWVzdG9yLCB0aGlzKTtcbiAgICAgICAgICAgICAgY2FzZSA0IC8qIGFycmF5ICovOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVbMF0ucmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpO1xuICAgICAgICAgICAgICBjYXNlIDUgLyogYWxpYXMgKi86XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5nZXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBSZXBvcnRlci5lcnJvcig2LCB0aGlzLnN0cmF0ZWd5KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRGYWN0b3J5KGNvbnRhaW5lcikge1xuICAgICAgICAgIHN3aXRjaCAodGhpcy5zdHJhdGVneSkge1xuICAgICAgICAgICAgICBjYXNlIDEgLyogc2luZ2xldG9uICovOlxuICAgICAgICAgICAgICBjYXNlIDIgLyogdHJhbnNpZW50ICovOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5nZXRGYWN0b3J5KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIC8qQGludGVybmFsKi9cbiAgY2xhc3MgRmFjdG9yeSB7XG4gICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBpbnZva2VyLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuaW52b2tlciA9IGludm9rZXI7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1lcnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGljIGNyZWF0ZSh0eXBlKSB7XG4gICAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gREkuZ2V0RGVwZW5kZW5jaWVzKHR5cGUpO1xuICAgICAgICAgIGNvbnN0IGludm9rZXIgPSBjbGFzc0ludm9rZXJzW2RlcGVuZGVuY2llcy5sZW5ndGhdIHx8IGZhbGxiYWNrSW52b2tlcjtcbiAgICAgICAgICByZXR1cm4gbmV3IEZhY3RvcnkodHlwZSwgaW52b2tlciwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0cnVjdChjb250YWluZXIsIGR5bmFtaWNEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lcnMgPSB0aGlzLnRyYW5zZm9ybWVycztcbiAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBkeW5hbWljRGVwZW5kZW5jaWVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyB0aGlzLmludm9rZXIuaW52b2tlV2l0aER5bmFtaWNEZXBlbmRlbmNpZXMoY29udGFpbmVyLCB0aGlzLnR5cGUsIHRoaXMuZGVwZW5kZW5jaWVzLCBkeW5hbWljRGVwZW5kZW5jaWVzKVxuICAgICAgICAgICAgICA6IHRoaXMuaW52b2tlci5pbnZva2UoY29udGFpbmVyLCB0aGlzLnR5cGUsIHRoaXMuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdHJhbnNmb3JtZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSB0cmFuc2Zvcm1lcnNbaV0oaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgICByZWdpc3RlclRyYW5zZm9ybWVyKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtZXJzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtZXIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG4gIGNvbnN0IGNvbnRhaW5lclJlc29sdmVyID0ge1xuICAgICAgcmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVxdWVzdG9yO1xuICAgICAgfVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ2lzdHJ5KG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmoucmVnaXN0ZXIgPT09ICdmdW5jdGlvbic7XG4gIH1cbiAgLypAaW50ZXJuYWwqL1xuICBjbGFzcyBDb250YWluZXIge1xuICAgICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVzb2x2ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBjb25maWd1cmF0aW9uLmZhY3RvcmllcyB8fCAoY29uZmlndXJhdGlvbi5mYWN0b3JpZXMgPSBuZXcgTWFwKCkpO1xuICAgICAgICAgIHRoaXMucmVzb2x2ZXJzLnNldChJQ29udGFpbmVyLCBjb250YWluZXJSZXNvbHZlcik7XG4gICAgICB9XG4gICAgICByZWdpc3RlciguLi5wYXJhbXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXJhbXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgICBpZiAoaXNSZWdpc3RyeShjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudC5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGtleXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudFtrZXlzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBjb3VsZCByZW1vdmUgdGhpcyBpZi1icmFuY2ggYW5kIGNhbGwgdGhpcy5yZWdpc3RlciBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlIGV4dHJhIGNoZWNrIGlzIGp1c3QgYSBwZXJmIHR3ZWFrIHRvIGNyZWF0ZSBmZXdlciB1bm5lY2Vzc2FyeSBhcnJheXMgYnkgdGhlIHNwcmVhZCBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlZ2lzdHJ5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVyUmVzb2x2ZXIoa2V5LCByZXNvbHZlcikge1xuICAgICAgICAgIHZhbGlkYXRlS2V5KGtleSk7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZXJzID0gdGhpcy5yZXNvbHZlcnM7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZXJzLmdldChrZXkpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXNvbHZlcnMuc2V0KGtleSwgcmVzb2x2ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZXNvbHZlciAmJiByZXN1bHQuc3RyYXRlZ3kgPT09IDQgLyogYXJyYXkgKi8pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnN0YXRlLnB1c2gocmVzb2x2ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZXJzLnNldChrZXksIG5ldyBSZXNvbHZlcihrZXksIDQgLyogYXJyYXkgKi8sIFtyZXN1bHQsIHJlc29sdmVyXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICB9XG4gICAgICByZWdpc3RlclRyYW5zZm9ybWVyKGtleSwgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlciA9IHRoaXMuZ2V0UmVzb2x2ZXIoa2V5KTtcbiAgICAgICAgICBpZiAocmVzb2x2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzb2x2ZXIuZ2V0RmFjdG9yeSkge1xuICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gcmVzb2x2ZXIuZ2V0RmFjdG9yeSh0aGlzKTtcbiAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5yZWdpc3RlclRyYW5zZm9ybWVyKHRyYW5zZm9ybWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZ2V0UmVzb2x2ZXIoa2V5LCBhdXRvUmVnaXN0ZXIgPSB0cnVlKSB7XG4gICAgICAgICAgdmFsaWRhdGVLZXkoa2V5KTtcbiAgICAgICAgICBpZiAoa2V5LnJlc29sdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gY3VycmVudC5yZXNvbHZlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgIGlmIChyZXNvbHZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b1JlZ2lzdGVyID8gdGhpcy5qaXRSZWdpc3RlcihrZXksIGN1cnJlbnQpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGhhcyhrZXksIHNlYXJjaEFuY2VzdG9ycyA9IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJzLmhhcyhrZXkpXG4gICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICA6IHNlYXJjaEFuY2VzdG9ycyAmJiB0aGlzLnBhcmVudCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgPyB0aGlzLnBhcmVudC5oYXMoa2V5LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUtleShrZXkpO1xuICAgICAgICAgIGlmIChrZXkucmVzb2x2ZSkge1xuICAgICAgICAgICAgICByZXR1cm4ga2V5LnJlc29sdmUodGhpcywgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGN1cnJlbnQucmVzb2x2ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaml0UmVnaXN0ZXIoa2V5LCBjdXJyZW50KS5yZXNvbHZlKGN1cnJlbnQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUoY3VycmVudCwgdGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRBbGwoa2V5KSB7XG4gICAgICAgICAgdmFsaWRhdGVLZXkoa2V5KTtcbiAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjdXJyZW50LnJlc29sdmVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgaWYgKHJlc29sdmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQTEFURk9STS5lbXB0eUFycmF5O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQWxsUmVzcG9uc2UocmVzb2x2ZXIsIGN1cnJlbnQsIHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQTEFURk9STS5lbXB0eUFycmF5O1xuICAgICAgfVxuICAgICAgZ2V0RmFjdG9yeSh0eXBlKSB7XG4gICAgICAgICAgbGV0IGZhY3RvcnkgPSB0aGlzLmZhY3Rvcmllcy5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKGZhY3RvcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmYWN0b3J5ID0gRmFjdG9yeS5jcmVhdGUodHlwZSk7XG4gICAgICAgICAgICAgIHRoaXMuZmFjdG9yaWVzLnNldCh0eXBlLCBmYWN0b3J5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICB9XG4gICAgICBjcmVhdGVDaGlsZCgpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBDb250YWluZXIodGhpcy5jb25maWd1cmF0aW9uKTtcbiAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICAgIGppdFJlZ2lzdGVyKGtleUFzVmFsdWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoa2V5QXNWYWx1ZS5yZWdpc3Rlcikge1xuICAgICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb25SZXNvbHZlciA9IGtleUFzVmFsdWUucmVnaXN0ZXIoaGFuZGxlciwga2V5QXNWYWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghKHJlZ2lzdHJhdGlvblJlc29sdmVyICYmIHJlZ2lzdHJhdGlvblJlc29sdmVyLnJlc29sdmUpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBSZXBvcnRlci5lcnJvcig0MCk7IC8vIGRpZCBub3QgcmV0dXJuIGEgdmFsaWQgcmVzb2x2ZXIgZnJvbSB0aGUgc3RhdGljIHJlZ2lzdGVyIG1ldGhvZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZWdpc3RyYXRpb25SZXNvbHZlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIoa2V5QXNWYWx1ZSwgMSAvKiBzaW5nbGV0b24gKi8sIGtleUFzVmFsdWUpO1xuICAgICAgICAgIGhhbmRsZXIucmVzb2x2ZXJzLnNldChrZXlBc1ZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgfVxuICB9XG4gIGNvbnN0IFJlZ2lzdHJhdGlvbiA9IHtcbiAgICAgIGluc3RhbmNlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVyKGtleSwgMCAvKiBpbnN0YW5jZSAqLywgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHNpbmdsZXRvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlcihrZXksIDEgLyogc2luZ2xldG9uICovLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNpZW50KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVyKGtleSwgMiAvKiB0cmFuc2llbnQgKi8sIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFjayhrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlcihrZXksIDMgLyogY2FsbGJhY2sgKi8sIGNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICBhbGlhcyhvcmlnaW5hbEtleSwgYWxpYXNLZXkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVyKGFsaWFzS2V5LCA1IC8qIGFsaWFzICovLCBvcmlnaW5hbEtleSk7XG4gICAgICB9LFxuICAgICAgaW50ZXJwcmV0KGludGVycHJldGVyS2V5LCAuLi5yZXN0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGNvbnRhaW5lci5nZXRSZXNvbHZlcihpbnRlcnByZXRlcktleSk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVnaXN0cnkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5nZXRGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSByZXNvbHZlci5nZXRGYWN0b3J5KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWN0b3J5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RyeSA9IGZhY3RvcnkuY29uc3RydWN0KGNvbnRhaW5lciwgcmVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdHJ5ID0gcmVzb2x2ZXIucmVzb2x2ZShjb250YWluZXIsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RyeS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICB9XG4gIH07XG4gIC8qQGludGVybmFsKi9cbiAgZnVuY3Rpb24gdmFsaWRhdGVLZXkoa2V5KSB7XG4gICAgICAvLyBub3RlOiBkZXNpZ246cGFyYW1UeXBlcyB3aGljaCB3aWxsIGRlZmF1bHQgdG8gT2JqZWN0IGlmIHRoZSBwYXJhbSB0eXBlcyBjYW5ub3QgYmUgc3RhdGljYWxseSBhbmFseXplZCBieSB0c2NcbiAgICAgIC8vIHRoaXMgY2hlY2sgaXMgaW50ZW5kZWQgdG8gcHJvcGVybHkgcmVwb3J0IG9uIHRoYXQgcHJvYmxlbSAtIHVuZGVyIG5vIGNpcmN1bXN0YW5jZSBzaG91bGQgT2JqZWN0IGJlIGEgdmFsaWQga2V5IGFueXdheVxuICAgICAgaWYgKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IE9iamVjdCkge1xuICAgICAgICAgIHRocm93IFJlcG9ydGVyLmVycm9yKDUpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkQWxsUmVzcG9uc2UocmVzb2x2ZXIsIGhhbmRsZXIsIHJlcXVlc3Rvcikge1xuICAgICAgaWYgKHJlc29sdmVyIGluc3RhbmNlb2YgUmVzb2x2ZXIgJiYgcmVzb2x2ZXIuc3RyYXRlZ3kgPT09IDQgLyogYXJyYXkgKi8pIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHJlc29sdmVyLnN0YXRlO1xuICAgICAgICAgIGxldCBpID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICByZXN1bHRzW2ldID0gc3RhdGVbaV0uZ2V0KGhhbmRsZXIsIHJlcXVlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyZXNvbHZlci5yZXNvbHZlKGhhbmRsZXIsIHJlcXVlc3RvcildO1xuICB9XG4gIC8qQGludGVybmFsKi9cbiAgY29uc3QgY2xhc3NJbnZva2VycyA9IFtcbiAgICAgIHtcbiAgICAgICAgICBpbnZva2UoY29udGFpbmVyLCBUeXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW52b2tlV2l0aER5bmFtaWNEZXBlbmRlbmNpZXNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICAgaW52b2tlKGNvbnRhaW5lciwgVHlwZSwgZGVwcykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFR5cGUoY29udGFpbmVyLmdldChkZXBzWzBdKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnZva2VXaXRoRHluYW1pY0RlcGVuZGVuY2llc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgICBpbnZva2UoY29udGFpbmVyLCBUeXBlLCBkZXBzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZShjb250YWluZXIuZ2V0KGRlcHNbMF0pLCBjb250YWluZXIuZ2V0KGRlcHNbMV0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludm9rZVdpdGhEeW5hbWljRGVwZW5kZW5jaWVzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAgIGludm9rZShjb250YWluZXIsIFR5cGUsIGRlcHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlKGNvbnRhaW5lci5nZXQoZGVwc1swXSksIGNvbnRhaW5lci5nZXQoZGVwc1sxXSksIGNvbnRhaW5lci5nZXQoZGVwc1syXSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW52b2tlV2l0aER5bmFtaWNEZXBlbmRlbmNpZXNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICAgaW52b2tlKGNvbnRhaW5lciwgVHlwZSwgZGVwcykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFR5cGUoY29udGFpbmVyLmdldChkZXBzWzBdKSwgY29udGFpbmVyLmdldChkZXBzWzFdKSwgY29udGFpbmVyLmdldChkZXBzWzJdKSwgY29udGFpbmVyLmdldChkZXBzWzNdKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnZva2VXaXRoRHluYW1pY0RlcGVuZGVuY2llc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgICBpbnZva2UoY29udGFpbmVyLCBUeXBlLCBkZXBzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZShjb250YWluZXIuZ2V0KGRlcHNbMF0pLCBjb250YWluZXIuZ2V0KGRlcHNbMV0pLCBjb250YWluZXIuZ2V0KGRlcHNbMl0pLCBjb250YWluZXIuZ2V0KGRlcHNbM10pLCBjb250YWluZXIuZ2V0KGRlcHNbNF0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludm9rZVdpdGhEeW5hbWljRGVwZW5kZW5jaWVzXG4gICAgICB9XG4gIF07XG4gIC8qQGludGVybmFsKi9cbiAgY29uc3QgZmFsbGJhY2tJbnZva2VyID0ge1xuICAgICAgaW52b2tlOiBpbnZva2VXaXRoRHluYW1pY0RlcGVuZGVuY2llcyxcbiAgICAgIGludm9rZVdpdGhEeW5hbWljRGVwZW5kZW5jaWVzXG4gIH07XG4gIC8qQGludGVybmFsKi9cbiAgZnVuY3Rpb24gaW52b2tlV2l0aER5bmFtaWNEZXBlbmRlbmNpZXMoY29udGFpbmVyLCBUeXBlLCBzdGF0aWNEZXBlbmRlbmNpZXMsIGR5bmFtaWNEZXBlbmRlbmNpZXMpIHtcbiAgICAgIGxldCBpID0gc3RhdGljRGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICAgIGxldCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgbGV0IGxvb2t1cDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBsb29rdXAgPSBzdGF0aWNEZXBlbmRlbmNpZXNbaV07XG4gICAgICAgICAgaWYgKGxvb2t1cCA9PT0gbnVsbCB8fCBsb29rdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBSZXBvcnRlci5lcnJvcig3LCBgSW5kZXggJHtpfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFyZ3NbaV0gPSBjb250YWluZXIuZ2V0KGxvb2t1cCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGR5bmFtaWNEZXBlbmRlbmNpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChkeW5hbWljRGVwZW5kZW5jaWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChUeXBlLCBhcmdzKTtcbiAgfVxuXG4gIGV4cG9ydHMuREkgPSBESTtcbiAgZXhwb3J0cy5JQ29udGFpbmVyID0gSUNvbnRhaW5lcjtcbiAgZXhwb3J0cy5JU2VydmljZUxvY2F0b3IgPSBJU2VydmljZUxvY2F0b3I7XG4gIGV4cG9ydHMuaW5qZWN0ID0gaW5qZWN0O1xuICBleHBvcnRzLnRyYW5zaWVudCA9IHRyYW5zaWVudDtcbiAgZXhwb3J0cy5zaW5nbGV0b24gPSBzaW5nbGV0b247XG4gIGV4cG9ydHMuYWxsID0gYWxsO1xuICBleHBvcnRzLmxhenkgPSBsYXp5O1xuICBleHBvcnRzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gIGV4cG9ydHMuUmVzb2x2ZXIgPSBSZXNvbHZlcjtcbiAgZXhwb3J0cy5GYWN0b3J5ID0gRmFjdG9yeTtcbiAgZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXI7XG4gIGV4cG9ydHMuUmVnaXN0cmF0aW9uID0gUmVnaXN0cmF0aW9uO1xuICBleHBvcnRzLnZhbGlkYXRlS2V5ID0gdmFsaWRhdGVLZXk7XG4gIGV4cG9ydHMuY2xhc3NJbnZva2VycyA9IGNsYXNzSW52b2tlcnM7XG4gIGV4cG9ydHMuZmFsbGJhY2tJbnZva2VyID0gZmFsbGJhY2tJbnZva2VyO1xuICBleHBvcnRzLmludm9rZVdpdGhEeW5hbWljRGVwZW5kZW5jaWVzID0gaW52b2tlV2l0aER5bmFtaWNEZXBlbmRlbmNpZXM7XG4gIGV4cG9ydHMuUExBVEZPUk0gPSBQTEFURk9STTtcbiAgZXhwb3J0cy5SZXBvcnRlciA9IFJlcG9ydGVyO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC51bWQuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@aurelia/kernel/dist/index.umd.js\n");

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/index.umd.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/index.umd.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! @aurelia/kernel */ \"./node_modules/@aurelia/kernel/dist/index.umd.js\")) :\n    undefined;\n}(this, (function (exports,kernel) { 'use strict';\n\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation. All rights reserved.\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n    this file except in compliance with the License. You may obtain a copy of the\n    License at http://www.apache.org/licenses/LICENSE-2.0\n\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n    MERCHANTABLITY OR NON-INFRINGEMENT.\n\n    See the Apache Version 2.0 License for specific language governing permissions\n    and limitations under the License.\n    ***************************************************************************** */\n\n    function __decorate(decorators, target, key, desc) {\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\n    }\n\n    (function (LifecycleFlags) {\n        LifecycleFlags[LifecycleFlags[\"none\"] = 0] = \"none\";\n        LifecycleFlags[LifecycleFlags[\"mustEvaluate\"] = 524288] = \"mustEvaluate\";\n        LifecycleFlags[LifecycleFlags[\"mutation\"] = 3] = \"mutation\";\n        LifecycleFlags[LifecycleFlags[\"isCollectionMutation\"] = 1] = \"isCollectionMutation\";\n        LifecycleFlags[LifecycleFlags[\"isInstanceMutation\"] = 2] = \"isInstanceMutation\";\n        LifecycleFlags[LifecycleFlags[\"update\"] = 28] = \"update\";\n        LifecycleFlags[LifecycleFlags[\"updateTargetObserver\"] = 4] = \"updateTargetObserver\";\n        LifecycleFlags[LifecycleFlags[\"updateTargetInstance\"] = 8] = \"updateTargetInstance\";\n        LifecycleFlags[LifecycleFlags[\"updateSourceExpression\"] = 16] = \"updateSourceExpression\";\n        LifecycleFlags[LifecycleFlags[\"from\"] = 524256] = \"from\";\n        LifecycleFlags[LifecycleFlags[\"fromFlush\"] = 96] = \"fromFlush\";\n        LifecycleFlags[LifecycleFlags[\"fromAsyncFlush\"] = 32] = \"fromAsyncFlush\";\n        LifecycleFlags[LifecycleFlags[\"fromSyncFlush\"] = 64] = \"fromSyncFlush\";\n        LifecycleFlags[LifecycleFlags[\"fromStartTask\"] = 128] = \"fromStartTask\";\n        LifecycleFlags[LifecycleFlags[\"fromStopTask\"] = 256] = \"fromStopTask\";\n        LifecycleFlags[LifecycleFlags[\"fromBind\"] = 512] = \"fromBind\";\n        LifecycleFlags[LifecycleFlags[\"fromUnbind\"] = 1024] = \"fromUnbind\";\n        LifecycleFlags[LifecycleFlags[\"fromAttach\"] = 2048] = \"fromAttach\";\n        LifecycleFlags[LifecycleFlags[\"fromDetach\"] = 4096] = \"fromDetach\";\n        LifecycleFlags[LifecycleFlags[\"fromCache\"] = 8192] = \"fromCache\";\n        LifecycleFlags[LifecycleFlags[\"fromCreate\"] = 16384] = \"fromCreate\";\n        LifecycleFlags[LifecycleFlags[\"fromDOMEvent\"] = 32768] = \"fromDOMEvent\";\n        LifecycleFlags[LifecycleFlags[\"fromObserverSetter\"] = 65536] = \"fromObserverSetter\";\n        LifecycleFlags[LifecycleFlags[\"fromBindableHandler\"] = 131072] = \"fromBindableHandler\";\n        LifecycleFlags[LifecycleFlags[\"fromLifecycleTask\"] = 262144] = \"fromLifecycleTask\";\n        LifecycleFlags[LifecycleFlags[\"parentUnmountQueued\"] = 1048576] = \"parentUnmountQueued\";\n        // this flag is for the synchronous flush before detach (no point in updating the\n        // DOM if it's about to be detached)\n        LifecycleFlags[LifecycleFlags[\"doNotUpdateDOM\"] = 2097152] = \"doNotUpdateDOM\";\n    })(exports.LifecycleFlags || (exports.LifecycleFlags = {}));\n    (function (MutationKind) {\n        MutationKind[MutationKind[\"instance\"] = 1] = \"instance\";\n        MutationKind[MutationKind[\"collection\"] = 2] = \"collection\";\n    })(exports.MutationKind || (exports.MutationKind = {}));\n\n    const IRenderable = kernel.DI.createInterface().noDefault();\n    const IViewFactory = kernel.DI.createInterface().noDefault();\n    const marker = Object.freeze(Object.create(null));\n    const ILifecycle = kernel.DI.createInterface().withDefault(x => x.singleton(Lifecycle));\n    const IFlushLifecycle = ILifecycle;\n    const IBindLifecycle = ILifecycle;\n    const IAttachLifecycle = ILifecycle;\n    /*@internal*/\n    class Lifecycle {\n        constructor() {\n            /*@internal*/ this.bindDepth = 0;\n            /*@internal*/ this.attachDepth = 0;\n            /*@internal*/ this.detachDepth = 0;\n            /*@internal*/ this.unbindDepth = 0;\n            /*@internal*/ this.flushHead = this;\n            /*@internal*/ this.flushTail = this;\n            /*@internal*/ this.connectHead = this; // this cast is safe because we know exactly which properties we'll use\n            /*@internal*/ this.connectTail = this;\n            /*@internal*/ this.patchHead = this;\n            /*@internal*/ this.patchTail = this;\n            /*@internal*/ this.boundHead = this;\n            /*@internal*/ this.boundTail = this;\n            /*@internal*/ this.mountHead = this;\n            /*@internal*/ this.mountTail = this;\n            /*@internal*/ this.attachedHead = this;\n            /*@internal*/ this.attachedTail = this;\n            /*@internal*/ this.unmountHead = this;\n            /*@internal*/ this.unmountTail = this;\n            /*@internal*/ this.detachedHead = this; //LOL\n            /*@internal*/ this.detachedTail = this;\n            /*@internal*/ this.unbindAfterDetachHead = this;\n            /*@internal*/ this.unbindAfterDetachTail = this;\n            /*@internal*/ this.unboundHead = this;\n            /*@internal*/ this.unboundTail = this;\n            /*@internal*/ this.flushed = null;\n            /*@internal*/ this.promise = Promise.resolve();\n            /*@internal*/ this.flushCount = 0;\n            /*@internal*/ this.connectCount = 0;\n            /*@internal*/ this.patchCount = 0;\n            /*@internal*/ this.boundCount = 0;\n            /*@internal*/ this.mountCount = 0;\n            /*@internal*/ this.attachedCount = 0;\n            /*@internal*/ this.unmountCount = 0;\n            /*@internal*/ this.detachedCount = 0;\n            /*@internal*/ this.unbindAfterDetachCount = 0;\n            /*@internal*/ this.unboundCount = 0;\n            // These are dummy properties to make the lifecycle conform to the interfaces\n            // of the components it manages. This allows the lifecycle itself to be the first link\n            // in the chain and removes the need for an additional null check on each addition.\n            /*@internal*/ this.$nextFlush = marker;\n            /*@internal*/ this.flush = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextConnect = marker;\n            /*@internal*/ this.connect = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextPatch = marker;\n            /*@internal*/ this.patch = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextBound = marker;\n            /*@internal*/ this.bound = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextMount = marker;\n            /*@internal*/ this.$mount = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextAttached = marker;\n            /*@internal*/ this.attached = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextUnmount = marker;\n            /*@internal*/ this.$unmount = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextDetached = marker;\n            /*@internal*/ this.detached = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextUnbindAfterDetach = marker;\n            /*@internal*/ this.$unbind = kernel.PLATFORM.noop;\n            /*@internal*/ this.$nextUnbound = marker;\n            /*@internal*/ this.unbound = kernel.PLATFORM.noop;\n            /*@internal*/ this.task = null;\n        }\n        registerTask(task) {\n            if (this.task === null) {\n                this.task = new AggregateLifecycleTask();\n            }\n            this.task.addTask(task);\n        }\n        finishTask(task) {\n            if (this.task !== null) {\n                if (this.task === task) {\n                    this.task = null;\n                }\n                else {\n                    this.task.removeTask(task);\n                }\n            }\n        }\n        enqueueFlush(requestor) {\n            // Queue a flush() callback; the depth is just for debugging / testing purposes and has\n            // no effect on execution. flush() will automatically be invoked when the promise resolves,\n            // or it can be manually invoked synchronously.\n            if (this.flushHead === this) {\n                this.flushed = this.promise.then(() => this.processFlushQueue(exports.LifecycleFlags.fromAsyncFlush));\n            }\n            if (requestor.$nextFlush === null) {\n                requestor.$nextFlush = marker;\n                this.flushTail.$nextFlush = requestor;\n                this.flushTail = requestor;\n                ++this.flushCount;\n            }\n            return this.flushed;\n        }\n        processFlushQueue(flags) {\n            flags |= exports.LifecycleFlags.fromSyncFlush;\n            // flush callbacks may lead to additional flush operations, so keep looping until\n            // the flush head is back to `this` (though this will typically happen in the first iteration)\n            while (this.flushCount > 0) {\n                let current = this.flushHead.$nextFlush;\n                this.flushHead = this.flushTail = this;\n                this.flushCount = 0;\n                let next;\n                do {\n                    next = current.$nextFlush;\n                    current.$nextFlush = null;\n                    current.flush(flags);\n                    current = next;\n                } while (current !== marker);\n            }\n        }\n        beginBind() {\n            ++this.bindDepth;\n        }\n        enqueueBound(requestor) {\n            // build a standard singly linked list for bound callbacks\n            if (requestor.$nextBound === null) {\n                requestor.$nextBound = marker;\n                this.boundTail.$nextBound = requestor;\n                this.boundTail = requestor;\n                ++this.boundCount;\n            }\n        }\n        enqueueConnect(requestor) {\n            // enqueue connect and patch calls in separate lists so that they can be invoked\n            // independently from eachother\n            // TODO: see if we can eliminate/optimize some of this, because this is a relatively hot path\n            // (first get all the necessary integration tests working, then look for optimizations)\n            // build a standard singly linked list for connect callbacks\n            if (requestor.$nextConnect === null) {\n                requestor.$nextConnect = marker;\n                this.connectTail.$nextConnect = requestor;\n                this.connectTail = requestor;\n                ++this.connectCount;\n            }\n            // build a standard singly linked list for patch callbacks\n            if (requestor.$nextPatch === null) {\n                requestor.$nextPatch = marker;\n                this.patchTail.$nextPatch = requestor;\n                this.patchTail = requestor;\n                ++this.patchCount;\n            }\n        }\n        processConnectQueue(flags) {\n            // connects cannot lead to additional connects, so we don't need to loop here\n            if (this.connectCount > 0) {\n                this.connectCount = 0;\n                let current = this.connectHead.$nextConnect;\n                this.connectHead = this.connectTail = this;\n                let next;\n                do {\n                    current.connect(flags);\n                    next = current.$nextConnect;\n                    current.$nextConnect = null;\n                    current = next;\n                } while (current !== marker);\n            }\n        }\n        processPatchQueue(flags) {\n            // flush before patching, but only if this is the initial bind;\n            // no DOM is attached yet so we can safely let everything propagate\n            if (flags & exports.LifecycleFlags.fromStartTask) {\n                this.processFlushQueue(flags | exports.LifecycleFlags.fromSyncFlush);\n            }\n            // patch callbacks may lead to additional bind operations, so keep looping until\n            // the patch head is back to `this` (though this will typically happen in the first iteration)\n            while (this.patchCount > 0) {\n                this.patchCount = 0;\n                let current = this.patchHead.$nextPatch;\n                this.patchHead = this.patchTail = this;\n                let next;\n                do {\n                    current.patch(flags);\n                    next = current.$nextPatch;\n                    current.$nextPatch = null;\n                    current = next;\n                } while (current !== marker);\n            }\n        }\n        endBind(flags) {\n            // close / shrink a bind batch\n            if (--this.bindDepth === 0) {\n                if (this.task !== null && !this.task.done) {\n                    this.task.owner = this;\n                    return this.task;\n                }\n                this.processBindQueue(flags);\n                return LifecycleTask.done;\n            }\n        }\n        processBindQueue(flags) {\n            // flush before processing bound callbacks, but only if this is the initial bind;\n            // no DOM is attached yet so we can safely let everything propagate\n            if (flags & exports.LifecycleFlags.fromStartTask) {\n                this.processFlushQueue(flags | exports.LifecycleFlags.fromSyncFlush);\n            }\n            // bound callbacks may lead to additional bind operations, so keep looping until\n            // the bound head is back to `this` (though this will typically happen in the first iteration)\n            while (this.boundCount > 0) {\n                this.boundCount = 0;\n                let current = this.boundHead.$nextBound;\n                let next;\n                this.boundHead = this.boundTail = this;\n                do {\n                    current.bound(flags);\n                    next = current.$nextBound;\n                    current.$nextBound = null;\n                    current = next;\n                } while (current !== marker);\n            }\n        }\n        beginUnbind() {\n            // open up / expand an unbind batch; the very first caller will close it again with endUnbind\n            ++this.unbindDepth;\n        }\n        enqueueUnbound(requestor) {\n            // This method is idempotent; adding the same item more than once has the same effect as\n            // adding it once.\n            // build a standard singly linked list for unbound callbacks\n            if (requestor.$nextUnbound === null) {\n                requestor.$nextUnbound = marker;\n                this.unboundTail.$nextUnbound = requestor;\n                this.unboundTail = requestor;\n                ++this.unboundCount;\n            }\n        }\n        endUnbind(flags) {\n            // close / shrink an unbind batch\n            if (--this.unbindDepth === 0) {\n                if (this.task !== null && !this.task.done) {\n                    this.task.owner = this;\n                    return this.task;\n                }\n                this.processUnbindQueue(flags);\n                return LifecycleTask.done;\n            }\n        }\n        processUnbindQueue(flags) {\n            // unbound callbacks may lead to additional unbind operations, so keep looping until\n            // the unbound head is back to `this` (though this will typically happen in the first iteration)\n            while (this.unboundCount > 0) {\n                this.unboundCount = 0;\n                let current = this.unboundHead.$nextUnbound;\n                let next;\n                this.unboundHead = this.unboundTail = this;\n                do {\n                    current.unbound(flags);\n                    next = current.$nextUnbound;\n                    current.$nextUnbound = null;\n                    current = next;\n                } while (current !== marker);\n            }\n        }\n        beginAttach() {\n            // open up / expand an attach batch; the very first caller will close it again with endAttach\n            ++this.attachDepth;\n        }\n        enqueueMount(requestor) {\n            // This method is idempotent; adding the same item more than once has the same effect as\n            // adding it once.\n            // build a standard singly linked list for mount callbacks\n            if (requestor.$nextMount === null) {\n                requestor.$nextMount = marker;\n                this.mountTail.$nextMount = requestor;\n                this.mountTail = requestor;\n                ++this.mountCount;\n            }\n        }\n        enqueueAttached(requestor) {\n            // This method is idempotent; adding the same item more than once has the same effect as\n            // adding it once.\n            // build a standard singly linked list for attached callbacks\n            if (requestor.$nextAttached === null) {\n                requestor.$nextAttached = marker;\n                this.attachedTail.$nextAttached = requestor;\n                this.attachedTail = requestor;\n                ++this.attachedCount;\n            }\n        }\n        endAttach(flags) {\n            // close / shrink an attach batch\n            if (--this.attachDepth === 0) {\n                if (this.task !== null && !this.task.done) {\n                    this.task.owner = this;\n                    return this.task;\n                }\n                this.processAttachQueue(flags);\n                return LifecycleTask.done;\n            }\n        }\n        processAttachQueue(flags) {\n            // flush and patch before starting the attach lifecycle to ensure batched collection changes are propagated to repeaters\n            // and the DOM is updated\n            this.processFlushQueue(flags | exports.LifecycleFlags.fromSyncFlush);\n            // TODO: prevent duplicate updates coming from the patch queue (or perhaps it's just not needed in its entirety?)\n            //this.processPatchQueue(flags | LifecycleFlags.fromSyncFlush);\n            if (this.mountCount > 0) {\n                this.mountCount = 0;\n                let currentMount = this.mountHead.$nextMount;\n                this.mountHead = this.mountTail = this;\n                let nextMount;\n                do {\n                    currentMount.$mount(flags);\n                    nextMount = currentMount.$nextMount;\n                    currentMount.$nextMount = null;\n                    currentMount = nextMount;\n                } while (currentMount !== marker);\n            }\n            // Connect all connect-queued bindings AFTER mounting is done, so that the DOM is visible asap,\n            // but connect BEFORE running the attached callbacks to ensure any changes made during those callbacks\n            // are still accounted for.\n            // TODO: add a flag/option to further delay connect with a RAF callback (the tradeoff would be that we'd need\n            // to run an additional patch cycle before that connect, which can be expensive and unnecessary in most real\n            // world scenarios, but can significantly speed things up with nested, highly volatile data like in dbmonster)\n            this.processConnectQueue(exports.LifecycleFlags.mustEvaluate);\n            if (this.attachedCount > 0) {\n                this.attachedCount = 0;\n                let currentAttached = this.attachedHead.$nextAttached;\n                this.attachedHead = this.attachedTail = this;\n                let nextAttached;\n                do {\n                    currentAttached.attached(flags);\n                    nextAttached = currentAttached.$nextAttached;\n                    currentAttached.$nextAttached = null;\n                    currentAttached = nextAttached;\n                } while (currentAttached !== marker);\n            }\n        }\n        beginDetach() {\n            // open up / expand a detach batch; the very first caller will close it again with endDetach\n            ++this.detachDepth;\n        }\n        enqueueUnmount(requestor) {\n            // This method is idempotent; adding the same item more than once has the same effect as\n            // adding it once.\n            // build a standard singly linked list for unmount callbacks\n            if (requestor.$nextUnmount === null) {\n                requestor.$nextUnmount = marker;\n                this.unmountTail.$nextUnmount = requestor;\n                this.unmountTail = requestor;\n                ++this.unmountCount;\n            }\n        }\n        enqueueDetached(requestor) {\n            // This method is idempotent; adding the same item more than once has the same effect as\n            // adding it once.\n            // build a standard singly linked list for detached callbacks\n            if (requestor.$nextDetached === null) {\n                requestor.$nextDetached = marker;\n                this.detachedTail.$nextDetached = requestor;\n                this.detachedTail = requestor;\n                ++this.detachedCount;\n            }\n        }\n        enqueueUnbindAfterDetach(requestor) {\n            // This method is idempotent; adding the same item more than once has the same effect as\n            // adding it once.\n            // build a standard singly linked list for unbindAfterDetach callbacks\n            if (requestor.$nextUnbindAfterDetach === null) {\n                requestor.$nextUnbindAfterDetach = marker;\n                this.unbindAfterDetachTail.$nextUnbindAfterDetach = requestor;\n                this.unbindAfterDetachTail = requestor;\n                ++this.unbindAfterDetachCount;\n            }\n        }\n        endDetach(flags) {\n            // close / shrink a detach batch\n            if (--this.detachDepth === 0) {\n                if (this.task !== null && !this.task.done) {\n                    this.task.owner = this;\n                    return this.task;\n                }\n                this.processDetachQueue(flags);\n                return LifecycleTask.done;\n            }\n        }\n        processDetachQueue(flags) {\n            // flush before unmounting to ensure batched collection changes propagate to the repeaters,\n            // which may lead to additional unmount operations\n            this.processFlushQueue(flags | exports.LifecycleFlags.fromFlush | exports.LifecycleFlags.doNotUpdateDOM);\n            if (this.unmountCount > 0) {\n                this.unmountCount = 0;\n                let currentUnmount = this.unmountHead.$nextUnmount;\n                this.unmountHead = this.unmountTail = this;\n                let nextUnmount;\n                do {\n                    currentUnmount.$unmount(flags);\n                    nextUnmount = currentUnmount.$nextUnmount;\n                    currentUnmount.$nextUnmount = null;\n                    currentUnmount = nextUnmount;\n                } while (currentUnmount !== marker);\n            }\n            if (this.detachedCount > 0) {\n                this.detachedCount = 0;\n                let currentDetached = this.detachedHead.$nextDetached;\n                this.detachedHead = this.detachedTail = this;\n                let nextDetached;\n                do {\n                    currentDetached.detached(flags);\n                    nextDetached = currentDetached.$nextDetached;\n                    currentDetached.$nextDetached = null;\n                    currentDetached = nextDetached;\n                } while (currentDetached !== marker);\n            }\n            if (this.unbindAfterDetachCount > 0) {\n                this.beginUnbind();\n                this.unbindAfterDetachCount = 0;\n                let currentUnbind = this.unbindAfterDetachHead.$nextUnbindAfterDetach;\n                this.unbindAfterDetachHead = this.unbindAfterDetachTail = this;\n                let nextUnbind;\n                do {\n                    currentUnbind.$unbind(flags);\n                    nextUnbind = currentUnbind.$nextUnbindAfterDetach;\n                    currentUnbind.$nextUnbindAfterDetach = null;\n                    currentUnbind = nextUnbind;\n                } while (currentUnbind !== marker);\n                this.endUnbind(flags);\n            }\n        }\n    }\n    exports.CompositionCoordinator = class CompositionCoordinator {\n        constructor($lifecycle) {\n            this.$lifecycle = $lifecycle;\n            this.onSwapComplete = kernel.PLATFORM.noop;\n            this.queue = null;\n            this.swapTask = LifecycleTask.done;\n            this.currentView = null;\n            this.isBound = false;\n            this.isAttached = false;\n        }\n        static register(container) {\n            return kernel.Registration.transient(this, this).register(container, this);\n        }\n        compose(value, flags) {\n            if (this.swapTask.done) {\n                if (value instanceof Promise) {\n                    this.enqueue(new PromiseSwap(this, value));\n                    this.processNext();\n                }\n                else {\n                    this.swap(value, flags);\n                }\n            }\n            else {\n                if (value instanceof Promise) {\n                    this.enqueue(new PromiseSwap(this, value));\n                }\n                else {\n                    this.enqueue(value);\n                }\n                if (this.swapTask.canCancel()) {\n                    this.swapTask.cancel();\n                }\n            }\n        }\n        binding(flags, scope) {\n            this.scope = scope;\n            this.isBound = true;\n            if (this.currentView !== null) {\n                this.currentView.$bind(flags, scope);\n            }\n        }\n        attaching(flags) {\n            this.isAttached = true;\n            if (this.currentView !== null) {\n                this.currentView.$attach(flags);\n            }\n        }\n        detaching(flags) {\n            this.isAttached = false;\n            if (this.currentView !== null) {\n                this.currentView.$detach(flags);\n            }\n        }\n        unbinding(flags) {\n            this.isBound = false;\n            if (this.currentView !== null) {\n                this.currentView.$unbind(flags);\n            }\n        }\n        caching(flags) {\n            this.currentView = null;\n        }\n        enqueue(view) {\n            if (this.queue === null) {\n                this.queue = [];\n            }\n            this.queue.push(view);\n        }\n        swap(view, flags) {\n            if (this.currentView === view) {\n                return;\n            }\n            const $lifecycle = this.$lifecycle;\n            const swapTask = new AggregateLifecycleTask();\n            let lifecycleTask;\n            let currentView = this.currentView;\n            if (currentView === null) {\n                lifecycleTask = LifecycleTask.done;\n            }\n            else {\n                $lifecycle.enqueueUnbindAfterDetach(currentView);\n                $lifecycle.beginDetach();\n                currentView.$detach(flags);\n                lifecycleTask = $lifecycle.endDetach(flags);\n            }\n            swapTask.addTask(lifecycleTask);\n            currentView = this.currentView = view;\n            if (currentView === null) {\n                lifecycleTask = LifecycleTask.done;\n            }\n            else {\n                if (this.isBound) {\n                    $lifecycle.beginBind();\n                    currentView.$bind(flags, this.scope);\n                    $lifecycle.endBind(flags);\n                }\n                if (this.isAttached) {\n                    $lifecycle.beginAttach();\n                    currentView.$attach(flags);\n                    lifecycleTask = $lifecycle.endAttach(flags);\n                }\n                else {\n                    lifecycleTask = LifecycleTask.done;\n                }\n            }\n            swapTask.addTask(lifecycleTask);\n            if (swapTask.done) {\n                this.swapTask = LifecycleTask.done;\n                this.onSwapComplete();\n            }\n            else {\n                this.swapTask = swapTask;\n                this.swapTask.wait().then(() => {\n                    this.onSwapComplete();\n                    this.processNext();\n                });\n            }\n        }\n        processNext() {\n            if (this.queue !== null && this.queue.length > 0) {\n                const next = this.queue.pop();\n                this.queue.length = 0;\n                if (PromiseSwap.is(next)) {\n                    this.swapTask = next.start();\n                }\n                else {\n                    this.swap(next, exports.LifecycleFlags.fromLifecycleTask);\n                }\n            }\n            else {\n                this.swapTask = LifecycleTask.done;\n            }\n        }\n    };\n    exports.CompositionCoordinator = __decorate([\n        kernel.inject(ILifecycle)\n    ], exports.CompositionCoordinator);\n    const LifecycleTask = {\n        done: {\n            done: true,\n            canCancel() { return false; },\n            // tslint:disable-next-line:no-empty\n            cancel() { },\n            wait() { return Promise.resolve(); }\n        }\n    };\n    class AggregateLifecycleTask {\n        constructor() {\n            this.done = true;\n            /*@internal*/\n            this.owner = null;\n            this.tasks = [];\n            this.waiter = null;\n            this.resolve = null;\n        }\n        addTask(task) {\n            if (!task.done) {\n                this.done = false;\n                this.tasks.push(task);\n                task.wait().then(() => this.tryComplete());\n            }\n        }\n        removeTask(task) {\n            if (task.done) {\n                const idx = this.tasks.indexOf(task);\n                if (idx !== -1) {\n                    this.tasks.splice(idx, 1);\n                }\n            }\n            if (this.tasks.length === 0) {\n                if (this.owner !== null) {\n                    this.owner.finishTask(this);\n                    this.owner = null;\n                }\n            }\n        }\n        canCancel() {\n            if (this.done) {\n                return false;\n            }\n            return this.tasks.every(x => x.canCancel());\n        }\n        cancel() {\n            if (this.canCancel()) {\n                this.tasks.forEach(x => x.cancel());\n                this.done = false;\n            }\n        }\n        wait() {\n            if (this.waiter === null) {\n                if (this.done) {\n                    this.waiter = Promise.resolve();\n                }\n                else {\n                    // tslint:disable-next-line:promise-must-complete\n                    this.waiter = new Promise((resolve) => this.resolve = resolve);\n                }\n            }\n            return this.waiter;\n        }\n        tryComplete() {\n            if (this.done) {\n                return;\n            }\n            if (this.tasks.every(x => x.done)) {\n                this.complete(true);\n            }\n        }\n        complete(notCancelled) {\n            this.done = true;\n            if (notCancelled && this.owner !== null) {\n                this.owner.processDetachQueue(exports.LifecycleFlags.fromLifecycleTask);\n                this.owner.processUnbindQueue(exports.LifecycleFlags.fromLifecycleTask);\n                this.owner.processBindQueue(exports.LifecycleFlags.fromLifecycleTask);\n                this.owner.processAttachQueue(exports.LifecycleFlags.fromLifecycleTask);\n            }\n            this.owner.finishTask(this);\n            if (this.resolve !== null) {\n                this.resolve();\n            }\n        }\n    }\n    /*@internal*/\n    class PromiseSwap {\n        constructor(coordinator, promise) {\n            this.coordinator = coordinator;\n            this.promise = promise;\n            this.done = false;\n            this.isCancelled = false;\n        }\n        static is(object) {\n            return 'start' in object;\n        }\n        start() {\n            if (this.isCancelled) {\n                return LifecycleTask.done;\n            }\n            this.promise = this.promise.then(x => {\n                this.onResolve(x);\n                return x;\n            });\n            return this;\n        }\n        canCancel() {\n            return !this.done;\n        }\n        cancel() {\n            if (this.canCancel()) {\n                this.isCancelled = true;\n            }\n        }\n        wait() {\n            return this.promise;\n        }\n        onResolve(value) {\n            if (this.isCancelled) {\n                return;\n            }\n            this.done = true;\n            this.coordinator.compose(value, exports.LifecycleFlags.fromLifecycleTask);\n        }\n    }\n    // tslint:disable:jsdoc-format\n    /**\n     * A general-purpose ILifecycleTask implementation that can be placed\n     * before an attached, detached, bound or unbound hook during attaching,\n     * detaching, binding or unbinding, respectively.\n     *\n     * The provided promise will be awaited before the corresponding lifecycle\n     * hook (and any hooks following it) is invoked.\n     *\n     * The provided callback will be invoked after the promise is resolved\n     * and before the next lifecycle hook.\n     *\n     * Example:\n    ```ts\n    export class MyViewModel {\n      private $lifecycle: ILifecycle; // set before created() hook\n      private answer: number;\n\n      public binding(flags: LifecycleFlags): void {\n        // this.answer === undefined\n        this.$lifecycle.registerTask(new PromiseTask(\n          this.getAnswerAsync,\n          answer => {\n            this.answer = answer;\n          }\n        ));\n      }\n\n      public bound(flags: LifecycleFlags): void {\n        // this.answer === 42\n      }\n\n      private getAnswerAsync(): Promise<number> {\n        return Promise.resolve().then(() => 42);\n      }\n    }\n    ```\n     */\n    // tslint:enable:jsdoc-format\n    class PromiseTask {\n        constructor(promise, callback) {\n            this.done = false;\n            this.isCancelled = false;\n            this.callback = callback;\n            this.promise = promise.then(value => {\n                if (this.isCancelled === true) {\n                    return;\n                }\n                this.done = true;\n                this.callback(value);\n                return value;\n            });\n        }\n        canCancel() {\n            return !this.done;\n        }\n        cancel() {\n            if (this.canCancel()) {\n                this.isCancelled = true;\n            }\n        }\n        wait() {\n            return this.promise;\n        }\n    }\n\n    function bindingBehavior(nameOrSource) {\n        return function (target) {\n            return BindingBehaviorResource.define(nameOrSource, target);\n        };\n    }\n    const BindingBehaviorResource = {\n        name: 'binding-behavior',\n        keyFrom(name) {\n            return `${this.name}:${name}`;\n        },\n        isType(Type) {\n            return Type.kind === this;\n        },\n        define(nameOrSource, ctor) {\n            const Type = ctor;\n            const description = typeof nameOrSource === 'string'\n                ? { name: nameOrSource }\n                : nameOrSource;\n            Type.kind = BindingBehaviorResource;\n            Type.description = description;\n            Type.register = register;\n            return Type;\n        }\n    };\n    function register(container) {\n        container.register(kernel.Registration.singleton(BindingBehaviorResource.keyFrom(this.description.name), this));\n    }\n\n    const ELEMENT_NODE = 1;\n    const ATTRIBUTE_NODE = 2;\n    const TEXT_NODE = 3;\n    const COMMENT_NODE = 8;\n    const DOCUMENT_FRAGMENT_NODE = 11;\n    function isRenderLocation(node) {\n        return node.textContent === 'au-end';\n    }\n    const INode = kernel.DI.createInterface().noDefault();\n    const IRenderLocation = kernel.DI.createInterface().noDefault();\n    // tslint:disable:no-any\n    const DOM = {\n        createDocumentFragment(markupOrNode) {\n            if (markupOrNode === undefined || markupOrNode === null) {\n                return document.createDocumentFragment();\n            }\n            if (markupOrNode.nodeType > 0) {\n                if (markupOrNode.content !== undefined) {\n                    return markupOrNode.content;\n                }\n                const fragment = document.createDocumentFragment();\n                fragment.appendChild(markupOrNode);\n                return fragment;\n            }\n            return DOM.createTemplate(markupOrNode).content;\n        },\n        createTemplate(markup) {\n            if (markup === undefined) {\n                return document.createElement('template');\n            }\n            const template = document.createElement('template');\n            template.innerHTML = markup;\n            return template;\n        },\n        addClass(node, className) {\n            node.classList.add(className);\n        },\n        addEventListener(eventName, subscriber, publisher, options) {\n            (publisher || document).addEventListener(eventName, subscriber, options);\n        },\n        appendChild(parent, child) {\n            parent.appendChild(child);\n        },\n        attachShadow(host, options) {\n            return host.attachShadow(options);\n        },\n        cloneNode(node, deep) {\n            return node.cloneNode(deep !== false); // use true unless the caller explicitly passes in false\n        },\n        convertToRenderLocation(node) {\n            if (isRenderLocation(node)) {\n                return node; // it's already a RenderLocation (converted by FragmentNodeSequence)\n            }\n            if (node.parentNode === null) {\n                throw kernel.Reporter.error(52);\n            }\n            const locationEnd = document.createComment('au-end');\n            const locationStart = document.createComment('au-start');\n            DOM.replaceNode(locationEnd, node);\n            DOM.insertBefore(locationStart, locationEnd);\n            locationEnd.$start = locationStart;\n            locationStart.$nodes = null;\n            return locationEnd;\n        },\n        createComment(text) {\n            return document.createComment(text);\n        },\n        createElement(name) {\n            return document.createElement(name);\n        },\n        createNodeObserver(target, callback, options) {\n            const observer = new MutationObserver(callback);\n            observer.observe(target, options);\n            return observer;\n        },\n        createTextNode(text) {\n            return document.createTextNode(text);\n        },\n        getAttribute(node, name) {\n            return node.getAttribute(name);\n        },\n        hasClass(node, className) {\n            return node.classList.contains(className);\n        },\n        insertBefore(nodeToInsert, referenceNode) {\n            referenceNode.parentNode.insertBefore(nodeToInsert, referenceNode);\n        },\n        isAllWhitespace(node) {\n            if (node.auInterpolationTarget === true) {\n                return false;\n            }\n            const text = node.textContent;\n            const len = text.length;\n            let i = 0;\n            // for perf benchmark of this compared to the regex method: http://jsben.ch/p70q2 (also a general case against using regex)\n            while (i < len) {\n                // charCodes 0-0x20(32) can all be considered whitespace (non-whitespace chars in this range don't have a visual representation anyway)\n                if (text.charCodeAt(i) > 0x20) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        },\n        isCommentNodeType(node) {\n            return node.nodeType === COMMENT_NODE;\n        },\n        isDocumentFragmentType(node) {\n            return node.nodeType === DOCUMENT_FRAGMENT_NODE;\n        },\n        isElementNodeType(node) {\n            return node.nodeType === ELEMENT_NODE;\n        },\n        isNodeInstance(potentialNode) {\n            return potentialNode.nodeType > 0;\n        },\n        isTextNodeType(node) {\n            return node.nodeType === TEXT_NODE;\n        },\n        migrateChildNodes(currentParent, newParent) {\n            while (currentParent.firstChild) {\n                DOM.appendChild(newParent, currentParent.firstChild);\n            }\n        },\n        registerElementResolver(container, resolver) {\n            container.registerResolver(INode, resolver);\n            container.registerResolver(Element, resolver);\n            container.registerResolver(HTMLElement, resolver);\n            container.registerResolver(SVGElement, resolver);\n        },\n        remove(node) {\n            if (node.remove) {\n                node.remove();\n            }\n            else {\n                node.parentNode.removeChild(node);\n            }\n        },\n        removeAttribute(node, name) {\n            node.removeAttribute(name);\n        },\n        removeClass(node, className) {\n            node.classList.remove(className);\n        },\n        removeEventListener(eventName, subscriber, publisher, options) {\n            (publisher || document).removeEventListener(eventName, subscriber, options);\n        },\n        replaceNode(newChild, oldChild) {\n            if (oldChild.parentNode) {\n                oldChild.parentNode.replaceChild(newChild, oldChild);\n            }\n        },\n        setAttribute(node, name, value) {\n            node.setAttribute(name, value);\n        },\n        treatAsNonWhitespace(node) {\n            // see isAllWhitespace above\n            node.auInterpolationTarget = true;\n        }\n    };\n    // This is an implementation of INodeSequence that represents \"no DOM\" to render.\n    // It's used in various places to avoid null and to encode\n    // the explicit idea of \"no view\".\n    const emptySequence = {\n        firstChild: null,\n        lastChild: null,\n        childNodes: kernel.PLATFORM.emptyArray,\n        findTargets() { return kernel.PLATFORM.emptyArray; },\n        insertBefore(refNode) { },\n        appendTo(parent) { },\n        remove() { }\n    };\n    const NodeSequence = {\n        empty: emptySequence\n    };\n    /**\n     * An specialized INodeSequence with optimizations for text (interpolation) bindings\n     * The contract of this INodeSequence is:\n     * - the previous element is an `au-marker` node\n     * - text is the actual text node\n     */\n    class TextNodeSequence {\n        constructor(text) {\n            this.firstChild = text;\n            this.lastChild = text;\n            this.childNodes = [text];\n            this.targets = [new AuMarker(text)];\n        }\n        findTargets() {\n            return this.targets;\n        }\n        insertBefore(refNode) {\n            refNode.parentNode.insertBefore(this.firstChild, refNode);\n        }\n        appendTo(parent) {\n            parent.appendChild(this.firstChild);\n        }\n        remove() {\n            this.firstChild.remove();\n        }\n    }\n    // tslint:enable:no-any\n    // This is the most common form of INodeSequence.\n    // Every custom element or template controller whose node sequence is based on an HTML template\n    // has an instance of this under the hood. Anyone who wants to create a node sequence from\n    // a string of markup would also receive an instance of this.\n    // CompiledTemplates create instances of FragmentNodeSequence.\n    /*@internal*/\n    class FragmentNodeSequence {\n        constructor(fragment) {\n            this.fragment = fragment;\n            // tslint:disable-next-line:no-any\n            const targetNodeList = fragment.querySelectorAll('.au');\n            let i = 0;\n            let ii = targetNodeList.length;\n            const targets = this.targets = Array(ii);\n            while (i < ii) {\n                // eagerly convert all markers to IRenderLocations (otherwise the renderer\n                // will do it anyway) and store them in the target list (since the comments\n                // can't be queried)\n                const target = targetNodeList[i];\n                if (target.nodeName === 'AU-MARKER') {\n                    // note the renderer will still call this method, but it will just return the\n                    // location if it sees it's already a location\n                    targets[i] = DOM.convertToRenderLocation(target);\n                }\n                else {\n                    // also store non-markers for consistent ordering\n                    targets[i] = target;\n                }\n                ++i;\n            }\n            const childNodeList = fragment.childNodes;\n            i = 0;\n            ii = childNodeList.length;\n            const childNodes = this.childNodes = Array(ii);\n            while (i < ii) {\n                childNodes[i] = childNodeList[i];\n                ++i;\n            }\n            this.firstChild = fragment.firstChild;\n            this.lastChild = fragment.lastChild;\n            this.start = this.end = null;\n        }\n        findTargets() {\n            // tslint:disable-next-line:no-any\n            return this.targets;\n        }\n        insertBefore(refNode) {\n            // tslint:disable-next-line:no-any\n            refNode.parentNode.insertBefore(this.fragment, refNode);\n            // internally we could generally assume that this is an IRenderLocation,\n            // but since this is also public API we still need to double check\n            // (or horrible things might happen)\n            if (isRenderLocation(refNode)) {\n                this.end = refNode;\n                const start = this.start = refNode.$start;\n                if (start.$nodes === null) {\n                    start.$nodes = this;\n                }\n                else {\n                    // if more than one NodeSequence uses the same RenderLocation, it's an child\n                    // of a repeater (or something similar) and we shouldn't remove all nodes between\n                    // start - end since that would always remove all items from a repeater, even\n                    // when only one is removed\n                    // so we set $nodes to PLATFORM.emptyObject to 1) tell other sequences that it's\n                    // occupied and 2) prevent start.$nodes === this from ever evaluating to true\n                    // during remove()\n                    start.$nodes = kernel.PLATFORM.emptyObject;\n                }\n            }\n        }\n        appendTo(parent) {\n            // tslint:disable-next-line:no-any\n            parent.appendChild(this.fragment);\n            // this can never be a RenderLocation, and if for whatever reason we moved\n            // from a RenderLocation to a host, make sure \"start\" and \"end\" are null\n            this.start = this.end = null;\n        }\n        remove() {\n            const fragment = this.fragment;\n            if (this.start !== null && this.start.$nodes === this) {\n                // if we're between a valid \"start\" and \"end\" (e.g. if/else, containerless, or a\n                // repeater with a single item) then simply remove everything in-between (but not\n                // the comments themselves as they belong to the parent)\n                const end = this.end;\n                let next;\n                let current = this.start.nextSibling;\n                while (current !== end) {\n                    next = current.nextSibling;\n                    // tslint:disable-next-line:no-any\n                    fragment.appendChild(current);\n                    current = next;\n                }\n                this.start.$nodes = null;\n                this.start = this.end = null;\n            }\n            else {\n                // otherwise just remove from first to last child in the regular way\n                let current = this.firstChild;\n                if (current.parentNode !== fragment) {\n                    const end = this.lastChild;\n                    let next;\n                    while (current !== null) {\n                        next = current.nextSibling;\n                        // tslint:disable-next-line:no-any\n                        fragment.appendChild(current);\n                        if (current === end) {\n                            break;\n                        }\n                        current = next;\n                    }\n                }\n            }\n        }\n    }\n    class NodeSequenceFactory {\n        constructor(fragment) {\n            const childNodes = fragment.childNodes;\n            switch (childNodes.length) {\n                case 0:\n                    this.createNodeSequence = () => NodeSequence.empty;\n                    return;\n                case 2:\n                    const target = childNodes[0];\n                    if (target.nodeName === 'AU-MARKER' || target.nodeName === '#comment') {\n                        const text = childNodes[1];\n                        if (text.nodeType === TEXT_NODE && text.textContent === ' ') {\n                            text.textContent = '';\n                            this.deepClone = false;\n                            this.node = text;\n                            this.Type = TextNodeSequence;\n                            return;\n                        }\n                    }\n                // falls through if not returned\n                default:\n                    this.deepClone = true;\n                    this.node = fragment;\n                    this.Type = FragmentNodeSequence;\n            }\n        }\n        static createFor(markupOrNode) {\n            const fragment = DOM.createDocumentFragment(markupOrNode);\n            return new NodeSequenceFactory(fragment);\n        }\n        createNodeSequence() {\n            return new this.Type(this.node.cloneNode(this.deepClone));\n        }\n    }\n    /*@internal*/\n    class AuMarker {\n        constructor(next) {\n            this.textContent = '';\n            this.nextSibling = next;\n        }\n        get parentNode() {\n            return this.nextSibling.parentNode;\n        }\n        remove() { }\n    }\n    (proto => {\n        proto.previousSibling = null;\n        proto.firstChild = null;\n        proto.lastChild = null;\n        proto.childNodes = kernel.PLATFORM.emptyArray;\n        proto.nodeName = 'AU-MARKER';\n        proto.nodeType = ELEMENT_NODE;\n    })(AuMarker.prototype);\n\n    function subscriberCollection(mutationKind) {\n        return function (target) {\n            const proto = target.prototype;\n            proto._subscriberFlags = 0 /* None */;\n            proto._subscriber0 = null;\n            proto._subscriber1 = null;\n            proto._subscriber2 = null;\n            proto._subscribersRest = null;\n            proto.addSubscriber = addSubscriber;\n            proto.removeSubscriber = removeSubscriber;\n            proto.hasSubscriber = hasSubscriber;\n            proto.hasSubscribers = hasSubscribers;\n            proto.callSubscribers = (mutationKind === exports.MutationKind.instance ? callPropertySubscribers : callCollectionSubscribers);\n        };\n    }\n    function addSubscriber(subscriber) {\n        if (this.hasSubscriber(subscriber)) {\n            return false;\n        }\n        const subscriberFlags = this._subscriberFlags;\n        if (!(subscriberFlags & 1 /* Subscriber0 */)) {\n            this._subscriber0 = subscriber;\n            this._subscriberFlags |= 1 /* Subscriber0 */;\n            return true;\n        }\n        if (!(subscriberFlags & 2 /* Subscriber1 */)) {\n            this._subscriber1 = subscriber;\n            this._subscriberFlags |= 2 /* Subscriber1 */;\n            return true;\n        }\n        if (!(subscriberFlags & 4 /* Subscriber2 */)) {\n            this._subscriber2 = subscriber;\n            this._subscriberFlags |= 4 /* Subscriber2 */;\n            return true;\n        }\n        if (!(subscriberFlags & 8 /* SubscribersRest */)) {\n            this._subscribersRest = [subscriber];\n            this._subscriberFlags |= 8 /* SubscribersRest */;\n            return true;\n        }\n        this._subscribersRest.push(subscriber);\n        return true;\n    }\n    function removeSubscriber(subscriber) {\n        const subscriberFlags = this._subscriberFlags;\n        if ((subscriberFlags & 1 /* Subscriber0 */) && this._subscriber0 === subscriber) {\n            this._subscriber0 = null;\n            this._subscriberFlags &= ~1 /* Subscriber0 */;\n            return true;\n        }\n        if ((subscriberFlags & 2 /* Subscriber1 */) && this._subscriber1 === subscriber) {\n            this._subscriber1 = null;\n            this._subscriberFlags &= ~2 /* Subscriber1 */;\n            return true;\n        }\n        if ((subscriberFlags & 4 /* Subscriber2 */) && this._subscriber2 === subscriber) {\n            this._subscriber2 = null;\n            this._subscriberFlags &= ~4 /* Subscriber2 */;\n            return true;\n        }\n        if (subscriberFlags & 8 /* SubscribersRest */) {\n            const subscribers = this._subscribersRest;\n            for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n                if (subscribers[i] === subscriber) {\n                    subscribers.splice(i, 1);\n                    if (ii === 1) {\n                        this._subscriberFlags &= ~8 /* SubscribersRest */;\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    function callPropertySubscribers(newValue, previousValue, flags) {\n        /**\n         * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this\n         * callSubscribers invocation, so we're caching them all before invoking any.\n         * Subscribers added during this invocation are not invoked (and they shouldn't be).\n         * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,\n         * however this is accounted for via $isBound and similar flags on the subscriber objects)\n         */\n        const subscriber0 = this._subscriber0;\n        const subscriber1 = this._subscriber1;\n        const subscriber2 = this._subscriber2;\n        let subscribers = this._subscribersRest;\n        if (subscribers !== null) {\n            subscribers = subscribers.slice();\n        }\n        if (subscriber0 !== null) {\n            subscriber0.handleChange(newValue, previousValue, flags);\n        }\n        if (subscriber1 !== null) {\n            subscriber1.handleChange(newValue, previousValue, flags);\n        }\n        if (subscriber2 !== null) {\n            subscriber2.handleChange(newValue, previousValue, flags);\n        }\n        const length = subscribers && subscribers.length;\n        if (length !== undefined && length > 0) {\n            for (let i = 0; i < length; ++i) {\n                const subscriber = subscribers[i];\n                if (subscriber !== null) {\n                    subscriber.handleChange(newValue, previousValue, flags);\n                }\n            }\n        }\n    }\n    function callCollectionSubscribers(origin, args, flags) {\n        const subscriber0 = this._subscriber0;\n        const subscriber1 = this._subscriber1;\n        const subscriber2 = this._subscriber2;\n        let subscribers = this._subscribersRest;\n        if (subscribers !== null) {\n            subscribers = subscribers.slice();\n        }\n        if (subscriber0 !== null) {\n            subscriber0.handleChange(origin, args, flags);\n        }\n        if (subscriber1 !== null) {\n            subscriber1.handleChange(origin, args, flags);\n        }\n        if (subscriber2 !== null) {\n            subscriber2.handleChange(origin, args, flags);\n        }\n        const length = subscribers && subscribers.length;\n        if (length !== undefined && length > 0) {\n            for (let i = 0; i < length; ++i) {\n                const subscriber = subscribers[i];\n                if (subscriber !== null) {\n                    subscriber.handleChange(origin, args, flags);\n                }\n            }\n        }\n        this.lifecycle.enqueueFlush(this);\n    }\n    function hasSubscribers() {\n        return this._subscriberFlags !== 0 /* None */;\n    }\n    function hasSubscriber(subscriber) {\n        // Flags here is just a perf tweak\n        // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n        // and minor slow-down when it does, and the former is more common than the latter.\n        const subscriberFlags = this._subscriberFlags;\n        if ((subscriberFlags & 1 /* Subscriber0 */) && this._subscriber0 === subscriber) {\n            return true;\n        }\n        if ((subscriberFlags & 2 /* Subscriber1 */) && this._subscriber1 === subscriber) {\n            return true;\n        }\n        if ((subscriberFlags & 4 /* Subscriber2 */) && this._subscriber2 === subscriber) {\n            return true;\n        }\n        if (subscriberFlags & 8 /* SubscribersRest */) {\n            // no need to check length; if the flag is set, there's always at least one\n            const subscribers = this._subscribersRest;\n            for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n                if (subscribers[i] === subscriber) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    function batchedSubscriberCollection() {\n        return function (target) {\n            const proto = target.prototype;\n            proto._batchedSubscriberFlags = 0 /* None */;\n            proto._batchedSubscriber0 = null;\n            proto._batchedSubscriber1 = null;\n            proto._batchedSubscriber2 = null;\n            proto._batchedSubscribersRest = null;\n            proto.addBatchedSubscriber = addBatchedSubscriber;\n            proto.removeBatchedSubscriber = removeBatchedSubscriber;\n            proto.hasBatchedSubscriber = hasBatchedSubscriber;\n            proto.hasBatchedSubscribers = hasBatchedSubscribers;\n            proto.callBatchedSubscribers = callBatchedCollectionSubscribers;\n        };\n    }\n    function addBatchedSubscriber(subscriber) {\n        if (this.hasBatchedSubscriber(subscriber)) {\n            return false;\n        }\n        const subscriberFlags = this._batchedSubscriberFlags;\n        if (!(subscriberFlags & 1 /* Subscriber0 */)) {\n            this._batchedSubscriber0 = subscriber;\n            this._batchedSubscriberFlags |= 1 /* Subscriber0 */;\n            return true;\n        }\n        if (!(subscriberFlags & 2 /* Subscriber1 */)) {\n            this._batchedSubscriber1 = subscriber;\n            this._batchedSubscriberFlags |= 2 /* Subscriber1 */;\n            return true;\n        }\n        if (!(subscriberFlags & 4 /* Subscriber2 */)) {\n            this._batchedSubscriber2 = subscriber;\n            this._batchedSubscriberFlags |= 4 /* Subscriber2 */;\n            return true;\n        }\n        if (!(subscriberFlags & 8 /* SubscribersRest */)) {\n            this._batchedSubscribersRest = [subscriber];\n            this._batchedSubscriberFlags |= 8 /* SubscribersRest */;\n            return true;\n        }\n        this._batchedSubscribersRest.push(subscriber);\n        return true;\n    }\n    function removeBatchedSubscriber(subscriber) {\n        const subscriberFlags = this._batchedSubscriberFlags;\n        if ((subscriberFlags & 1 /* Subscriber0 */) && this._batchedSubscriber0 === subscriber) {\n            this._batchedSubscriber0 = null;\n            this._batchedSubscriberFlags &= ~1 /* Subscriber0 */;\n            return true;\n        }\n        if ((subscriberFlags & 2 /* Subscriber1 */) && this._batchedSubscriber1 === subscriber) {\n            this._batchedSubscriber1 = null;\n            this._batchedSubscriberFlags &= ~2 /* Subscriber1 */;\n            return true;\n        }\n        if ((subscriberFlags & 4 /* Subscriber2 */) && this._batchedSubscriber2 === subscriber) {\n            this._batchedSubscriber2 = null;\n            this._batchedSubscriberFlags &= ~4 /* Subscriber2 */;\n            return true;\n        }\n        if (subscriberFlags & 8 /* SubscribersRest */) {\n            const subscribers = this._batchedSubscribersRest;\n            for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n                if (subscribers[i] === subscriber) {\n                    subscribers.splice(i, 1);\n                    if (ii === 1) {\n                        this._batchedSubscriberFlags &= ~8 /* SubscribersRest */;\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    function callBatchedCollectionSubscribers(indexMap) {\n        const subscriber0 = this._batchedSubscriber0;\n        const subscriber1 = this._batchedSubscriber1;\n        const subscriber2 = this._batchedSubscriber2;\n        let subscribers = this._batchedSubscribersRest;\n        if (subscribers !== null) {\n            subscribers = subscribers.slice();\n        }\n        if (subscriber0 !== null) {\n            subscriber0.handleBatchedChange(indexMap);\n        }\n        if (subscriber1 !== null) {\n            subscriber1.handleBatchedChange(indexMap);\n        }\n        if (subscriber2 !== null) {\n            subscriber2.handleBatchedChange(indexMap);\n        }\n        const length = subscribers && subscribers.length;\n        if (length !== undefined && length > 0) {\n            for (let i = 0; i < length; ++i) {\n                const subscriber = subscribers[i];\n                if (subscriber !== null) {\n                    subscriber.handleBatchedChange(indexMap);\n                }\n            }\n        }\n    }\n    function hasBatchedSubscribers() {\n        return this._batchedSubscriberFlags !== 0 /* None */;\n    }\n    function hasBatchedSubscriber(subscriber) {\n        // Flags here is just a perf tweak\n        // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n        // and minor slow-down when it does, and the former is more common than the latter.\n        const subscriberFlags = this._batchedSubscriberFlags;\n        if ((subscriberFlags & 1 /* Subscriber0 */) && this._batchedSubscriber0 === subscriber) {\n            return true;\n        }\n        if ((subscriberFlags & 2 /* Subscriber1 */) && this._batchedSubscriber1 === subscriber) {\n            return true;\n        }\n        if ((subscriberFlags & 4 /* Subscriber2 */) && this._batchedSubscriber2 === subscriber) {\n            return true;\n        }\n        if (subscriberFlags & 8 /* SubscribersRest */) {\n            // no need to check length; if the flag is set, there's always at least one\n            const subscribers = this._batchedSubscribersRest;\n            for (let i = 0, ii = subscribers.length; i < ii; ++i) {\n                if (subscribers[i] === subscriber) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function setValue(newValue, flags) {\n        const currentValue = this.currentValue;\n        newValue = newValue === null || newValue === undefined ? this.defaultValue : newValue;\n        if (currentValue !== newValue) {\n            this.currentValue = newValue;\n            if ((flags & (exports.LifecycleFlags.fromFlush | exports.LifecycleFlags.fromBind)) &&\n                !((flags & exports.LifecycleFlags.doNotUpdateDOM) && DOM.isNodeInstance(this.obj))) {\n                this.setValueCore(newValue, flags);\n            }\n            else {\n                this.currentFlags = flags;\n                return this.lifecycle.enqueueFlush(this);\n            }\n        }\n        return Promise.resolve();\n    }\n    function flush(flags) {\n        if (flags & exports.LifecycleFlags.doNotUpdateDOM) {\n            if (DOM.isNodeInstance(this.obj)) {\n                // re-queue the change so it will still propagate on flush when it's attached again\n                this.lifecycle.enqueueFlush(this);\n                return;\n            }\n        }\n        const currentValue = this.currentValue;\n        // we're doing this check because a value could be set multiple times before a flush, and the final value could be the same as the original value\n        // in which case the target doesn't need to be updated\n        if (this.oldValue !== currentValue) {\n            this.setValueCore(currentValue, this.currentFlags | flags | exports.LifecycleFlags.updateTargetInstance);\n            this.oldValue = this.currentValue;\n        }\n    }\n    function dispose() {\n        this.currentValue = null;\n        this.oldValue = null;\n        this.defaultValue = null;\n        this.obj = null;\n        this.propertyKey = '';\n    }\n    function targetObserver(defaultValue = null) {\n        return function (target) {\n            subscriberCollection(exports.MutationKind.instance)(target);\n            const proto = target.prototype;\n            proto.$nextFlush = null;\n            proto.currentValue = defaultValue;\n            proto.oldValue = defaultValue;\n            proto.defaultValue = defaultValue;\n            proto.obj = null;\n            proto.propertyKey = '';\n            proto.setValue = proto.setValue || setValue;\n            proto.flush = proto.flush || flush;\n            proto.dispose = proto.dispose || dispose;\n        };\n    }\n\n    // tslint:disable-next-line:no-http-string\n    const xlinkAttributeNS = 'http://www.w3.org/1999/xlink';\n    exports.XLinkAttributeAccessor = class XLinkAttributeAccessor {\n        // xlink namespaced attributes require getAttributeNS/setAttributeNS\n        // (even though the NS version doesn't work for other namespaces\n        // in html5 documents)\n        // Using very HTML-specific code here since this isn't likely to get\n        // called unless operating against a real HTML element.\n        constructor(lifecycle, obj, propertyKey, attributeName) {\n            this.lifecycle = lifecycle;\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n            this.attributeName = attributeName;\n            this.oldValue = this.currentValue = this.getValue();\n        }\n        getValue() {\n            return this.obj.getAttributeNS(xlinkAttributeNS, this.attributeName);\n        }\n        setValueCore(newValue) {\n            this.obj.setAttributeNS(xlinkAttributeNS, this.attributeName, newValue);\n        }\n    };\n    exports.XLinkAttributeAccessor = __decorate([\n        targetObserver('')\n    ], exports.XLinkAttributeAccessor);\n    exports.XLinkAttributeAccessor.prototype.attributeName = '';\n    exports.DataAttributeAccessor = class DataAttributeAccessor {\n        constructor(lifecycle, obj, propertyKey) {\n            this.lifecycle = lifecycle;\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n            this.oldValue = this.currentValue = this.getValue();\n        }\n        getValue() {\n            return DOM.getAttribute(this.obj, this.propertyKey);\n        }\n        setValueCore(newValue) {\n            if (newValue === null) {\n                DOM.removeAttribute(this.obj, this.propertyKey);\n            }\n            else {\n                DOM.setAttribute(this.obj, this.propertyKey, newValue);\n            }\n        }\n    };\n    exports.DataAttributeAccessor = __decorate([\n        targetObserver()\n    ], exports.DataAttributeAccessor);\n    exports.StyleAttributeAccessor = class StyleAttributeAccessor {\n        constructor(lifecycle, obj) {\n            this.lifecycle = lifecycle;\n            this.obj = obj;\n            this.oldValue = this.currentValue = obj.style.cssText;\n        }\n        getValue() {\n            return this.obj.style.cssText;\n        }\n        // tslint:disable-next-line:function-name\n        _setProperty(style, value) {\n            let priority = '';\n            if (value !== null && value !== undefined && typeof value.indexOf === 'function' && value.indexOf('!important') !== -1) {\n                priority = 'important';\n                value = value.replace('!important', '');\n            }\n            this.obj.style.setProperty(style, value, priority);\n        }\n        setValueCore(newValue) {\n            const styles = this.styles || {};\n            let style;\n            let version = this.version;\n            if (newValue !== null) {\n                if (newValue instanceof Object) {\n                    let value;\n                    for (style in newValue) {\n                        if (newValue.hasOwnProperty(style)) {\n                            value = newValue[style];\n                            style = style.replace(/([A-Z])/g, m => `-${m.toLowerCase()}`);\n                            styles[style] = version;\n                            this._setProperty(style, value);\n                        }\n                    }\n                }\n                else if (newValue.length) {\n                    const rx = /\\s*([\\w\\-]+)\\s*:\\s*((?:(?:[\\w\\-]+\\(\\s*(?:\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[\\w\\-]+\\(\\s*(?:^\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[^\\)]*)\\),?|[^\\)]*)\\),?|\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|[^;]*),?\\s*)+);?/g;\n                    let pair;\n                    while ((pair = rx.exec(newValue)) !== null) {\n                        style = pair[1];\n                        if (!style) {\n                            continue;\n                        }\n                        styles[style] = version;\n                        this._setProperty(style, pair[2]);\n                    }\n                }\n            }\n            this.styles = styles;\n            this.version += 1;\n            if (version === 0) {\n                return;\n            }\n            version -= 1;\n            for (style in styles) {\n                if (!styles.hasOwnProperty(style) || styles[style] !== version) {\n                    continue;\n                }\n                this.obj.style.removeProperty(style);\n            }\n        }\n    };\n    exports.StyleAttributeAccessor = __decorate([\n        targetObserver()\n    ], exports.StyleAttributeAccessor);\n    exports.StyleAttributeAccessor.prototype.styles = null;\n    exports.StyleAttributeAccessor.prototype.version = 0;\n    exports.StyleAttributeAccessor.prototype.propertyKey = 'style';\n    exports.ClassAttributeAccessor = class ClassAttributeAccessor {\n        constructor(lifecycle, obj) {\n            this.lifecycle = lifecycle;\n            this.obj = obj;\n        }\n        getValue() {\n            return this.currentValue;\n        }\n        setValueCore(newValue) {\n            const nameIndex = this.nameIndex || {};\n            let version = this.version;\n            let names;\n            let name;\n            // Add the classes, tracking the version at which they were added.\n            if (newValue.length) {\n                const node = this.obj;\n                names = newValue.split(/\\s+/);\n                for (let i = 0, length = names.length; i < length; i++) {\n                    name = names[i];\n                    if (!name.length) {\n                        continue;\n                    }\n                    nameIndex[name] = version;\n                    DOM.addClass(node, name);\n                }\n            }\n            // Update state variables.\n            this.nameIndex = nameIndex;\n            this.version += 1;\n            // First call to setValue?  We're done.\n            if (version === 0) {\n                return;\n            }\n            // Remove classes from previous version.\n            version -= 1;\n            for (name in nameIndex) {\n                if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {\n                    continue;\n                }\n                // TODO: this has the side-effect that classes already present which are added again,\n                // will be removed if they're not present in the next update.\n                // Better would be do have some configurability for this behavior, allowing the user to\n                // decide whether initial classes always need to be kept, always removed, or something in between\n                DOM.removeClass(this.obj, name);\n            }\n        }\n    };\n    exports.ClassAttributeAccessor = __decorate([\n        targetObserver('')\n    ], exports.ClassAttributeAccessor);\n    exports.ClassAttributeAccessor.prototype.doNotCache = true;\n    exports.ClassAttributeAccessor.prototype.version = 0;\n    exports.ClassAttributeAccessor.prototype.nameIndex = null;\n    exports.ElementPropertyAccessor = class ElementPropertyAccessor {\n        constructor(lifecycle, obj, propertyKey) {\n            this.lifecycle = lifecycle;\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n        }\n        getValue() {\n            return this.obj[this.propertyKey];\n        }\n        setValueCore(value) {\n            this.obj[this.propertyKey] = value;\n        }\n    };\n    exports.ElementPropertyAccessor = __decorate([\n        targetObserver('')\n    ], exports.ElementPropertyAccessor);\n    class PropertyAccessor {\n        constructor(obj, propertyKey) {\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n        }\n        getValue() {\n            return this.obj[this.propertyKey];\n        }\n        setValue(value) {\n            this.obj[this.propertyKey] = value;\n        }\n    }\n\n    exports.AttrBindingBehavior = class AttrBindingBehavior {\n        bind(flags, scope, binding) {\n            binding.targetObserver = new exports.DataAttributeAccessor(binding.locator.get(ILifecycle), binding.target, binding.targetProperty);\n        }\n        // tslint:disable-next-line:no-empty\n        unbind(flags, scope, binding) { }\n    };\n    exports.AttrBindingBehavior = __decorate([\n        bindingBehavior('attr')\n    ], exports.AttrBindingBehavior);\n\n    /*\n    * Note: the oneTime binding now has a non-zero value for 2 reasons:\n    *  - plays nicer with bitwise operations (more consistent code, more explicit settings)\n    *  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model\n    *\n    * Furthermore, the \"default\" mode would be for simple \".bind\" expressions to make it explicit for our logic that the default is being used.\n    * This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it\n    */\n    (function (BindingMode) {\n        BindingMode[BindingMode[\"oneTime\"] = 1] = \"oneTime\";\n        BindingMode[BindingMode[\"toView\"] = 2] = \"toView\";\n        BindingMode[BindingMode[\"fromView\"] = 4] = \"fromView\";\n        BindingMode[BindingMode[\"twoWay\"] = 6] = \"twoWay\";\n        BindingMode[BindingMode[\"default\"] = 8] = \"default\";\n    })(exports.BindingMode || (exports.BindingMode = {}));\n\n    const { oneTime, toView, fromView, twoWay } = exports.BindingMode;\n    class BindingModeBehavior {\n        constructor(mode) {\n            this.mode = mode;\n        }\n        bind(flags, scope, binding) {\n            binding.originalMode = binding.mode;\n            binding.mode = this.mode;\n        }\n        unbind(flags, scope, binding) {\n            binding.mode = binding.originalMode;\n            binding.originalMode = null;\n        }\n    }\n    exports.OneTimeBindingBehavior = class OneTimeBindingBehavior extends BindingModeBehavior {\n        constructor() {\n            super(oneTime);\n        }\n    };\n    exports.OneTimeBindingBehavior = __decorate([\n        bindingBehavior('oneTime')\n    ], exports.OneTimeBindingBehavior);\n    exports.ToViewBindingBehavior = class ToViewBindingBehavior extends BindingModeBehavior {\n        constructor() {\n            super(toView);\n        }\n    };\n    exports.ToViewBindingBehavior = __decorate([\n        bindingBehavior('toView')\n    ], exports.ToViewBindingBehavior);\n    exports.FromViewBindingBehavior = class FromViewBindingBehavior extends BindingModeBehavior {\n        constructor() {\n            super(fromView);\n        }\n    };\n    exports.FromViewBindingBehavior = __decorate([\n        bindingBehavior('fromView')\n    ], exports.FromViewBindingBehavior);\n    exports.TwoWayBindingBehavior = class TwoWayBindingBehavior extends BindingModeBehavior {\n        constructor() {\n            super(twoWay);\n        }\n    };\n    exports.TwoWayBindingBehavior = __decorate([\n        bindingBehavior('twoWay')\n    ], exports.TwoWayBindingBehavior);\n\n    const defineProperty = Reflect.defineProperty;\n    // note: we're reusing the same object for setting all descriptors, just changing some properties as needed\n    //   this works, because the properties are copied by defineProperty (so changing them afterwards doesn't affect existing descriptors)\n    // see also: https://tc39.github.io/ecma262/#sec-topropertydescriptor\n    const observedPropertyDescriptor = {\n        get: undefined,\n        set: undefined,\n        enumerable: true,\n        configurable: true\n    };\n    function subscribe(subscriber) {\n        if (this.observing === false) {\n            this.observing = true;\n            const { obj, propertyKey } = this;\n            this.currentValue = obj[propertyKey];\n            observedPropertyDescriptor.get = () => this.getValue();\n            observedPropertyDescriptor.set = value => { this.setValue(value, exports.LifecycleFlags.updateTargetInstance); };\n            if (!defineProperty(obj, propertyKey, observedPropertyDescriptor)) {\n                kernel.Reporter.write(1, propertyKey, obj);\n            }\n        }\n        this.addSubscriber(subscriber);\n    }\n    function dispose$1() {\n        delete this.obj[this.propertyKey];\n        this.obj = null;\n        this.propertyKey = null;\n        this.currentValue = null;\n    }\n    function propertyObserver() {\n        return function (target) {\n            subscriberCollection(exports.MutationKind.instance)(target);\n            const proto = target.prototype;\n            proto.observing = false;\n            proto.obj = null;\n            proto.propertyKey = null;\n            // Note: this will generate some \"false positive\" changes when setting a target undefined from a source undefined,\n            // but those aren't harmful because the changes won't be propagated through to subscribers during $bind anyway.\n            // It will, however, solve some \"false negative\" changes when the source value is undefined but the target value is not;\n            // in such cases, this.currentValue in the observer being undefined will block the change from propagating to the target.\n            // This is likely not working correctly in vCurrent either.\n            proto.currentValue = Symbol();\n            proto.subscribe = proto.subscribe || subscribe;\n            proto.unsubscribe = proto.unsubscribe || proto.removeSubscriber;\n            proto.dispose = proto.dispose || dispose$1;\n        };\n    }\n\n    const noop = kernel.PLATFORM.noop;\n    // note: string.length is the only property of any primitive that is not a function,\n    // so we can hardwire it to that and simply return undefined for anything else\n    // note#2: a modified primitive constructor prototype would not work (and really, it shouldn't..)\n    class PrimitiveObserver {\n        constructor(obj, propertyKey) {\n            this.doNotCache = true;\n            // we don't need to store propertyName because only 'length' can return a useful value\n            if (propertyKey === 'length') {\n                // deliberately not checking for typeof string as users probably still want to know via an error that their string is undefined\n                this.obj = obj;\n                this.getValue = this.getStringLength;\n            }\n            else {\n                this.getValue = this.returnUndefined;\n            }\n        }\n        getStringLength() {\n            return this.obj.length;\n        }\n        returnUndefined() {\n            return undefined;\n        }\n    }\n    PrimitiveObserver.prototype.setValue = noop;\n    PrimitiveObserver.prototype.subscribe = noop;\n    PrimitiveObserver.prototype.unsubscribe = noop;\n    PrimitiveObserver.prototype.dispose = noop;\n    exports.SetterObserver = class SetterObserver {\n        constructor(obj, propertyKey) {\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n        }\n        getValue() {\n            return this.currentValue;\n        }\n        setValue(newValue, flags) {\n            const currentValue = this.currentValue;\n            if (currentValue !== newValue) {\n                this.currentValue = newValue;\n                if (!(flags & exports.LifecycleFlags.fromBind)) {\n                    this.callSubscribers(newValue, currentValue, flags);\n                }\n                // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,\n                // so calling obj[propertyKey] will actually return this.currentValue.\n                // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor\n                // is unmodified and we need to explicitly set the property value.\n                // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.\n                // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.\n                if (!this.observing) {\n                    this.obj[this.propertyKey] = newValue;\n                }\n            }\n        }\n    };\n    exports.SetterObserver = __decorate([\n        propertyObserver()\n    ], exports.SetterObserver);\n    exports.Observer = class Observer {\n        constructor(instance, propertyName, callbackName) {\n            this.obj = instance;\n            this.propertyKey = propertyName;\n            this.currentValue = instance[propertyName];\n            this.callback = callbackName in instance\n                ? instance[callbackName].bind(instance)\n                : noop;\n        }\n        getValue() {\n            return this.currentValue;\n        }\n        setValue(newValue, flags) {\n            const currentValue = this.currentValue;\n            if (currentValue !== newValue) {\n                this.currentValue = newValue;\n                if (!(flags & exports.LifecycleFlags.fromBind)) {\n                    const coercedValue = this.callback(newValue, currentValue);\n                    if (coercedValue !== undefined) {\n                        this.currentValue = newValue = coercedValue;\n                    }\n                    this.callSubscribers(newValue, currentValue, flags);\n                }\n            }\n        }\n    };\n    exports.Observer = __decorate([\n        propertyObserver()\n    ], exports.Observer);\n\n    /*@internal*/\n    class InternalObserversLookup {\n        getOrCreate(obj, key) {\n            let observer = this[key];\n            if (observer === undefined) {\n                observer = this[key] = new exports.SetterObserver(obj, key);\n            }\n            return observer;\n        }\n    }\n    class BindingContext {\n        constructor(keyOrObj, value) {\n            this.$synthetic = true;\n            if (keyOrObj !== undefined) {\n                if (value !== undefined) {\n                    // if value is defined then it's just a property and a value to initialize with\n                    // tslint:disable-next-line:no-any\n                    this[keyOrObj] = value;\n                }\n                else {\n                    // can either be some random object or another bindingContext to clone from\n                    for (const prop in keyOrObj) {\n                        if (keyOrObj.hasOwnProperty(prop)) {\n                            this[prop] = keyOrObj[prop];\n                        }\n                    }\n                }\n            }\n        }\n        static create(keyOrObj, value) {\n            return new BindingContext(keyOrObj, value);\n        }\n        // tslint:disable-next-line:no-reserved-keywords\n        static get(scope, name, ancestor) {\n            if (scope === undefined) {\n                throw kernel.Reporter.error(250 /* UndefinedScope */);\n            }\n            if (scope === null) {\n                throw kernel.Reporter.error(251 /* NullScope */);\n            }\n            let overrideContext = scope.overrideContext;\n            if (ancestor > 0) {\n                // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)\n                while (ancestor > 0) {\n                    if (overrideContext.parentOverrideContext === null) {\n                        return undefined;\n                    }\n                    ancestor--;\n                    overrideContext = overrideContext.parentOverrideContext;\n                }\n                return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n            }\n            // traverse the context and it's ancestors, searching for a context that has the name.\n            while (overrideContext && !(name in overrideContext) && !(overrideContext.bindingContext && name in overrideContext.bindingContext)) {\n                overrideContext = overrideContext.parentOverrideContext;\n            }\n            if (overrideContext) {\n                // we located a context with the property.  return it.\n                return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n            }\n            // the name wasn't found.  return the root binding context.\n            return scope.bindingContext || scope.overrideContext;\n        }\n        getObservers() {\n            let observers = this.$observers;\n            if (observers === undefined) {\n                this.$observers = observers = new InternalObserversLookup();\n            }\n            return observers;\n        }\n    }\n    class Scope {\n        constructor(bindingContext, overrideContext) {\n            this.bindingContext = bindingContext;\n            this.overrideContext = overrideContext;\n        }\n        static create(bc, oc) {\n            return new Scope(bc, oc === null || oc === undefined ? OverrideContext.create(bc, oc) : oc);\n        }\n        static fromOverride(oc) {\n            if (oc === null || oc === undefined) {\n                throw kernel.Reporter.error(252 /* NilOverrideContext */);\n            }\n            return new Scope(oc.bindingContext, oc);\n        }\n        static fromParent(ps, bc) {\n            if (ps === null || ps === undefined) {\n                throw kernel.Reporter.error(253 /* NilParentScope */);\n            }\n            return new Scope(bc, OverrideContext.create(bc, ps.overrideContext));\n        }\n    }\n    class OverrideContext {\n        constructor(bindingContext, parentOverrideContext) {\n            this.bindingContext = bindingContext;\n            this.parentOverrideContext = parentOverrideContext;\n            this.$synthetic = true;\n        }\n        static create(bc, poc) {\n            return new OverrideContext(bc, poc === undefined ? null : poc);\n        }\n        getObservers() {\n            let observers = this.$observers;\n            if (observers === undefined) {\n                this.$observers = observers = new InternalObserversLookup();\n            }\n            return observers;\n        }\n    }\n\n    const ISignaler = kernel.DI.createInterface().withDefault(x => x.singleton(Signaler));\n    /*@internal*/\n    class Signaler {\n        constructor() {\n            this.signals = Object.create(null);\n        }\n        dispatchSignal(name, flags) {\n            const listeners = this.signals[name];\n            if (listeners === undefined) {\n                return;\n            }\n            for (const listener of listeners.keys()) {\n                listener.handleChange(undefined, undefined, flags | exports.LifecycleFlags.updateTargetInstance);\n            }\n        }\n        addSignalListener(name, listener) {\n            const signals = this.signals;\n            const listeners = signals[name];\n            if (listeners === undefined) {\n                signals[name] = new Set([listener]);\n            }\n            else {\n                listeners.add(listener);\n            }\n        }\n        removeSignalListener(name, listener) {\n            const listeners = this.signals[name];\n            if (listeners) {\n                listeners.delete(listener);\n            }\n        }\n    }\n\n    function valueConverter(nameOrSource) {\n        return function (target) {\n            return ValueConverterResource.define(nameOrSource, target);\n        };\n    }\n    const ValueConverterResource = {\n        name: 'value-converter',\n        keyFrom(name) {\n            return `${this.name}:${name}`;\n        },\n        isType(Type) {\n            return Type.kind === this;\n        },\n        define(nameOrSource, ctor) {\n            const Type = ctor;\n            const description = typeof nameOrSource === 'string'\n                ? { name: nameOrSource }\n                : nameOrSource;\n            Type.kind = ValueConverterResource;\n            Type.description = description;\n            Type.register = register$1;\n            return Type;\n        }\n    };\n    function register$1(container) {\n        container.register(kernel.Registration.singleton(ValueConverterResource.keyFrom(this.description.name), this));\n    }\n\n    function connects(expr) {\n        return (expr.$kind & 32 /* Connects */) === 32 /* Connects */;\n    }\n    function observes(expr) {\n        return (expr.$kind & 64 /* Observes */) === 64 /* Observes */;\n    }\n    function callsFunction(expr) {\n        return (expr.$kind & 128 /* CallsFunction */) === 128 /* CallsFunction */;\n    }\n    function hasAncestor(expr) {\n        return (expr.$kind & 256 /* HasAncestor */) === 256 /* HasAncestor */;\n    }\n    function isAssignable(expr) {\n        return (expr.$kind & 8192 /* IsAssignable */) === 8192 /* IsAssignable */;\n    }\n    function isLeftHandSide(expr) {\n        return (expr.$kind & 1024 /* IsLeftHandSide */) === 1024 /* IsLeftHandSide */;\n    }\n    function isPrimary(expr) {\n        return (expr.$kind & 512 /* IsPrimary */) === 512 /* IsPrimary */;\n    }\n    function isResource(expr) {\n        return (expr.$kind & 32768 /* IsResource */) === 32768 /* IsResource */;\n    }\n    function hasBind(expr) {\n        return (expr.$kind & 2048 /* HasBind */) === 2048 /* HasBind */;\n    }\n    function hasUnbind(expr) {\n        return (expr.$kind & 4096 /* HasUnbind */) === 4096 /* HasUnbind */;\n    }\n    function isLiteral(expr) {\n        return (expr.$kind & 16384 /* IsLiteral */) === 16384 /* IsLiteral */;\n    }\n    function arePureLiterals(expressions) {\n        if (expressions === undefined || expressions.length === 0) {\n            return true;\n        }\n        for (let i = 0; i < expressions.length; ++i) {\n            if (!isPureLiteral(expressions[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function isPureLiteral(expr) {\n        if (isLiteral(expr)) {\n            switch (expr.$kind) {\n                case 17955 /* ArrayLiteral */:\n                    return arePureLiterals(expr.elements);\n                case 17956 /* ObjectLiteral */:\n                    return arePureLiterals(expr.values);\n                case 17958 /* Template */:\n                    return arePureLiterals(expr.expressions);\n                case 17925 /* PrimitiveLiteral */:\n                    return true;\n            }\n        }\n        return false;\n    }\n    class BindingBehavior {\n        constructor(expression, name, args) {\n            this.expression = expression;\n            this.name = name;\n            this.args = args;\n            this.behaviorKey = BindingBehaviorResource.keyFrom(this.name);\n            this.expressionHasBind = hasBind(expression);\n            this.expressionHasUnbind = hasUnbind(expression);\n        }\n        evaluate(flags, scope, locator) {\n            return this.expression.evaluate(flags, scope, locator);\n        }\n        assign(flags, scope, locator, value) {\n            return this.expression.assign(flags, scope, locator, value);\n        }\n        connect(flags, scope, binding) {\n            this.expression.connect(flags, scope, binding);\n        }\n        bind(flags, scope, binding) {\n            if (scope === undefined) {\n                throw kernel.Reporter.error(250 /* UndefinedScope */, this);\n            }\n            if (scope === null) {\n                throw kernel.Reporter.error(251 /* NullScope */, this);\n            }\n            if (!binding) {\n                throw kernel.Reporter.error(206 /* NoBinding */, this);\n            }\n            const locator = binding.locator;\n            if (!locator) {\n                throw kernel.Reporter.error(202 /* NoLocator */, this);\n            }\n            if (this.expressionHasBind) {\n                this.expression.bind(flags, scope, binding);\n            }\n            const behaviorKey = this.behaviorKey;\n            const behavior = locator.get(behaviorKey);\n            if (!behavior) {\n                throw kernel.Reporter.error(203 /* NoBehaviorFound */, this);\n            }\n            if (binding[behaviorKey] !== undefined && binding[behaviorKey] !== null) {\n                throw kernel.Reporter.error(204 /* BehaviorAlreadyApplied */, this);\n            }\n            binding[behaviorKey] = behavior;\n            behavior.bind.apply(behavior, [flags, scope, binding].concat(evalList(flags, scope, locator, this.args)));\n        }\n        unbind(flags, scope, binding) {\n            const behaviorKey = this.behaviorKey;\n            binding[behaviorKey].unbind(flags, scope, binding);\n            binding[behaviorKey] = null;\n            if (this.expressionHasUnbind) {\n                this.expression.unbind(flags, scope, binding);\n            }\n        }\n        accept(visitor) {\n            return visitor.visitBindingBehavior(this);\n        }\n    }\n    class ValueConverter {\n        constructor(expression, name, args) {\n            this.expression = expression;\n            this.name = name;\n            this.args = args;\n            this.converterKey = ValueConverterResource.keyFrom(this.name);\n        }\n        evaluate(flags, scope, locator) {\n            if (!locator) {\n                throw kernel.Reporter.error(202 /* NoLocator */, this);\n            }\n            const converter = locator.get(this.converterKey);\n            if (!converter) {\n                throw kernel.Reporter.error(205 /* NoConverterFound */, this);\n            }\n            if ('toView' in converter) {\n                const args = this.args;\n                const len = args.length;\n                const result = Array(len + 1);\n                result[0] = this.expression.evaluate(flags, scope, locator);\n                for (let i = 0; i < len; ++i) {\n                    result[i + 1] = args[i].evaluate(flags, scope, locator);\n                }\n                return converter.toView.apply(converter, result);\n            }\n            return this.expression.evaluate(flags, scope, locator);\n        }\n        assign(flags, scope, locator, value) {\n            if (!locator) {\n                throw kernel.Reporter.error(202 /* NoLocator */, this);\n            }\n            const converter = locator.get(this.converterKey);\n            if (!converter) {\n                throw kernel.Reporter.error(205 /* NoConverterFound */, this);\n            }\n            if ('fromView' in converter) {\n                value = converter.fromView.apply(converter, [value].concat(evalList(flags, scope, locator, this.args)));\n            }\n            return this.expression.assign(flags, scope, locator, value);\n        }\n        connect(flags, scope, binding) {\n            if (scope === undefined) {\n                throw kernel.Reporter.error(250 /* UndefinedScope */, this);\n            }\n            if (scope === null) {\n                throw kernel.Reporter.error(251 /* NullScope */, this);\n            }\n            if (!binding) {\n                throw kernel.Reporter.error(206 /* NoBinding */, this);\n            }\n            const locator = binding.locator;\n            if (!locator) {\n                throw kernel.Reporter.error(202 /* NoLocator */, this);\n            }\n            this.expression.connect(flags, scope, binding);\n            const args = this.args;\n            for (let i = 0, ii = args.length; i < ii; ++i) {\n                args[i].connect(flags, scope, binding);\n            }\n            const converter = locator.get(this.converterKey);\n            if (!converter) {\n                throw kernel.Reporter.error(205 /* NoConverterFound */, this);\n            }\n            const signals = converter.signals;\n            if (signals === undefined) {\n                return;\n            }\n            const signaler = locator.get(ISignaler);\n            for (let i = 0, ii = signals.length; i < ii; ++i) {\n                signaler.addSignalListener(signals[i], binding);\n            }\n        }\n        unbind(flags, scope, binding) {\n            const locator = binding.locator;\n            const converter = locator.get(this.converterKey);\n            const signals = converter.signals;\n            if (signals === undefined) {\n                return;\n            }\n            const signaler = locator.get(ISignaler);\n            for (let i = 0, ii = signals.length; i < ii; ++i) {\n                signaler.removeSignalListener(signals[i], binding);\n            }\n        }\n        accept(visitor) {\n            return visitor.visitValueConverter(this);\n        }\n    }\n    class Assign {\n        constructor(target, value) {\n            this.target = target;\n            this.value = value;\n        }\n        evaluate(flags, scope, locator) {\n            return this.target.assign(flags, scope, locator, this.value.evaluate(flags, scope, locator));\n        }\n        connect(flags, scope, binding) {\n            return;\n        }\n        assign(flags, scope, locator, value) {\n            this.value.assign(flags, scope, locator, value);\n            return this.target.assign(flags, scope, locator, value);\n        }\n        accept(visitor) {\n            return visitor.visitAssign(this);\n        }\n    }\n    class Conditional {\n        constructor(condition, yes, no) {\n            this.condition = condition;\n            this.yes = yes;\n            this.no = no;\n        }\n        evaluate(flags, scope, locator) {\n            return (!!this.condition.evaluate(flags, scope, locator))\n                ? this.yes.evaluate(flags, scope, locator)\n                : this.no.evaluate(flags, scope, locator);\n        }\n        connect(flags, scope, binding) {\n            const condition = this.condition;\n            if (condition.evaluate(flags, scope, null)) {\n                this.condition.connect(flags, scope, binding);\n                this.yes.connect(flags, scope, binding);\n            }\n            else {\n                this.condition.connect(flags, scope, binding);\n                this.no.connect(flags, scope, binding);\n            }\n        }\n        accept(visitor) {\n            return visitor.visitConditional(this);\n        }\n    }\n    class AccessThis {\n        constructor(ancestor = 0) {\n            this.ancestor = ancestor;\n        }\n        evaluate(flags, scope, locator) {\n            if (scope === undefined) {\n                throw kernel.Reporter.error(250 /* UndefinedScope */, this);\n            }\n            if (scope === null) {\n                throw kernel.Reporter.error(251 /* NullScope */, this);\n            }\n            let oc = scope.overrideContext;\n            let i = this.ancestor;\n            while (i-- && oc) {\n                oc = oc.parentOverrideContext;\n            }\n            return i < 1 && oc ? oc.bindingContext : undefined;\n        }\n        accept(visitor) {\n            return visitor.visitAccessThis(this);\n        }\n    }\n    AccessThis.$this = new AccessThis(0);\n    AccessThis.$parent = new AccessThis(1);\n    class AccessScope {\n        constructor(name, ancestor = 0) {\n            this.name = name;\n            this.ancestor = ancestor;\n        }\n        evaluate(flags, scope, locator) {\n            const name = this.name;\n            return BindingContext.get(scope, name, this.ancestor)[name];\n        }\n        assign(flags, scope, locator, value) {\n            const name = this.name;\n            const context = BindingContext.get(scope, name, this.ancestor);\n            return context ? (context[name] = value) : undefined;\n        }\n        connect(flags, scope, binding) {\n            const name = this.name;\n            const context = BindingContext.get(scope, name, this.ancestor);\n            binding.observeProperty(context, name);\n        }\n        accept(visitor) {\n            return visitor.visitAccessScope(this);\n        }\n    }\n    class AccessMember {\n        constructor(object, name) {\n            this.object = object;\n            this.name = name;\n        }\n        evaluate(flags, scope, locator) {\n            const instance = this.object.evaluate(flags, scope, locator);\n            return instance === null || instance === undefined ? instance : instance[this.name];\n        }\n        assign(flags, scope, locator, value) {\n            let instance = this.object.evaluate(flags, scope, locator);\n            if (instance === null || typeof instance !== 'object') {\n                instance = {};\n                this.object.assign(flags, scope, locator, instance);\n            }\n            instance[this.name] = value;\n            return value;\n        }\n        connect(flags, scope, binding) {\n            const obj = this.object.evaluate(flags, scope, null);\n            this.object.connect(flags, scope, binding);\n            if (obj) {\n                binding.observeProperty(obj, this.name);\n            }\n        }\n        accept(visitor) {\n            return visitor.visitAccessMember(this);\n        }\n    }\n    class AccessKeyed {\n        constructor(object, key) {\n            this.object = object;\n            this.key = key;\n        }\n        evaluate(flags, scope, locator) {\n            const instance = this.object.evaluate(flags, scope, locator);\n            if (instance === null || instance === undefined) {\n                return undefined;\n            }\n            const key = this.key.evaluate(flags, scope, locator);\n            // note: getKeyed and setKeyed are removed because they are identical to the default spec behavior\n            // and the runtime does this this faster\n            // tslint:disable-next-line:no-any\n            return instance[key];\n        }\n        assign(flags, scope, locator, value) {\n            const instance = this.object.evaluate(flags, scope, locator);\n            const key = this.key.evaluate(flags, scope, locator);\n            // tslint:disable-next-line:no-any\n            return instance[key] = value;\n        }\n        connect(flags, scope, binding) {\n            const obj = this.object.evaluate(flags, scope, null);\n            this.object.connect(flags, scope, binding);\n            if (typeof obj === 'object' && obj !== null) {\n                this.key.connect(flags, scope, binding);\n                const key = this.key.evaluate(flags, scope, null);\n                // observe the property represented by the key as long as it's not an array indexer\n                // (note: string indexers behave the same way as numeric indexers as long as they represent numbers)\n                if (!(Array.isArray(obj) && isNumeric(key))) {\n                    binding.observeProperty(obj, key);\n                }\n            }\n        }\n        accept(visitor) {\n            return visitor.visitAccessKeyed(this);\n        }\n    }\n    class CallScope {\n        constructor(name, args, ancestor = 0) {\n            this.name = name;\n            this.args = args;\n            this.ancestor = ancestor;\n        }\n        evaluate(flags, scope, locator) {\n            const args = evalList(flags, scope, locator, this.args);\n            const context = BindingContext.get(scope, this.name, this.ancestor);\n            const func = getFunction(flags, context, this.name);\n            if (func) {\n                return func.apply(context, args);\n            }\n            return undefined;\n        }\n        connect(flags, scope, binding) {\n            const args = this.args;\n            for (let i = 0, ii = args.length; i < ii; ++i) {\n                args[i].connect(flags, scope, binding);\n            }\n        }\n        accept(visitor) {\n            return visitor.visitCallScope(this);\n        }\n    }\n    class CallMember {\n        constructor(object, name, args) {\n            this.object = object;\n            this.name = name;\n            this.args = args;\n        }\n        evaluate(flags, scope, locator) {\n            const instance = this.object.evaluate(flags, scope, locator);\n            const args = evalList(flags, scope, locator, this.args);\n            const func = getFunction(flags, instance, this.name);\n            if (func) {\n                return func.apply(instance, args);\n            }\n            return undefined;\n        }\n        connect(flags, scope, binding) {\n            const obj = this.object.evaluate(flags, scope, null);\n            this.object.connect(flags, scope, binding);\n            if (getFunction(flags & ~exports.LifecycleFlags.mustEvaluate, obj, this.name)) {\n                const args = this.args;\n                for (let i = 0, ii = args.length; i < ii; ++i) {\n                    args[i].connect(flags, scope, binding);\n                }\n            }\n        }\n        accept(visitor) {\n            return visitor.visitCallMember(this);\n        }\n    }\n    class CallFunction {\n        constructor(func, args) {\n            this.func = func;\n            this.args = args;\n        }\n        evaluate(flags, scope, locator) {\n            const func = this.func.evaluate(flags, scope, locator); // not sure why this cast is needed..\n            if (typeof func === 'function') {\n                return func.apply(null, evalList(flags, scope, locator, this.args));\n            }\n            if (!(flags & exports.LifecycleFlags.mustEvaluate) && (func === null || func === undefined)) {\n                return undefined;\n            }\n            throw kernel.Reporter.error(207 /* NotAFunction */, this);\n        }\n        connect(flags, scope, binding) {\n            const func = this.func.evaluate(flags, scope, null);\n            this.func.connect(flags, scope, binding);\n            if (typeof func === 'function') {\n                const args = this.args;\n                for (let i = 0, ii = args.length; i < ii; ++i) {\n                    args[i].connect(flags, scope, binding);\n                }\n            }\n        }\n        accept(visitor) {\n            return visitor.visitCallFunction(this);\n        }\n    }\n    class Binary {\n        constructor(operation, left, right) {\n            this.operation = operation;\n            this.left = left;\n            this.right = right;\n            // what we're doing here is effectively moving the large switch statement from evaluate to the constructor\n            // so that the check only needs to be done once, and evaluate (which is called many times) will have a lot less\n            // work to do; we can do this because the operation can't change after it's parsed\n            this.evaluate = this[operation];\n        }\n        evaluate(flags, scope, locator) {\n            throw kernel.Reporter.error(208 /* UnknownOperator */, this);\n        }\n        connect(flags, scope, binding) {\n            const left = this.left.evaluate(flags, scope, null);\n            this.left.connect(flags, scope, binding);\n            if (this.operation === '&&' && !left || this.operation === '||' && left) {\n                return;\n            }\n            this.right.connect(flags, scope, binding);\n        }\n        ['&&'](f, s, l) {\n            return this.left.evaluate(f, s, l) && this.right.evaluate(f, s, l);\n        }\n        ['||'](f, s, l) {\n            return this.left.evaluate(f, s, l) || this.right.evaluate(f, s, l);\n        }\n        ['=='](f, s, l) {\n            // tslint:disable-next-line:triple-equals\n            return this.left.evaluate(f, s, l) == this.right.evaluate(f, s, l);\n        }\n        ['==='](f, s, l) {\n            return this.left.evaluate(f, s, l) === this.right.evaluate(f, s, l);\n        }\n        ['!='](f, s, l) {\n            // tslint:disable-next-line:triple-equals\n            return this.left.evaluate(f, s, l) != this.right.evaluate(f, s, l);\n        }\n        ['!=='](f, s, l) {\n            return this.left.evaluate(f, s, l) !== this.right.evaluate(f, s, l);\n        }\n        ['instanceof'](f, s, l) {\n            const right = this.right.evaluate(f, s, l);\n            if (typeof right === 'function') {\n                return this.left.evaluate(f, s, l) instanceof right;\n            }\n            return false;\n        }\n        ['in'](f, s, l) {\n            const right = this.right.evaluate(f, s, l);\n            if (right !== null && typeof right === 'object') {\n                return this.left.evaluate(f, s, l) in right;\n            }\n            return false;\n        }\n        // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar\n        // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)\n        // this makes bugs in user code easier to track down for end users\n        // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code\n        ['+'](f, s, l) {\n            // tslint:disable-next-line:no-any\n            return this.left.evaluate(f, s, l) + this.right.evaluate(f, s, l);\n        }\n        ['-'](f, s, l) {\n            // tslint:disable-next-line:no-any\n            return this.left.evaluate(f, s, l) - this.right.evaluate(f, s, l);\n        }\n        ['*'](f, s, l) {\n            // tslint:disable-next-line:no-any\n            return this.left.evaluate(f, s, l) * this.right.evaluate(f, s, l);\n        }\n        ['/'](f, s, l) {\n            // tslint:disable-next-line:no-any\n            return this.left.evaluate(f, s, l) / this.right.evaluate(f, s, l);\n        }\n        ['%'](f, s, l) {\n            // tslint:disable-next-line:no-any\n            return this.left.evaluate(f, s, l) % this.right.evaluate(f, s, l);\n        }\n        ['<'](f, s, l) {\n            return this.left.evaluate(f, s, l) < this.right.evaluate(f, s, l);\n        }\n        ['>'](f, s, l) {\n            return this.left.evaluate(f, s, l) > this.right.evaluate(f, s, l);\n        }\n        ['<='](f, s, l) {\n            return this.left.evaluate(f, s, l) <= this.right.evaluate(f, s, l);\n        }\n        ['>='](f, s, l) {\n            return this.left.evaluate(f, s, l) >= this.right.evaluate(f, s, l);\n        }\n        // tslint:disable-next-line:member-ordering\n        accept(visitor) {\n            return visitor.visitBinary(this);\n        }\n    }\n    class Unary {\n        constructor(operation, expression) {\n            this.operation = operation;\n            this.expression = expression;\n            // see Binary (we're doing the same thing here)\n            // tslint:disable-next-line:no-any\n            this.evaluate = this[operation];\n        }\n        evaluate(flags, scope, locator) {\n            throw kernel.Reporter.error(208 /* UnknownOperator */, this);\n        }\n        connect(flags, scope, binding) {\n            this.expression.connect(flags, scope, binding);\n        }\n        ['void'](f, s, l) {\n            return void this.expression.evaluate(f, s, l);\n        }\n        ['typeof'](f, s, l) {\n            return typeof this.expression.evaluate(f, s, l);\n        }\n        ['!'](f, s, l) {\n            return !this.expression.evaluate(f, s, l);\n        }\n        ['-'](f, s, l) {\n            return -this.expression.evaluate(f, s, l);\n        }\n        ['+'](f, s, l) {\n            return +this.expression.evaluate(f, s, l);\n        }\n        // tslint:disable-next-line:member-ordering\n        accept(visitor) {\n            return visitor.visitUnary(this);\n        }\n    }\n    class PrimitiveLiteral {\n        constructor(value) {\n            this.value = value;\n        }\n        evaluate(flags, scope, locator) {\n            return this.value;\n        }\n        accept(visitor) {\n            return visitor.visitPrimitiveLiteral(this);\n        }\n    }\n    PrimitiveLiteral.$undefined = new PrimitiveLiteral(undefined);\n    PrimitiveLiteral.$null = new PrimitiveLiteral(null);\n    PrimitiveLiteral.$true = new PrimitiveLiteral(true);\n    PrimitiveLiteral.$false = new PrimitiveLiteral(false);\n    PrimitiveLiteral.$empty = new PrimitiveLiteral('');\n    class HtmlLiteral {\n        constructor(parts) {\n            this.parts = parts;\n        }\n        evaluate(flags, scope, locator) {\n            const elements = this.parts;\n            let result = '';\n            for (let i = 0, ii = elements.length; i < ii; ++i) {\n                const value = elements[i].evaluate(flags, scope, locator);\n                if (value === undefined || value === null) {\n                    continue;\n                }\n                result += value;\n            }\n            return result;\n        }\n        connect(flags, scope, binding) {\n            for (let i = 0, ii = this.parts.length; i < ii; ++i) {\n                this.parts[i].connect(flags, scope, binding);\n            }\n        }\n        accept(visitor) {\n            return visitor.visitHtmlLiteral(this);\n        }\n    }\n    class ArrayLiteral {\n        constructor(elements) {\n            this.elements = elements;\n        }\n        evaluate(flags, scope, locator) {\n            const elements = this.elements;\n            const length = elements.length;\n            const result = Array(length);\n            for (let i = 0; i < length; ++i) {\n                result[i] = elements[i].evaluate(flags, scope, locator);\n            }\n            return result;\n        }\n        connect(flags, scope, binding) {\n            const elements = this.elements;\n            for (let i = 0, ii = elements.length; i < ii; ++i) {\n                elements[i].connect(flags, scope, binding);\n            }\n        }\n        accept(visitor) {\n            return visitor.visitArrayLiteral(this);\n        }\n    }\n    ArrayLiteral.$empty = new ArrayLiteral(kernel.PLATFORM.emptyArray);\n    class ObjectLiteral {\n        constructor(keys, values) {\n            this.keys = keys;\n            this.values = values;\n        }\n        evaluate(flags, scope, locator) {\n            const instance = {};\n            const keys = this.keys;\n            const values = this.values;\n            for (let i = 0, ii = keys.length; i < ii; ++i) {\n                instance[keys[i]] = values[i].evaluate(flags, scope, locator);\n            }\n            return instance;\n        }\n        connect(flags, scope, binding) {\n            const keys = this.keys;\n            const values = this.values;\n            for (let i = 0, ii = keys.length; i < ii; ++i) {\n                values[i].connect(flags, scope, binding);\n            }\n        }\n        accept(visitor) {\n            return visitor.visitObjectLiteral(this);\n        }\n    }\n    ObjectLiteral.$empty = new ObjectLiteral(kernel.PLATFORM.emptyArray, kernel.PLATFORM.emptyArray);\n    class Template {\n        constructor(cooked, expressions) {\n            this.cooked = cooked;\n            this.expressions = expressions;\n            this.expressions = expressions || kernel.PLATFORM.emptyArray;\n        }\n        evaluate(flags, scope, locator) {\n            const expressions = this.expressions;\n            const cooked = this.cooked;\n            let result = cooked[0];\n            for (let i = 0, ii = expressions.length; i < ii; ++i) {\n                result += expressions[i].evaluate(flags, scope, locator);\n                result += cooked[i + 1];\n            }\n            return result;\n        }\n        connect(flags, scope, binding) {\n            const expressions = this.expressions;\n            for (let i = 0, ii = expressions.length; i < ii; ++i) {\n                expressions[i].connect(flags, scope, binding);\n                i++;\n            }\n        }\n        accept(visitor) {\n            return visitor.visitTemplate(this);\n        }\n    }\n    Template.$empty = new Template(['']);\n    class TaggedTemplate {\n        constructor(cooked, raw, func, expressions) {\n            this.cooked = cooked;\n            this.func = func;\n            this.expressions = expressions;\n            cooked.raw = raw;\n            this.expressions = expressions || kernel.PLATFORM.emptyArray;\n        }\n        evaluate(flags, scope, locator) {\n            const expressions = this.expressions;\n            const len = expressions.length;\n            const results = Array(len);\n            for (let i = 0, ii = len; i < ii; ++i) {\n                results[i] = expressions[i].evaluate(flags, scope, locator);\n            }\n            const func = this.func.evaluate(flags, scope, locator); // not sure why this cast is needed..\n            if (typeof func !== 'function') {\n                throw kernel.Reporter.error(207 /* NotAFunction */, this);\n            }\n            return func.apply(null, [this.cooked].concat(results));\n        }\n        connect(flags, scope, binding) {\n            const expressions = this.expressions;\n            for (let i = 0, ii = expressions.length; i < ii; ++i) {\n                expressions[i].connect(flags, scope, binding);\n            }\n            this.func.connect(flags, scope, binding);\n        }\n        accept(visitor) {\n            return visitor.visitTaggedTemplate(this);\n        }\n    }\n    class ArrayBindingPattern {\n        // We'll either have elements, or keys+values, but never all 3\n        constructor(elements) {\n            this.elements = elements;\n        }\n        // tslint:disable-next-line:no-any\n        evaluate(flags, scope, locator) {\n            // TODO\n        }\n        // tslint:disable-next-line:no-any\n        assign(flags, scope, locator, obj) {\n            // TODO\n        }\n        connect(flags, scope, binding) {\n            return;\n        }\n        accept(visitor) {\n            return visitor.visitArrayBindingPattern(this);\n        }\n    }\n    class ObjectBindingPattern {\n        // We'll either have elements, or keys+values, but never all 3\n        constructor(keys, values) {\n            this.keys = keys;\n            this.values = values;\n        }\n        // tslint:disable-next-line:no-any\n        evaluate(flags, scope, locator) {\n            // TODO\n        }\n        // tslint:disable-next-line:no-any\n        assign(flags, scope, locator, obj) {\n            // TODO\n        }\n        connect(flags, scope, binding) {\n            return;\n        }\n        accept(visitor) {\n            return visitor.visitObjectBindingPattern(this);\n        }\n    }\n    class BindingIdentifier {\n        constructor(name) {\n            this.name = name;\n        }\n        evaluate(flags, scope, locator) {\n            return this.name;\n        }\n        connect(flags, scope, binding) {\n            return;\n        }\n        accept(visitor) {\n            return visitor.visitBindingIdentifier(this);\n        }\n    }\n    const toStringTag = Object.prototype.toString;\n    // https://tc39.github.io/ecma262/#sec-iteration-statements\n    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\n    class ForOfStatement {\n        constructor(declaration, iterable) {\n            this.declaration = declaration;\n            this.iterable = iterable;\n        }\n        evaluate(flags, scope, locator) {\n            return this.iterable.evaluate(flags, scope, locator);\n        }\n        count(result) {\n            return CountForOfStatement[toStringTag.call(result)](result);\n        }\n        // tslint:disable-next-line:no-any\n        iterate(result, func) {\n            IterateForOfStatement[toStringTag.call(result)](result, func);\n        }\n        connect(flags, scope, binding) {\n            this.declaration.connect(flags, scope, binding);\n            this.iterable.connect(flags, scope, binding);\n        }\n        accept(visitor) {\n            return visitor.visitForOfStatement(this);\n        }\n    }\n    /*\n    * Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)\n    * so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction\n    * but this class might be a candidate for removal if it turns out it does provide all we need\n    */\n    class Interpolation {\n        constructor(parts, expressions) {\n            this.parts = parts;\n            this.expressions = expressions;\n            this.isMulti = expressions.length > 1;\n            this.firstExpression = expressions[0];\n        }\n        evaluate(flags, scope, locator) {\n            if (this.isMulti) {\n                const expressions = this.expressions;\n                const parts = this.parts;\n                let result = parts[0];\n                for (let i = 0, ii = expressions.length; i < ii; ++i) {\n                    result += expressions[i].evaluate(flags, scope, locator);\n                    result += parts[i + 1];\n                }\n                return result;\n            }\n            else {\n                const parts = this.parts;\n                return parts[0] + this.firstExpression.evaluate(flags, scope, locator) + parts[1];\n            }\n        }\n        connect(flags, scope, binding) {\n            return;\n        }\n        accept(visitor) {\n            return visitor.visitInterpolation(this);\n        }\n    }\n    /*\n    * Note: for a property that is always the same, directly assigning it to the prototype is more efficient CPU wise\n    * (gets assigned once, instead of per constructor call) as well as memory wise (stored once, instead of per instance)\n    *\n    * This gives us a cheap way to add some extra information to the AST for the runtime to do things more efficiently.\n    */\n    BindingBehavior.prototype.$kind = 38962 /* BindingBehavior */;\n    ValueConverter.prototype.$kind = 36913 /* ValueConverter */;\n    Assign.prototype.$kind = 8208 /* Assign */;\n    Conditional.prototype.$kind = 63 /* Conditional */;\n    AccessThis.prototype.$kind = 1793 /* AccessThis */;\n    AccessScope.prototype.$kind = 10082 /* AccessScope */;\n    AccessMember.prototype.$kind = 9323 /* AccessMember */;\n    AccessKeyed.prototype.$kind = 9324 /* AccessKeyed */;\n    CallScope.prototype.$kind = 1448 /* CallScope */;\n    CallMember.prototype.$kind = 1161 /* CallMember */;\n    CallFunction.prototype.$kind = 1162 /* CallFunction */;\n    Binary.prototype.$kind = 46 /* Binary */;\n    Unary.prototype.$kind = 39 /* Unary */;\n    PrimitiveLiteral.prototype.$kind = 17925 /* PrimitiveLiteral */;\n    HtmlLiteral.prototype.$kind = 51 /* HtmlLiteral */;\n    ArrayLiteral.prototype.$kind = 17955 /* ArrayLiteral */;\n    ObjectLiteral.prototype.$kind = 17956 /* ObjectLiteral */;\n    Template.prototype.$kind = 17958 /* Template */;\n    TaggedTemplate.prototype.$kind = 1197 /* TaggedTemplate */;\n    ArrayBindingPattern.prototype.$kind = 65556 /* ArrayBindingPattern */;\n    ObjectBindingPattern.prototype.$kind = 65557 /* ObjectBindingPattern */;\n    BindingIdentifier.prototype.$kind = 65558 /* BindingIdentifier */;\n    ForOfStatement.prototype.$kind = 55 /* ForOfStatement */;\n    Interpolation.prototype.$kind = 24 /* Interpolation */;\n    /// Evaluate the [list] in context of the [scope].\n    function evalList(flags, scope, locator, list) {\n        const len = list.length;\n        const result = Array(len);\n        for (let i = 0; i < len; ++i) {\n            result[i] = list[i].evaluate(flags, scope, locator);\n        }\n        return result;\n    }\n    function getFunction(flags, obj, name) {\n        const func = obj === null || obj === undefined ? null : obj[name];\n        if (typeof func === 'function') {\n            return func;\n        }\n        if (!(flags & exports.LifecycleFlags.mustEvaluate) && (func === null || func === undefined)) {\n            return null;\n        }\n        throw kernel.Reporter.error(207 /* NotAFunction */, obj, name, func);\n    }\n    function isNumeric(value) {\n        const valueType = typeof value;\n        if (valueType === 'number')\n            return true;\n        if (valueType !== 'string')\n            return false;\n        const len = value.length;\n        if (len === 0)\n            return false;\n        for (let i = 0; i < len; ++i) {\n            const char = value.charCodeAt(i);\n            if (char < 0x30 /*0*/ || char > 0x39 /*9*/) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /*@internal*/\n    const IterateForOfStatement = {\n        ['[object Array]'](result, func) {\n            for (let i = 0, ii = result.length; i < ii; ++i) {\n                func(result, i, result[i]);\n            }\n        },\n        ['[object Map]'](result, func) {\n            const arr = Array(result.size);\n            let i = -1;\n            for (const entry of result.entries()) {\n                arr[++i] = entry;\n            }\n            IterateForOfStatement['[object Array]'](arr, func);\n        },\n        ['[object Set]'](result, func) {\n            const arr = Array(result.size);\n            let i = -1;\n            for (const key of result.keys()) {\n                arr[++i] = key;\n            }\n            IterateForOfStatement['[object Array]'](arr, func);\n        },\n        ['[object Number]'](result, func) {\n            const arr = Array(result);\n            for (let i = 0; i < result; ++i) {\n                arr[i] = i;\n            }\n            IterateForOfStatement['[object Array]'](arr, func);\n        },\n        ['[object Null]'](result, func) {\n            return;\n        },\n        ['[object Undefined]'](result, func) {\n            return;\n        }\n    };\n    /*@internal*/\n    const CountForOfStatement = {\n        ['[object Array]'](result) { return result.length; },\n        ['[object Map]'](result) { return result.size; },\n        ['[object Set]'](result) { return result.size; },\n        ['[object Number]'](result) { return result; },\n        ['[object Null]'](result) { return 0; },\n        ['[object Undefined]'](result) { return 0; }\n    };\n    // Give each AST class a noop for each interface method if and only if it's not already defined\n    // This accomplishes the following:\n    //   1) no runtime error due to bad AST structure (it's the parser's job to guard against that)\n    //   2) no runtime error due to a bad binding such as two-way on a literal (no need, since it doesn't threaten the integrity of the app's state)\n    //   3) should we decide something else, we can easily change the global behavior of 1) and 2) by simply assigning a different method here (either in the source or via AOT)\n    const ast = [AccessThis, AccessScope, ArrayLiteral, ObjectLiteral, PrimitiveLiteral, Template, Unary, CallFunction, CallMember, CallScope, AccessMember, AccessKeyed, TaggedTemplate, Binary, Conditional, Assign, ForOfStatement];\n    for (let i = 0, ii = ast.length; i < ii; ++i) {\n        const proto = ast[i].prototype;\n        // tslint:disable-next-line:no-any\n        proto.assign = proto.assign || kernel.PLATFORM.noop;\n        proto.connect = proto.connect || kernel.PLATFORM.noop;\n    }\n\n    // TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time\n    const slotNames = [];\n    const versionSlotNames = [];\n    let lastSlot = -1;\n    function ensureEnoughSlotNames(currentSlot) {\n        if (currentSlot === lastSlot) {\n            lastSlot += 5;\n            const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;\n            for (let i = currentSlot + 1; i < ii; ++i) {\n                slotNames[i] = `_observer${i}`;\n                versionSlotNames[i] = `_observerVersion${i}`;\n            }\n        }\n    }\n    ensureEnoughSlotNames(-1);\n    /*@internal*/\n    function addObserver(observer) {\n        // find the observer.\n        const observerSlots = this.observerSlots === undefined ? 0 : this.observerSlots;\n        let i = observerSlots;\n        while (i-- && this[slotNames[i]] !== observer)\n            ;\n        // if we are not already observing, put the observer in an open slot and subscribe.\n        if (i === -1) {\n            i = 0;\n            while (this[slotNames[i]]) {\n                i++;\n            }\n            this[slotNames[i]] = observer;\n            observer.subscribe(this);\n            // increment the slot count.\n            if (i === observerSlots) {\n                this.observerSlots = i + 1;\n            }\n        }\n        // set the \"version\" when the observer was used.\n        if (this.version === undefined) {\n            this.version = 0;\n        }\n        this[versionSlotNames[i]] = this.version;\n        ensureEnoughSlotNames(i);\n    }\n    /*@internal*/\n    function observeProperty(obj, propertyName) {\n        const observer = this.observerLocator.getObserver(obj, propertyName);\n        /* Note: we need to cast here because we can indeed get an accessor instead of an observer,\n         *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:\n         *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)\n         *  2. Fail silently (without throwing): give all accessors a no-op subscribe method\n         *\n         * We'll probably want to implement some global configuration (like a \"strict\" toggle) so users can pick between enforced correctness vs. ease-of-use\n         */\n        this.addObserver(observer);\n    }\n    /*@internal*/\n    function unobserve(all) {\n        const slots = this.observerSlots;\n        let slotName;\n        let observer;\n        if (all === true) {\n            for (let i = 0; i < slots; ++i) {\n                slotName = slotNames[i];\n                observer = this[slotName];\n                if (observer !== null && observer !== undefined) {\n                    this[slotName] = null;\n                    observer.unsubscribe(this);\n                }\n            }\n        }\n        else {\n            const version = this.version;\n            for (let i = 0; i < slots; ++i) {\n                if (this[versionSlotNames[i]] !== version) {\n                    slotName = slotNames[i];\n                    observer = this[slotName];\n                    if (observer !== null && observer !== undefined) {\n                        this[slotName] = null;\n                        observer.unsubscribe(this);\n                    }\n                }\n            }\n        }\n    }\n    function connectableDecorator(target) {\n        const proto = target.prototype;\n        if (!proto.hasOwnProperty('observeProperty'))\n            proto.observeProperty = observeProperty;\n        if (!proto.hasOwnProperty('unobserve'))\n            proto.unobserve = unobserve;\n        if (!proto.hasOwnProperty('addObserver'))\n            proto.addObserver = addObserver;\n        return target;\n    }\n    function connectable(target) {\n        return target === undefined ? connectableDecorator : connectableDecorator(target);\n    }\n\n    // BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak\n    const { oneTime: oneTime$1, toView: toView$1, fromView: fromView$1 } = exports.BindingMode;\n    // pre-combining flags for bitwise checks is a minor perf tweak\n    const toViewOrOneTime = toView$1 | oneTime$1;\n    exports.Binding = class Binding {\n        constructor(sourceExpression, target, targetProperty, mode, observerLocator, locator) {\n            this.sourceExpression = sourceExpression;\n            this.target = target;\n            this.targetProperty = targetProperty;\n            this.mode = mode;\n            this.observerLocator = observerLocator;\n            this.locator = locator;\n            this.$nextConnect = null;\n            this.$nextPatch = null;\n            this.$nextBind = null;\n            this.$prevBind = null;\n            this.$state = 0 /* none */;\n            this.$scope = null;\n            this.$lifecycle = locator.get(ILifecycle);\n        }\n        updateTarget(value, flags) {\n            this.targetObserver.setValue(value, flags | exports.LifecycleFlags.updateTargetInstance);\n        }\n        updateSource(value, flags) {\n            this.sourceExpression.assign(flags | exports.LifecycleFlags.updateSourceExpression, this.$scope, this.locator, value);\n        }\n        handleChange(newValue, previousValue, flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            const sourceExpression = this.sourceExpression;\n            const $scope = this.$scope;\n            const locator = this.locator;\n            if (flags & exports.LifecycleFlags.updateTargetInstance) {\n                const targetObserver = this.targetObserver;\n                const mode = this.mode;\n                previousValue = targetObserver.getValue();\n                // if the only observable is an AccessScope then we can assume the passed-in newValue is the correct and latest value\n                if (sourceExpression.$kind !== 10082 /* AccessScope */ || this.observerSlots > 1) {\n                    newValue = sourceExpression.evaluate(flags, $scope, locator);\n                }\n                if (newValue !== previousValue) {\n                    this.updateTarget(newValue, flags);\n                }\n                if ((mode & oneTime$1) === 0) {\n                    this.version++;\n                    sourceExpression.connect(flags, $scope, this);\n                    this.unobserve(false);\n                }\n                return;\n            }\n            if (flags & exports.LifecycleFlags.updateSourceExpression) {\n                if (newValue !== sourceExpression.evaluate(flags, $scope, locator)) {\n                    this.updateSource(newValue, flags);\n                }\n                return;\n            }\n            throw kernel.Reporter.error(15, exports.LifecycleFlags[flags]);\n        }\n        $bind(flags, scope) {\n            if (this.$state & 2 /* isBound */) {\n                if (this.$scope === scope) {\n                    return;\n                }\n                this.$unbind(flags | exports.LifecycleFlags.fromBind);\n            }\n            // add isBinding flag\n            this.$state |= 1 /* isBinding */;\n            this.$scope = scope;\n            let sourceExpression = this.sourceExpression;\n            if (hasBind(sourceExpression)) {\n                sourceExpression.bind(flags, scope, this);\n            }\n            const mode = this.mode;\n            let targetObserver = this.targetObserver;\n            if (!targetObserver) {\n                if (mode & fromView$1) {\n                    targetObserver = this.targetObserver = this.observerLocator.getObserver(this.target, this.targetProperty);\n                }\n                else {\n                    targetObserver = this.targetObserver = this.observerLocator.getAccessor(this.target, this.targetProperty);\n                }\n            }\n            if (targetObserver.bind) {\n                targetObserver.bind(flags);\n            }\n            // during bind, binding behavior might have changed sourceExpression\n            sourceExpression = this.sourceExpression;\n            if (mode & toViewOrOneTime) {\n                this.updateTarget(sourceExpression.evaluate(flags, scope, this.locator), flags);\n            }\n            if (mode & toView$1) {\n                this.$lifecycle.enqueueConnect(this);\n            }\n            if (mode & fromView$1) {\n                targetObserver.subscribe(this);\n            }\n            // add isBound flag and remove isBinding flag\n            this.$state |= 2 /* isBound */;\n            this.$state &= ~1 /* isBinding */;\n        }\n        $unbind(flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            // add isUnbinding flag\n            this.$state |= 64 /* isUnbinding */;\n            const sourceExpression = this.sourceExpression;\n            if (hasUnbind(sourceExpression)) {\n                sourceExpression.unbind(flags, this.$scope, this);\n            }\n            this.$scope = null;\n            const targetObserver = this.targetObserver;\n            if (targetObserver.unbind) {\n                targetObserver.unbind(flags);\n            }\n            if (targetObserver.unsubscribe) {\n                targetObserver.unsubscribe(this);\n            }\n            this.unobserve(true);\n            // remove isBound and isUnbinding flags\n            this.$state &= ~(2 /* isBound */ | 64 /* isUnbinding */);\n        }\n        connect(flags) {\n            if (this.$state & 2 /* isBound */) {\n                this.sourceExpression.connect(flags | exports.LifecycleFlags.mustEvaluate, this.$scope, this);\n            }\n        }\n        patch(flags) {\n            if (this.$state & 2 /* isBound */) {\n                this.updateTarget(this.sourceExpression.evaluate(flags | exports.LifecycleFlags.mustEvaluate, this.$scope, this.locator), flags);\n            }\n        }\n    };\n    exports.Binding = __decorate([\n        connectable()\n    ], exports.Binding);\n\n    const unset = {};\n    /*@internal*/\n    function debounceCallSource(event) {\n        const state = this.debounceState;\n        clearTimeout(state.timeoutId);\n        state.timeoutId = setTimeout(() => this.debouncedMethod(event), state.delay);\n    }\n    /*@internal*/\n    function debounceCall(newValue, oldValue, flags) {\n        const state = this.debounceState;\n        clearTimeout(state.timeoutId);\n        if (!(flags & state.callContextToDebounce)) {\n            state.oldValue = unset;\n            this.debouncedMethod(newValue, oldValue, flags);\n            return;\n        }\n        if (state.oldValue === unset) {\n            state.oldValue = oldValue;\n        }\n        state.timeoutId = setTimeout(() => {\n            const ov = state.oldValue;\n            state.oldValue = unset;\n            this.debouncedMethod(newValue, ov, flags);\n        }, state.delay);\n    }\n    const fromView$2 = exports.BindingMode.fromView;\n    exports.DebounceBindingBehavior = class DebounceBindingBehavior {\n        bind(flags, scope, binding, delay = 200) {\n            let methodToDebounce;\n            let callContextToDebounce;\n            let debouncer;\n            if (binding instanceof exports.Binding) {\n                methodToDebounce = 'handleChange';\n                debouncer = debounceCall;\n                callContextToDebounce = binding.mode & fromView$2 ? exports.LifecycleFlags.updateSourceExpression : exports.LifecycleFlags.updateTargetInstance;\n            }\n            else {\n                methodToDebounce = 'callSource';\n                debouncer = debounceCallSource;\n                callContextToDebounce = exports.LifecycleFlags.updateTargetInstance;\n            }\n            // stash the original method and it's name.\n            // note: a generic name like \"originalMethod\" is not used to avoid collisions\n            // with other binding behavior types.\n            binding.debouncedMethod = binding[methodToDebounce];\n            binding.debouncedMethod.originalName = methodToDebounce;\n            // replace the original method with the debouncing version.\n            binding[methodToDebounce] = debouncer;\n            // create the debounce state.\n            binding.debounceState = {\n                callContextToDebounce,\n                delay,\n                timeoutId: 0,\n                oldValue: unset\n            };\n        }\n        unbind(flags, scope, binding) {\n            // restore the state of the binding.\n            const methodToRestore = binding.debouncedMethod.originalName;\n            binding[methodToRestore] = binding.debouncedMethod;\n            binding.debouncedMethod = null;\n            clearTimeout(binding.debounceState.timeoutId);\n            binding.debounceState = null;\n        }\n    };\n    exports.DebounceBindingBehavior = __decorate([\n        bindingBehavior('debounce')\n    ], exports.DebounceBindingBehavior);\n\n    const SCRIPT_REGEX = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi;\n    const ISanitizer = kernel.DI.createInterface()\n        .withDefault(x => x.singleton(class {\n        sanitize(input) {\n            return input.replace(SCRIPT_REGEX, '');\n        }\n    }));\n    /**\n     * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.\n     */\n    exports.SanitizeValueConverter = class SanitizeValueConverter {\n        constructor(sanitizer) {\n            this.sanitizer = sanitizer;\n            this.sanitizer = sanitizer;\n        }\n        /**\n         * Process the provided markup that flows to the view.\n         * @param untrustedMarkup The untrusted markup to be sanitized.\n         */\n        toView(untrustedMarkup) {\n            if (untrustedMarkup === null || untrustedMarkup === undefined) {\n                return null;\n            }\n            return this.sanitizer.sanitize(untrustedMarkup);\n        }\n    };\n    exports.SanitizeValueConverter = __decorate([\n        valueConverter('sanitize'),\n        kernel.inject(ISanitizer)\n    ], exports.SanitizeValueConverter);\n\n    //Note: path and deepPath are designed to handle v0 and v1 shadow dom specs respectively\n    /*@internal*/\n    function findOriginalEventTarget(event) {\n        return (event.composedPath && event.composedPath()[0]) || (event.deepPath && event.deepPath()[0]) || (event.path && event.path[0]) || event.target;\n    }\n    function stopPropagation() {\n        this.standardStopPropagation();\n        this.propagationStopped = true;\n    }\n    function handleCapturedEvent(event) {\n        event.propagationStopped = false;\n        let target = findOriginalEventTarget(event);\n        const orderedCallbacks = [];\n        /**\n         * During capturing phase, event 'bubbles' down from parent. Needs to reorder callback from root down to target\n         */\n        while (target) {\n            if (target.capturedCallbacks) {\n                const callback = target.capturedCallbacks[event.type];\n                if (callback) {\n                    if (event.stopPropagation !== stopPropagation) {\n                        event.standardStopPropagation = event.stopPropagation;\n                        event.stopPropagation = stopPropagation;\n                    }\n                    orderedCallbacks.push(callback);\n                }\n            }\n            target = target.parentNode;\n        }\n        for (let i = orderedCallbacks.length - 1; i >= 0 && !event.propagationStopped; i--) {\n            const orderedCallback = orderedCallbacks[i];\n            if ('handleEvent' in orderedCallback) {\n                orderedCallback.handleEvent(event);\n            }\n            else {\n                orderedCallback(event);\n            }\n        }\n    }\n    function handleDelegatedEvent(event) {\n        event.propagationStopped = false;\n        let target = findOriginalEventTarget(event);\n        while (target && !event.propagationStopped) {\n            if (target.delegatedCallbacks) {\n                const callback = target.delegatedCallbacks[event.type];\n                if (callback) {\n                    if (event.stopPropagation !== stopPropagation) {\n                        event.standardStopPropagation = event.stopPropagation;\n                        event.stopPropagation = stopPropagation;\n                    }\n                    if ('handleEvent' in callback) {\n                        callback.handleEvent(event);\n                    }\n                    else {\n                        callback(event);\n                    }\n                }\n            }\n            target = target.parentNode;\n        }\n    }\n    class ListenerTracker {\n        constructor(eventName, listener, capture) {\n            this.eventName = eventName;\n            this.listener = listener;\n            this.capture = capture;\n            this.count = 0;\n        }\n        increment() {\n            this.count++;\n            if (this.count === 1) {\n                DOM.addEventListener(this.eventName, this.listener, null, this.capture);\n            }\n        }\n        decrement() {\n            this.count--;\n            if (this.count === 0) {\n                DOM.removeEventListener(this.eventName, this.listener, null, this.capture);\n            }\n        }\n    }\n    /**\n     * Enable dispose() pattern for `delegate` & `capture` commands\n     */\n    class DelegateOrCaptureSubscription {\n        constructor(entry, lookup, targetEvent, callback) {\n            this.entry = entry;\n            this.lookup = lookup;\n            this.targetEvent = targetEvent;\n            lookup[targetEvent] = callback;\n        }\n        dispose() {\n            this.entry.decrement();\n            this.lookup[this.targetEvent] = null;\n        }\n    }\n    /**\n     * Enable dispose() pattern for addEventListener for `trigger`\n     */\n    class TriggerSubscription {\n        constructor(target, targetEvent, callback) {\n            this.target = target;\n            this.targetEvent = targetEvent;\n            this.callback = callback;\n            DOM.addEventListener(targetEvent, callback, target);\n        }\n        dispose() {\n            DOM.removeEventListener(this.targetEvent, this.callback, this.target);\n        }\n    }\n    (function (DelegationStrategy) {\n        DelegationStrategy[DelegationStrategy[\"none\"] = 0] = \"none\";\n        DelegationStrategy[DelegationStrategy[\"capturing\"] = 1] = \"capturing\";\n        DelegationStrategy[DelegationStrategy[\"bubbling\"] = 2] = \"bubbling\";\n    })(exports.DelegationStrategy || (exports.DelegationStrategy = {}));\n    class EventSubscriber {\n        constructor(events) {\n            this.events = events;\n            this.events = events;\n            this.target = null;\n            this.handler = null;\n        }\n        subscribe(node, callbackOrListener) {\n            this.target = node;\n            this.handler = callbackOrListener;\n            const add = DOM.addEventListener;\n            const events = this.events;\n            for (let i = 0, ii = events.length; ii > i; ++i) {\n                add(events[i], callbackOrListener, node);\n            }\n        }\n        dispose() {\n            const node = this.target;\n            const callbackOrListener = this.handler;\n            const events = this.events;\n            const remove = DOM.removeEventListener;\n            for (let i = 0, ii = events.length; ii > i; ++i) {\n                remove(events[i], callbackOrListener, node);\n            }\n            this.target = this.handler = null;\n        }\n    }\n    const IEventManager = kernel.DI.createInterface()\n        .withDefault(x => x.singleton(EventManager));\n    /*@internal*/\n    class EventManager {\n        constructor() {\n            this.elementHandlerLookup = {};\n            this.delegatedHandlers = {};\n            this.capturedHandlers = {};\n            this.registerElementConfiguration({\n                tagName: 'INPUT',\n                properties: {\n                    value: ['change', 'input'],\n                    checked: ['change', 'input'],\n                    files: ['change', 'input']\n                }\n            });\n            this.registerElementConfiguration({\n                tagName: 'TEXTAREA',\n                properties: {\n                    value: ['change', 'input']\n                }\n            });\n            this.registerElementConfiguration({\n                tagName: 'SELECT',\n                properties: {\n                    value: ['change']\n                }\n            });\n            this.registerElementConfiguration({\n                tagName: 'content editable',\n                properties: {\n                    value: ['change', 'input', 'blur', 'keyup', 'paste']\n                }\n            });\n            this.registerElementConfiguration({\n                tagName: 'scrollable element',\n                properties: {\n                    scrollTop: ['scroll'],\n                    scrollLeft: ['scroll']\n                }\n            });\n        }\n        registerElementConfiguration(config) {\n            const properties = config.properties;\n            const lookup = this.elementHandlerLookup[config.tagName] = {};\n            for (const propertyName in properties) {\n                if (properties.hasOwnProperty(propertyName)) {\n                    lookup[propertyName] = properties[propertyName];\n                }\n            }\n        }\n        getElementHandler(target, propertyName) {\n            const tagName = target['tagName'];\n            const lookup = this.elementHandlerLookup;\n            if (tagName) {\n                if (lookup[tagName] && lookup[tagName][propertyName]) {\n                    return new EventSubscriber(lookup[tagName][propertyName]);\n                }\n                if (propertyName === 'textContent' || propertyName === 'innerHTML') {\n                    return new EventSubscriber(lookup['content editable'].value);\n                }\n                if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {\n                    return new EventSubscriber(lookup['scrollable element'][propertyName]);\n                }\n            }\n            return null;\n        }\n        addEventListener(target, targetEvent, callbackOrListener, strategy) {\n            let delegatedHandlers;\n            let capturedHandlers;\n            let handlerEntry;\n            if (strategy === exports.DelegationStrategy.bubbling) {\n                delegatedHandlers = this.delegatedHandlers;\n                handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new ListenerTracker(targetEvent, handleDelegatedEvent, false));\n                handlerEntry.increment();\n                const delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});\n                return new DelegateOrCaptureSubscription(handlerEntry, delegatedCallbacks, targetEvent, callbackOrListener);\n            }\n            if (strategy === exports.DelegationStrategy.capturing) {\n                capturedHandlers = this.capturedHandlers;\n                handlerEntry = capturedHandlers[targetEvent] || (capturedHandlers[targetEvent] = new ListenerTracker(targetEvent, handleCapturedEvent, true));\n                handlerEntry.increment();\n                const capturedCallbacks = target.capturedCallbacks || (target.capturedCallbacks = {});\n                return new DelegateOrCaptureSubscription(handlerEntry, capturedCallbacks, targetEvent, callbackOrListener);\n            }\n            return new TriggerSubscription(target, targetEvent, callbackOrListener);\n        }\n    }\n\n    /*@internal*/\n    function handleSelfEvent(event) {\n        const target = findOriginalEventTarget(event);\n        if (this.target !== target) {\n            return;\n        }\n        return this.selfEventCallSource(event);\n    }\n    exports.SelfBindingBehavior = class SelfBindingBehavior {\n        bind(flags, scope, binding) {\n            if (!binding.callSource || !binding.targetEvent) {\n                throw kernel.Reporter.error(8);\n            }\n            binding.selfEventCallSource = binding.callSource;\n            binding.callSource = handleSelfEvent;\n        }\n        unbind(flags, scope, binding) {\n            binding.callSource = binding.selfEventCallSource;\n            binding.selfEventCallSource = null;\n        }\n    };\n    exports.SelfBindingBehavior = __decorate([\n        bindingBehavior('self')\n    ], exports.SelfBindingBehavior);\n\n    exports.SignalBindingBehavior = class SignalBindingBehavior {\n        constructor(signaler) {\n            this.signaler = signaler;\n        }\n        bind(flags, scope, binding) {\n            if (!binding.updateTarget) {\n                throw kernel.Reporter.error(11);\n            }\n            if (arguments.length === 4) {\n                const name = arguments[3];\n                this.signaler.addSignalListener(name, binding);\n                binding.signal = name;\n            }\n            else if (arguments.length > 4) {\n                const names = Array.prototype.slice.call(arguments, 3);\n                let i = names.length;\n                while (i--) {\n                    const name = names[i];\n                    this.signaler.addSignalListener(name, binding);\n                }\n                binding.signal = names;\n            }\n            else {\n                throw kernel.Reporter.error(12);\n            }\n        }\n        unbind(flags, scope, binding) {\n            const name = binding.signal;\n            binding.signal = null;\n            if (Array.isArray(name)) {\n                const names = name;\n                let i = names.length;\n                while (i--) {\n                    this.signaler.removeSignalListener(names[i], binding);\n                }\n            }\n            else {\n                this.signaler.removeSignalListener(name, binding);\n            }\n        }\n    };\n    exports.SignalBindingBehavior = __decorate([\n        bindingBehavior('signal'),\n        kernel.inject(ISignaler)\n    ], exports.SignalBindingBehavior);\n\n    /*@internal*/\n    function throttle(newValue) {\n        const state = this.throttleState;\n        const elapsed = +new Date() - state.last;\n        if (elapsed >= state.delay) {\n            clearTimeout(state.timeoutId);\n            state.timeoutId = null;\n            state.last = +new Date();\n            this.throttledMethod(newValue);\n            return;\n        }\n        state.newValue = newValue;\n        if (state.timeoutId === null) {\n            state.timeoutId = setTimeout(() => {\n                state.timeoutId = null;\n                state.last = +new Date();\n                this.throttledMethod(state.newValue);\n            }, state.delay - elapsed);\n        }\n    }\n    exports.ThrottleBindingBehavior = class ThrottleBindingBehavior {\n        bind(flags, scope, binding, delay = 200) {\n            let methodToThrottle;\n            if (binding instanceof exports.Binding) {\n                if (binding.mode === exports.BindingMode.twoWay) {\n                    methodToThrottle = 'updateSource';\n                }\n                else {\n                    methodToThrottle = 'updateTarget';\n                }\n            }\n            else {\n                methodToThrottle = 'callSource';\n            }\n            // stash the original method and it's name.\n            // note: a generic name like \"originalMethod\" is not used to avoid collisions\n            // with other binding behavior types.\n            binding.throttledMethod = binding[methodToThrottle];\n            binding.throttledMethod.originalName = methodToThrottle;\n            // replace the original method with the throttling version.\n            binding[methodToThrottle] = throttle;\n            // create the throttle state.\n            binding.throttleState = {\n                delay: delay,\n                last: 0,\n                timeoutId: null\n            };\n        }\n        unbind(flags, scope, binding) {\n            // restore the state of the binding.\n            const methodToRestore = binding.throttledMethod.originalName;\n            binding[methodToRestore] = binding.throttledMethod;\n            binding.throttledMethod = null;\n            clearTimeout(binding.throttleState.timeoutId);\n            binding.throttleState = null;\n        }\n    };\n    exports.ThrottleBindingBehavior = __decorate([\n        bindingBehavior('throttle')\n    ], exports.ThrottleBindingBehavior);\n\n    function flush$1() {\n        this.callBatchedSubscribers(this.indexMap);\n        this.resetIndexMap();\n    }\n    function dispose$2() {\n        this.collection.$observer = undefined;\n        this.collection = null;\n        this.indexMap = null;\n    }\n    function resetIndexMapIndexed() {\n        const len = this.collection.length;\n        const indexMap = (this.indexMap = Array(len));\n        let i = 0;\n        while (i < len) {\n            indexMap[i] = i++;\n        }\n        indexMap.deletedItems = [];\n    }\n    function resetIndexMapKeyed() {\n        const len = this.collection.size;\n        const indexMap = (this.indexMap = Array(len));\n        let i = 0;\n        while (i < len) {\n            indexMap[i] = i++;\n        }\n        indexMap.deletedItems = [];\n    }\n    function getLengthObserver() {\n        return this.lengthObserver || (this.lengthObserver = new exports.CollectionLengthObserver(this, this.lengthPropertyName));\n    }\n    function collectionObserver(kind) {\n        return function (target) {\n            subscriberCollection(exports.MutationKind.collection)(target);\n            batchedSubscriberCollection()(target);\n            const proto = target.prototype;\n            proto.$nextFlush = null;\n            proto.collection = null;\n            proto.indexMap = null;\n            proto.hasChanges = false;\n            proto.lengthPropertyName = kind & 8 /* indexed */ ? 'length' : 'size';\n            proto.collectionKind = kind;\n            proto.resetIndexMap = kind & 8 /* indexed */ ? resetIndexMapIndexed : resetIndexMapKeyed;\n            proto.flush = flush$1;\n            proto.dispose = dispose$2;\n            proto.getLengthObserver = getLengthObserver;\n            proto.subscribe = proto.subscribe || proto.addSubscriber;\n            proto.unsubscribe = proto.unsubscribe || proto.removeSubscriber;\n            proto.subscribeBatched = proto.subscribeBatched || proto.addBatchedSubscriber;\n            proto.unsubscribeBatched = proto.unsubscribeBatched || proto.removeBatchedSubscriber;\n        };\n    }\n    exports.CollectionLengthObserver = class CollectionLengthObserver {\n        constructor(obj, propertyKey) {\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n            this.currentValue = obj[propertyKey];\n        }\n        getValue() {\n            return this.obj[this.propertyKey];\n        }\n        setValueCore(newValue) {\n            this.obj[this.propertyKey] = newValue;\n        }\n        subscribe(subscriber) {\n            this.addSubscriber(subscriber);\n        }\n        unsubscribe(subscriber) {\n            this.removeSubscriber(subscriber);\n        }\n    };\n    exports.CollectionLengthObserver = __decorate([\n        targetObserver()\n    ], exports.CollectionLengthObserver);\n\n    const proto = Array.prototype;\n    const nativePush = proto.push; // TODO: probably want to make these internal again\n    const nativeUnshift = proto.unshift;\n    const nativePop = proto.pop;\n    const nativeShift = proto.shift;\n    const nativeSplice = proto.splice;\n    const nativeReverse = proto.reverse;\n    const nativeSort = proto.sort;\n    // https://tc39.github.io/ecma262/#sec-array.prototype.push\n    function observePush() {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativePush.apply(this, arguments);\n        }\n        const len = this.length;\n        const argCount = arguments.length;\n        if (argCount === 0) {\n            return len;\n        }\n        this.length = o.indexMap.length = len + argCount;\n        let i = len;\n        while (i < this.length) {\n            this[i] = arguments[i - len];\n            o.indexMap[i] = -2;\n            i++;\n        }\n        o.callSubscribers('push', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return this.length;\n    }\n    // https://tc39.github.io/ecma262/#sec-array.prototype.unshift\n    function observeUnshift() {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeUnshift.apply(this, arguments);\n        }\n        const argCount = arguments.length;\n        const inserts = new Array(argCount);\n        let i = 0;\n        while (i < argCount) {\n            inserts[i++] = -2;\n        }\n        nativeUnshift.apply(o.indexMap, inserts);\n        const len = nativeUnshift.apply(this, arguments);\n        o.callSubscribers('unshift', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return len;\n    }\n    // https://tc39.github.io/ecma262/#sec-array.prototype.pop\n    function observePop() {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativePop.call(this);\n        }\n        const indexMap = o.indexMap;\n        const element = nativePop.call(this);\n        // only mark indices as deleted if they actually existed in the original array\n        const index = indexMap.length - 1;\n        if (indexMap[index] > -1) {\n            nativePush.call(indexMap.deletedItems, element);\n        }\n        nativePop.call(indexMap);\n        o.callSubscribers('pop', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return element;\n    }\n    // https://tc39.github.io/ecma262/#sec-array.prototype.shift\n    function observeShift() {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeShift.call(this);\n        }\n        const indexMap = o.indexMap;\n        const element = nativeShift.call(this);\n        // only mark indices as deleted if they actually existed in the original array\n        if (indexMap[0] > -1) {\n            nativePush.call(indexMap.deletedItems, element);\n        }\n        nativeShift.call(indexMap);\n        o.callSubscribers('shift', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return element;\n    }\n    // https://tc39.github.io/ecma262/#sec-array.prototype.splice\n    function observeSplice(start, deleteCount) {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeSplice.apply(this, arguments);\n        }\n        const indexMap = o.indexMap;\n        if (deleteCount > 0) {\n            let i = isNaN(start) ? 0 : start;\n            const to = i + deleteCount;\n            while (i < to) {\n                if (indexMap[i] > -1) {\n                    nativePush.call(indexMap.deletedItems, this[i]);\n                }\n                i++;\n            }\n        }\n        const argCount = arguments.length;\n        if (argCount > 2) {\n            const itemCount = argCount - 2;\n            const inserts = new Array(itemCount);\n            let i = 0;\n            while (i < itemCount) {\n                inserts[i++] = -2;\n            }\n            nativeSplice.call(indexMap, start, deleteCount, ...inserts);\n        }\n        else if (argCount === 2) {\n            nativeSplice.call(indexMap, start, deleteCount);\n        }\n        const deleted = nativeSplice.apply(this, arguments);\n        o.callSubscribers('splice', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return deleted;\n    }\n    // https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n    function observeReverse() {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeReverse.call(this);\n        }\n        const len = this.length;\n        const middle = (len / 2) | 0;\n        let lower = 0;\n        while (lower !== middle) {\n            const upper = len - lower - 1;\n            const lowerValue = this[lower];\n            const lowerIndex = o.indexMap[lower];\n            const upperValue = this[upper];\n            const upperIndex = o.indexMap[upper];\n            this[lower] = upperValue;\n            o.indexMap[lower] = upperIndex;\n            this[upper] = lowerValue;\n            o.indexMap[upper] = lowerIndex;\n            lower++;\n        }\n        o.callSubscribers('reverse', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return this;\n    }\n    // https://tc39.github.io/ecma262/#sec-array.prototype.sort\n    // https://github.com/v8/v8/blob/master/src/js/array.js\n    function observeSort(compareFn) {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeSort.call(this, compareFn);\n        }\n        const len = this.length;\n        if (len < 2) {\n            return this;\n        }\n        quickSort(this, o.indexMap, 0, len, preSortCompare);\n        let i = 0;\n        while (i < len) {\n            if (this[i] === undefined) {\n                break;\n            }\n            i++;\n        }\n        if (compareFn === undefined || typeof compareFn !== 'function' /*spec says throw a TypeError, should we do that too?*/) {\n            compareFn = sortCompare;\n        }\n        quickSort(this, o.indexMap, 0, i, compareFn);\n        o.callSubscribers('sort', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return this;\n    }\n    // https://tc39.github.io/ecma262/#sec-sortcompare\n    function sortCompare(x, y) {\n        if (x === y) {\n            return 0;\n        }\n        x = x === null ? 'null' : x.toString();\n        y = y === null ? 'null' : y.toString();\n        return x < y ? -1 : 1;\n    }\n    function preSortCompare(x, y) {\n        if (x === undefined) {\n            if (y === undefined) {\n                return 0;\n            }\n            else {\n                return 1;\n            }\n        }\n        if (y === undefined) {\n            return -1;\n        }\n        return 0;\n    }\n    function insertionSort(arr, indexMap, fromIndex, toIndex, compareFn) {\n        let velement, ielement, vtmp, itmp, order;\n        let i, j;\n        for (i = fromIndex + 1; i < toIndex; i++) {\n            velement = arr[i];\n            ielement = indexMap[i];\n            for (j = i - 1; j >= fromIndex; j--) {\n                vtmp = arr[j];\n                itmp = indexMap[j];\n                order = compareFn(vtmp, velement);\n                if (order > 0) {\n                    arr[j + 1] = vtmp;\n                    indexMap[j + 1] = itmp;\n                }\n                else {\n                    break;\n                }\n            }\n            arr[j + 1] = velement;\n            indexMap[j + 1] = ielement;\n        }\n    }\n    function quickSort(arr, indexMap, fromIndex, toIndex, compareFn) {\n        let thirdIndex = 0, i = 0;\n        let v0, v1, v2;\n        let i0, i1, i2;\n        let c01, c02, c12;\n        let vtmp, itmp;\n        let vpivot, ipivot, lowEnd, highStart;\n        let velement, ielement, order, vtopElement;\n        // tslint:disable-next-line:no-constant-condition\n        while (true) {\n            if (toIndex - fromIndex <= 10) {\n                insertionSort(arr, indexMap, fromIndex, toIndex, compareFn);\n                return;\n            }\n            thirdIndex = fromIndex + ((toIndex - fromIndex) >> 1);\n            v0 = arr[fromIndex];\n            i0 = indexMap[fromIndex];\n            v1 = arr[toIndex - 1];\n            i1 = indexMap[toIndex - 1];\n            v2 = arr[thirdIndex];\n            i2 = indexMap[thirdIndex];\n            c01 = compareFn(v0, v1);\n            if (c01 > 0) {\n                vtmp = v0;\n                itmp = i0;\n                v0 = v1;\n                i0 = i1;\n                v1 = vtmp;\n                i1 = itmp;\n            }\n            c02 = compareFn(v0, v2);\n            if (c02 >= 0) {\n                vtmp = v0;\n                itmp = i0;\n                v0 = v2;\n                i0 = i2;\n                v2 = v1;\n                i2 = i1;\n                v1 = vtmp;\n                i1 = itmp;\n            }\n            else {\n                c12 = compareFn(v1, v2);\n                if (c12 > 0) {\n                    vtmp = v1;\n                    itmp = i1;\n                    v1 = v2;\n                    i1 = i2;\n                    v2 = vtmp;\n                    i2 = itmp;\n                }\n            }\n            arr[fromIndex] = v0;\n            indexMap[fromIndex] = i0;\n            arr[toIndex - 1] = v2;\n            indexMap[toIndex - 1] = i2;\n            vpivot = v1;\n            ipivot = i1;\n            lowEnd = fromIndex + 1;\n            highStart = toIndex - 1;\n            arr[thirdIndex] = arr[lowEnd];\n            indexMap[thirdIndex] = indexMap[lowEnd];\n            arr[lowEnd] = vpivot;\n            indexMap[lowEnd] = ipivot;\n            partition: for (i = lowEnd + 1; i < highStart; i++) {\n                velement = arr[i];\n                ielement = indexMap[i];\n                order = compareFn(velement, vpivot);\n                if (order < 0) {\n                    arr[i] = arr[lowEnd];\n                    indexMap[i] = indexMap[lowEnd];\n                    arr[lowEnd] = velement;\n                    indexMap[lowEnd] = ielement;\n                    lowEnd++;\n                }\n                else if (order > 0) {\n                    do {\n                        highStart--;\n                        // tslint:disable-next-line:triple-equals\n                        if (highStart == i) {\n                            break partition;\n                        }\n                        vtopElement = arr[highStart];\n                        order = compareFn(vtopElement, vpivot);\n                    } while (order > 0);\n                    arr[i] = arr[highStart];\n                    indexMap[i] = indexMap[highStart];\n                    arr[highStart] = velement;\n                    indexMap[highStart] = ielement;\n                    if (order < 0) {\n                        velement = arr[i];\n                        ielement = indexMap[i];\n                        arr[i] = arr[lowEnd];\n                        indexMap[i] = indexMap[lowEnd];\n                        arr[lowEnd] = velement;\n                        indexMap[lowEnd] = ielement;\n                        lowEnd++;\n                    }\n                }\n            }\n            if (toIndex - highStart < lowEnd - fromIndex) {\n                quickSort(arr, indexMap, highStart, toIndex, compareFn);\n                toIndex = lowEnd;\n            }\n            else {\n                quickSort(arr, indexMap, fromIndex, lowEnd, compareFn);\n                fromIndex = highStart;\n            }\n        }\n    }\n    for (const observe of [observePush, observeUnshift, observePop, observeShift, observeSplice, observeReverse, observeSort]) {\n        Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n    }\n    function enableArrayObservation() {\n        if (proto.push['observing'] !== true)\n            proto.push = observePush;\n        if (proto.unshift['observing'] !== true)\n            proto.unshift = observeUnshift;\n        if (proto.pop['observing'] !== true)\n            proto.pop = observePop;\n        if (proto.shift['observing'] !== true)\n            proto.shift = observeShift;\n        if (proto.splice['observing'] !== true)\n            proto.splice = observeSplice;\n        if (proto.reverse['observing'] !== true)\n            proto.reverse = observeReverse;\n        if (proto.sort['observing'] !== true)\n            proto.sort = observeSort;\n    }\n    enableArrayObservation();\n    function disableArrayObservation() {\n        if (proto.push['observing'] === true)\n            proto.push = nativePush;\n        if (proto.unshift['observing'] === true)\n            proto.unshift = nativeUnshift;\n        if (proto.pop['observing'] === true)\n            proto.pop = nativePop;\n        if (proto.shift['observing'] === true)\n            proto.shift = nativeShift;\n        if (proto.splice['observing'] === true)\n            proto.splice = nativeSplice;\n        if (proto.reverse['observing'] === true)\n            proto.reverse = nativeReverse;\n        if (proto.sort['observing'] === true)\n            proto.sort = nativeSort;\n    }\n    exports.ArrayObserver = class ArrayObserver {\n        constructor(lifecycle, array) {\n            this.lifecycle = lifecycle;\n            array.$observer = this;\n            this.collection = array;\n            this.resetIndexMap();\n        }\n    };\n    exports.ArrayObserver = __decorate([\n        collectionObserver(9 /* array */)\n    ], exports.ArrayObserver);\n    function getArrayObserver(lifecycle, array) {\n        return array.$observer || new exports.ArrayObserver(lifecycle, array);\n    }\n\n    function computed(config) {\n        return function (target, key) {\n            (target.computed || (target.computed = {}))[key] = config;\n        };\n    }\n    const noProxy = !(typeof Proxy !== undefined);\n    const computedOverrideDefaults = { static: false, volatile: false };\n    /* @internal */\n    function createComputedObserver(observerLocator, dirtyChecker, lifecycle, \n    // tslint:disable-next-line:no-reserved-keywords\n    instance, propertyName, descriptor) {\n        if (descriptor.configurable === false) {\n            return dirtyChecker.createProperty(instance, propertyName);\n        }\n        if (descriptor.get) {\n            const overrides = instance.constructor.computed\n                ? instance.constructor.computed[propertyName] || computedOverrideDefaults\n                : computedOverrideDefaults;\n            if (descriptor.set) {\n                if (overrides.volatile) {\n                    return noProxy\n                        ? dirtyChecker.createProperty(instance, propertyName)\n                        : new exports.GetterObserver(overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n                }\n                return new exports.CustomSetterObserver(instance, propertyName, descriptor, lifecycle);\n            }\n            return noProxy\n                ? dirtyChecker.createProperty(instance, propertyName)\n                : new exports.GetterObserver(overrides, instance, propertyName, descriptor, observerLocator, lifecycle);\n        }\n        throw kernel.Reporter.error(18, propertyName);\n    }\n    // Used when the getter is dependent solely on changes that happen within the setter.\n    exports.CustomSetterObserver = class CustomSetterObserver {\n        constructor(obj, propertyKey, descriptor, lifecycle) {\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n            this.descriptor = descriptor;\n            this.lifecycle = lifecycle;\n            this.$nextFlush = null;\n            this.observing = false;\n        }\n        getValue() {\n            return this.obj[this.propertyKey];\n        }\n        setValue(newValue) {\n            this.obj[this.propertyKey] = newValue;\n        }\n        flush(flags) {\n            const oldValue = this.oldValue;\n            const newValue = this.currentValue;\n            this.callSubscribers(newValue, oldValue, flags | exports.LifecycleFlags.updateTargetInstance);\n        }\n        subscribe(subscriber) {\n            if (!this.observing) {\n                this.convertProperty();\n            }\n            this.addSubscriber(subscriber);\n        }\n        unsubscribe(subscriber) {\n            this.removeSubscriber(subscriber);\n        }\n        convertProperty() {\n            const setter = this.descriptor.set;\n            const that = this;\n            this.observing = true;\n            this.currentValue = this.obj[this.propertyKey];\n            Reflect.defineProperty(this.obj, this.propertyKey, {\n                set: function (newValue) {\n                    setter.call(that.obj, newValue);\n                    const oldValue = this.currentValue;\n                    if (oldValue !== newValue) {\n                        that.oldValue = oldValue;\n                        this.lifecycle.queueFlush(that);\n                        that.currentValue = newValue;\n                    }\n                }\n            });\n        }\n    };\n    exports.CustomSetterObserver = __decorate([\n        subscriberCollection(exports.MutationKind.instance)\n    ], exports.CustomSetterObserver);\n    exports.CustomSetterObserver.prototype.dispose = kernel.PLATFORM.noop;\n    // Used when there is no setter, and the getter is dependent on other properties of the object;\n    // Used when there is a setter but the value of the getter can change based on properties set outside of the setter.\n    /*@internal*/\n    exports.GetterObserver = class GetterObserver {\n        constructor(overrides, obj, propertyKey, descriptor, observerLocator, lifecycle) {\n            this.overrides = overrides;\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n            this.descriptor = descriptor;\n            this.observerLocator = observerLocator;\n            this.lifecycle = lifecycle;\n            this.controller = new GetterController(overrides, obj, propertyKey, descriptor, this, observerLocator, lifecycle);\n        }\n        getValue() {\n            return this.controller.value;\n        }\n        // tslint:disable-next-line:no-empty\n        setValue(newValue) { }\n        flush(flags) {\n            const oldValue = this.controller.value;\n            const newValue = this.controller.getValueAndCollectDependencies();\n            if (oldValue !== newValue) {\n                this.callSubscribers(newValue, oldValue, flags | exports.LifecycleFlags.updateTargetInstance);\n            }\n        }\n        subscribe(subscriber) {\n            this.addSubscriber(subscriber);\n            this.controller.onSubscriberAdded();\n        }\n        unsubscribe(subscriber) {\n            this.removeSubscriber(subscriber);\n            this.controller.onSubscriberRemoved();\n        }\n    };\n    exports.GetterObserver = __decorate([\n        subscriberCollection(exports.MutationKind.instance)\n    ], exports.GetterObserver);\n    exports.GetterObserver.prototype.dispose = kernel.PLATFORM.noop;\n    /*@internal*/\n    class GetterController {\n        constructor(overrides, instance, propertyName, descriptor, owner, observerLocator, lifecycle) {\n            this.overrides = overrides;\n            this.instance = instance;\n            this.propertyName = propertyName;\n            this.owner = owner;\n            this.lifecycle = lifecycle;\n            this.isCollecting = false;\n            this.dependencies = [];\n            this.subscriberCount = 0;\n            const proxy = new Proxy(instance, createGetterTraps(observerLocator, this));\n            const getter = descriptor.get;\n            const ctrl = this;\n            Reflect.defineProperty(instance, propertyName, {\n                get: function () {\n                    if (ctrl.subscriberCount < 1 || ctrl.isCollecting) {\n                        ctrl.value = getter.apply(proxy);\n                    }\n                    return ctrl.value;\n                }\n            });\n        }\n        addDependency(subscribable) {\n            if (this.dependencies.includes(subscribable)) {\n                return;\n            }\n            this.dependencies.push(subscribable);\n        }\n        onSubscriberAdded() {\n            this.subscriberCount++;\n            if (this.subscriberCount > 1) {\n                return;\n            }\n            this.getValueAndCollectDependencies(true);\n        }\n        getValueAndCollectDependencies(requireCollect = false) {\n            const dynamicDependencies = !this.overrides.static || requireCollect;\n            if (dynamicDependencies) {\n                this.unsubscribeAllDependencies();\n                this.isCollecting = true;\n            }\n            this.value = this.instance[this.propertyName]; // triggers observer collection\n            if (dynamicDependencies) {\n                this.isCollecting = false;\n                this.dependencies.forEach(x => { x.subscribe(this); });\n            }\n            return this.value;\n        }\n        onSubscriberRemoved() {\n            this.subscriberCount--;\n            if (this.subscriberCount === 0) {\n                this.unsubscribeAllDependencies();\n            }\n        }\n        handleChange() {\n            this.lifecycle.enqueueFlush(this.owner);\n        }\n        unsubscribeAllDependencies() {\n            this.dependencies.forEach(x => { x.unsubscribe(this); });\n            this.dependencies.length = 0;\n        }\n    }\n    function createGetterTraps(observerLocator, controller) {\n        return {\n            get: function (instance, key) {\n                const value = instance[key];\n                if (key === '$observers' || typeof value === 'function' || !controller.isCollecting) {\n                    return value;\n                }\n                // TODO: fix this\n                if (instance instanceof Array) {\n                    controller.addDependency(observerLocator.getArrayObserver(instance));\n                    if (key === 'length') {\n                        controller.addDependency(observerLocator.getArrayObserver(instance).getLengthObserver());\n                    }\n                }\n                else if (instance instanceof Map) {\n                    controller.addDependency(observerLocator.getMapObserver(instance));\n                    if (key === 'size') {\n                        controller.addDependency(observerLocator.getMapObserver(instance).getLengthObserver());\n                    }\n                }\n                else if (instance instanceof Set) {\n                    controller.addDependency(observerLocator.getSetObserver(instance));\n                    if (key === 'size') {\n                        return observerLocator.getSetObserver(instance).getLengthObserver();\n                    }\n                }\n                else {\n                    controller.addDependency(observerLocator.getObserver(instance, key));\n                }\n                return proxyOrValue(observerLocator, controller, value);\n            }\n        };\n    }\n    function proxyOrValue(observerLocator, controller, value) {\n        if (!(value instanceof Object)) {\n            return value;\n        }\n        return new Proxy(value, createGetterTraps(observerLocator, controller));\n    }\n\n    const IDirtyChecker = kernel.DI.createInterface()\n        .withDefault(x => x.singleton(DirtyChecker));\n    /*@internal*/\n    class DirtyChecker {\n        constructor() {\n            this.tracked = [];\n            this.checkDelay = 120;\n        }\n        createProperty(obj, propertyName) {\n            return new exports.DirtyCheckProperty(this, obj, propertyName);\n        }\n        addProperty(property) {\n            const tracked = this.tracked;\n            tracked.push(property);\n            if (tracked.length === 1) {\n                this.scheduleDirtyCheck();\n            }\n        }\n        removeProperty(property) {\n            const tracked = this.tracked;\n            tracked.splice(tracked.indexOf(property), 1);\n        }\n        scheduleDirtyCheck() {\n            setTimeout(() => { this.check(); }, this.checkDelay);\n        }\n        check() {\n            const tracked = this.tracked;\n            let i = tracked.length;\n            while (i--) {\n                const current = tracked[i];\n                if (current.isDirty()) {\n                    current.flush(exports.LifecycleFlags.fromFlush);\n                }\n            }\n            if (tracked.length) {\n                this.scheduleDirtyCheck();\n            }\n        }\n    }\n    /*@internal*/\n    exports.DirtyCheckProperty = class DirtyCheckProperty {\n        constructor(dirtyChecker, obj, propertyKey) {\n            this.dirtyChecker = dirtyChecker;\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n        }\n        isDirty() {\n            return this.oldValue !== this.obj[this.propertyKey];\n        }\n        getValue() {\n            return this.obj[this.propertyKey];\n        }\n        setValue(newValue) {\n            this.obj[this.propertyKey] = newValue;\n        }\n        flush(flags) {\n            const oldValue = this.oldValue;\n            const newValue = this.getValue();\n            this.callSubscribers(newValue, oldValue, flags | exports.LifecycleFlags.updateTargetInstance);\n            this.oldValue = newValue;\n        }\n        subscribe(subscriber) {\n            if (!this.hasSubscribers()) {\n                this.oldValue = this.getValue();\n                this.dirtyChecker.addProperty(this);\n            }\n            this.addSubscriber(subscriber);\n        }\n        unsubscribe(subscriber) {\n            if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n                this.dirtyChecker.removeProperty(this);\n            }\n        }\n    };\n    exports.DirtyCheckProperty = __decorate([\n        propertyObserver()\n    ], exports.DirtyCheckProperty);\n\n    const inputValueDefaults = {\n        ['button']: '',\n        ['checkbox']: 'on',\n        ['color']: '#000000',\n        ['date']: '',\n        ['datetime-local']: '',\n        ['email']: '',\n        ['file']: '',\n        ['hidden']: '',\n        ['image']: '',\n        ['month']: '',\n        ['number']: '',\n        ['password']: '',\n        ['radio']: 'on',\n        ['range']: '50',\n        ['reset']: '',\n        ['search']: '',\n        ['submit']: '',\n        ['tel']: '',\n        ['text']: '',\n        ['time']: '',\n        ['url']: '',\n        ['week']: ''\n    };\n    const handleEventFlags = exports.LifecycleFlags.fromDOMEvent | exports.LifecycleFlags.updateSourceExpression;\n    exports.ValueAttributeObserver = class ValueAttributeObserver {\n        constructor(lifecycle, obj, propertyKey, handler) {\n            // note: input.files can be assigned and this was fixed in Firefox 57:\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1384030\n            this.lifecycle = lifecycle;\n            this.obj = obj;\n            this.propertyKey = propertyKey;\n            this.handler = handler;\n            // input.value (for type='file') however, can only be assigned an empty string\n            if (propertyKey === 'value') {\n                const nodeType = obj['type'];\n                this.defaultValue = inputValueDefaults[nodeType || 'text'];\n                if (nodeType === 'file') {\n                    this.flush = this.flushFileChanges;\n                }\n            }\n            else {\n                this.defaultValue = '';\n            }\n            this.oldValue = this.currentValue = obj[propertyKey];\n        }\n        getValue() {\n            return this.obj[this.propertyKey];\n        }\n        setValueCore(newValue, flags) {\n            this.obj[this.propertyKey] = newValue;\n            if (flags & exports.LifecycleFlags.fromBind) {\n                return;\n            }\n            this.callSubscribers(this.currentValue, this.oldValue, flags);\n        }\n        handleEvent() {\n            const oldValue = this.oldValue = this.currentValue;\n            const newValue = this.currentValue = this.getValue();\n            if (oldValue !== newValue) {\n                this.callSubscribers(newValue, oldValue, handleEventFlags);\n                this.oldValue = newValue;\n            }\n        }\n        subscribe(subscriber) {\n            if (!this.hasSubscribers()) {\n                this.oldValue = this.getValue();\n                this.handler.subscribe(this.obj, this);\n            }\n            this.addSubscriber(subscriber);\n        }\n        unsubscribe(subscriber) {\n            if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n                this.handler.dispose();\n            }\n        }\n        flushFileChanges() {\n            const currentValue = this.currentValue;\n            if (this.oldValue !== currentValue) {\n                if (currentValue === '') {\n                    this.setValueCore(currentValue, this.currentFlags);\n                    this.oldValue = this.currentValue;\n                }\n            }\n        }\n    };\n    exports.ValueAttributeObserver = __decorate([\n        targetObserver('')\n    ], exports.ValueAttributeObserver);\n    exports.ValueAttributeObserver.prototype.propertyKey = '';\n    exports.ValueAttributeObserver.prototype.handler = null;\n    const defaultHandleBatchedChangeFlags = exports.LifecycleFlags.fromFlush | exports.LifecycleFlags.updateTargetInstance;\n    exports.CheckedObserver = class CheckedObserver {\n        constructor(lifecycle, obj, handler, observerLocator) {\n            this.lifecycle = lifecycle;\n            this.obj = obj;\n            this.handler = handler;\n            this.observerLocator = observerLocator;\n        }\n        getValue() {\n            return this.currentValue;\n        }\n        setValueCore(newValue, flags) {\n            if (!this.valueObserver) {\n                this.valueObserver = this.obj['$observers'] && (this.obj['$observers'].model || this.obj['$observers'].value);\n                if (this.valueObserver) {\n                    this.valueObserver.subscribe(this);\n                }\n            }\n            if (this.arrayObserver) {\n                this.arrayObserver.unsubscribeBatched(this);\n                this.arrayObserver = null;\n            }\n            if (this.obj.type === 'checkbox' && Array.isArray(newValue)) {\n                this.arrayObserver = this.observerLocator.getArrayObserver(newValue);\n                this.arrayObserver.subscribeBatched(this);\n            }\n            this.synchronizeElement();\n        }\n        // handleBatchedCollectionChange (todo: rename to make this explicit?)\n        handleBatchedChange() {\n            this.synchronizeElement();\n            this.notify(defaultHandleBatchedChangeFlags);\n        }\n        // handlePropertyChange (todo: rename normal subscribe methods in target observers to batched, since that's what they really are)\n        handleChange(newValue, previousValue, flags) {\n            this.synchronizeElement();\n            this.notify(flags);\n        }\n        synchronizeElement() {\n            const value = this.currentValue;\n            const element = this.obj;\n            const elementValue = element.hasOwnProperty('model') ? element['model'] : element.value;\n            const isRadio = element.type === 'radio';\n            const matcher = element['matcher'] || ((a, b) => a === b);\n            if (isRadio) {\n                element.checked = !!matcher(value, elementValue);\n            }\n            else if (value === true) {\n                element.checked = true;\n            }\n            else if (Array.isArray(value)) {\n                element.checked = value.findIndex(item => !!matcher(item, elementValue)) !== -1;\n            }\n            else {\n                element.checked = false;\n            }\n        }\n        notify(flags) {\n            if (flags & exports.LifecycleFlags.fromBind) {\n                return;\n            }\n            const oldValue = this.oldValue;\n            const newValue = this.currentValue;\n            if (newValue === oldValue) {\n                return;\n            }\n            this.callSubscribers(this.currentValue, this.oldValue, flags);\n        }\n        handleEvent() {\n            let value = this.currentValue;\n            const element = this.obj;\n            const elementValue = element.hasOwnProperty('model') ? element['model'] : element.value;\n            let index;\n            const matcher = element['matcher'] || defaultMatcher;\n            if (element.type === 'checkbox') {\n                if (Array.isArray(value)) {\n                    index = value.findIndex(item => !!matcher(item, elementValue));\n                    if (element.checked && index === -1) {\n                        value.push(elementValue);\n                    }\n                    else if (!element.checked && index !== -1) {\n                        value.splice(index, 1);\n                    }\n                    // when existing value is array, do not invoke callback as only the array element has changed\n                    return;\n                }\n                value = element.checked;\n            }\n            else if (element.checked) {\n                value = elementValue;\n            }\n            else {\n                return;\n            }\n            this.oldValue = this.currentValue;\n            this.currentValue = value;\n            this.notify(handleEventFlags);\n        }\n        subscribe(subscriber) {\n            if (!this.hasSubscribers()) {\n                this.handler.subscribe(this.obj, this);\n            }\n            this.addSubscriber(subscriber);\n        }\n        unsubscribe(subscriber) {\n            if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n                this.handler.dispose();\n            }\n        }\n        unbind() {\n            if (this.arrayObserver) {\n                this.arrayObserver.unsubscribeBatched(this);\n                this.arrayObserver = null;\n            }\n            if (this.valueObserver) {\n                this.valueObserver.unsubscribe(this);\n            }\n        }\n    };\n    exports.CheckedObserver = __decorate([\n        targetObserver()\n    ], exports.CheckedObserver);\n    exports.CheckedObserver.prototype.handler = null;\n    exports.CheckedObserver.prototype.observerLocator = null;\n    const childObserverOptions = {\n        childList: true,\n        subtree: true,\n        characterData: true\n    };\n    function defaultMatcher(a, b) {\n        return a === b;\n    }\n    exports.SelectValueObserver = class SelectValueObserver {\n        constructor(lifecycle, obj, handler, observerLocator) {\n            this.lifecycle = lifecycle;\n            this.obj = obj;\n            this.handler = handler;\n            this.observerLocator = observerLocator;\n        }\n        getValue() {\n            return this.currentValue;\n        }\n        setValueCore(newValue, flags) {\n            const isArray = Array.isArray(newValue);\n            if (!isArray && newValue !== null && newValue !== undefined && this.obj.multiple) {\n                throw new Error('Only null or Array instances can be bound to a multi-select.');\n            }\n            if (this.arrayObserver) {\n                this.arrayObserver.unsubscribeBatched(this);\n                this.arrayObserver = null;\n            }\n            if (isArray) {\n                this.arrayObserver = this.observerLocator.getArrayObserver(newValue);\n                this.arrayObserver.subscribeBatched(this);\n            }\n            this.synchronizeOptions();\n            this.notify(flags);\n        }\n        // called when the array mutated (items sorted/added/removed, etc)\n        handleBatchedChange(indexMap) {\n            // we don't need to go through the normal setValue logic and can directly call synchronizeOptions here,\n            // because the change already waited one tick (batched) and there's no point in calling notify when the instance didn't change\n            this.synchronizeOptions(indexMap);\n        }\n        // called when a different value was assigned\n        handleChange(newValue, previousValue, flags) {\n            this.setValue(newValue, flags);\n        }\n        notify(flags) {\n            if (flags & exports.LifecycleFlags.fromBind) {\n                return;\n            }\n            const oldValue = this.oldValue;\n            const newValue = this.currentValue;\n            if (newValue === oldValue) {\n                return;\n            }\n            this.callSubscribers(newValue, oldValue, flags);\n        }\n        handleEvent() {\n            // \"from-view\" changes are always synchronous now, so immediately sync the value and notify subscribers\n            const shouldNotify = this.synchronizeValue();\n            if (shouldNotify) {\n                this.notify(handleEventFlags);\n            }\n        }\n        synchronizeOptions(indexMap) {\n            const currentValue = this.currentValue;\n            const isArray = Array.isArray(currentValue);\n            const obj = this.obj;\n            const matcher = obj.matcher || defaultMatcher;\n            const options = obj.options;\n            let i = options.length;\n            while (i--) {\n                const option = options[i];\n                const optionValue = option.hasOwnProperty('model') ? option.model : option.value;\n                if (isArray) {\n                    option.selected = currentValue.findIndex(item => !!matcher(optionValue, item)) !== -1;\n                    continue;\n                }\n                option.selected = !!matcher(optionValue, currentValue);\n            }\n        }\n        synchronizeValue() {\n            // Spec for synchronizing value from `SelectObserver` to `<select/>`\n            // When synchronizing value to observed <select/> element, do the following steps:\n            // A. If `<select/>` is multiple\n            //    1. Check if current value, called `currentValue` is an array\n            //      a. If not an array, return true to signal value has changed\n            //      b. If is an array:\n            //        i. gather all current selected <option/>, in to array called `values`\n            //        ii. loop through the `currentValue` array and remove items that are nolonger selected based on matcher\n            //        iii. loop through the `values` array and add items that are selected based on matcher\n            //        iv. Return false to signal value hasn't changed\n            // B. If the select is single\n            //    1. Let `value` equal the first selected option, if no option selected, then `value` is `null`\n            //    2. assign `this.currentValue` to `this.oldValue`\n            //    3. assign `value` to `this.currentValue`\n            //    4. return `true` to signal value has changed\n            const obj = this.obj;\n            const options = obj.options;\n            const len = options.length;\n            const currentValue = this.currentValue;\n            let i = 0;\n            if (obj.multiple) {\n                // A.\n                if (!Array.isArray(currentValue)) {\n                    // A.1.a\n                    return true;\n                }\n                // A.1.b\n                // multi select\n                let option;\n                const matcher = obj.matcher || defaultMatcher;\n                // A.1.b.i\n                const values = [];\n                while (i < len) {\n                    option = options[i];\n                    if (option.selected) {\n                        values.push(option.hasOwnProperty('model')\n                            ? option.model\n                            : option.value);\n                    }\n                    ++i;\n                }\n                // A.1.b.ii\n                i = 0;\n                while (i < currentValue.length) {\n                    const a = currentValue[i];\n                    // Todo: remove arrow fn\n                    if (values.findIndex(b => !!matcher(a, b)) === -1) {\n                        currentValue.splice(i, 1);\n                    }\n                    else {\n                        ++i;\n                    }\n                }\n                // A.1.b.iii\n                i = 0;\n                while (i < values.length) {\n                    const a = values[i];\n                    // Todo: remove arrow fn\n                    if (currentValue.findIndex(b => !!matcher(a, b)) === -1) {\n                        currentValue.push(a);\n                    }\n                    ++i;\n                }\n                // A.1.b.iv\n                return false;\n            }\n            // B. single select\n            // B.1\n            let value = null;\n            while (i < len) {\n                const option = options[i];\n                if (option.selected) {\n                    value = option.hasOwnProperty('model')\n                        ? option.model\n                        : option.value;\n                    break;\n                }\n                ++i;\n            }\n            // B.2\n            this.oldValue = this.currentValue;\n            // B.3\n            this.currentValue = value;\n            // B.4\n            return true;\n        }\n        subscribe(subscriber) {\n            if (!this.hasSubscribers()) {\n                this.handler.subscribe(this.obj, this);\n            }\n            this.addSubscriber(subscriber);\n        }\n        unsubscribe(subscriber) {\n            if (this.removeSubscriber(subscriber) && !this.hasSubscribers()) {\n                this.handler.dispose();\n            }\n        }\n        bind() {\n            this.nodeObserver = DOM.createNodeObserver(this.obj, this.handleNodeChange.bind(this), childObserverOptions);\n        }\n        unbind() {\n            this.nodeObserver.disconnect();\n            this.nodeObserver = null;\n            if (this.arrayObserver) {\n                this.arrayObserver.unsubscribeBatched(this);\n                this.arrayObserver = null;\n            }\n        }\n        handleNodeChange() {\n            this.synchronizeOptions();\n            const shouldNotify = this.synchronizeValue();\n            if (shouldNotify) {\n                this.notify(handleEventFlags);\n            }\n        }\n    };\n    exports.SelectValueObserver = __decorate([\n        targetObserver()\n    ], exports.SelectValueObserver);\n    exports.SelectValueObserver.prototype.handler = null;\n    exports.SelectValueObserver.prototype.observerLocator = null;\n\n    const proto$1 = Map.prototype;\n    const nativeSet = proto$1.set; // TODO: probably want to make these internal again\n    const nativeClear = proto$1.clear;\n    const nativeDelete = proto$1.delete;\n    // note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls\n    // fortunately, map/delete/clear are easy to reconstruct for the indexMap\n    // https://tc39.github.io/ecma262/#sec-map.prototype.map\n    function observeSet(key, value) {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeSet.call(this, key, value);\n        }\n        const oldSize = this.size;\n        nativeSet.call(this, key, value);\n        const newSize = this.size;\n        if (newSize === oldSize) {\n            let i = 0;\n            for (const entry of this.entries()) {\n                if (entry[0] === key) {\n                    if (entry[1] !== value) {\n                        o.indexMap[i] = -2;\n                    }\n                    return this;\n                }\n                i++;\n            }\n            return this;\n        }\n        o.indexMap[oldSize] = -2;\n        o.callSubscribers('set', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return this;\n    }\n    // https://tc39.github.io/ecma262/#sec-map.prototype.clear\n    function observeClear() {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeClear.call(this);\n        }\n        const size = this.size;\n        if (size > 0) {\n            const indexMap = o.indexMap;\n            let i = 0;\n            for (const entry of this.keys()) {\n                if (indexMap[i] > -1) {\n                    nativePush.call(indexMap.deletedItems, entry);\n                }\n                i++;\n            }\n            nativeClear.call(this);\n            indexMap.length = 0;\n            o.callSubscribers('clear', arguments, exports.LifecycleFlags.isCollectionMutation);\n        }\n        return undefined;\n    }\n    // https://tc39.github.io/ecma262/#sec-map.prototype.delete\n    function observeDelete(value) {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeDelete.call(this, value);\n        }\n        const size = this.size;\n        if (size === 0) {\n            return false;\n        }\n        let i = 0;\n        const indexMap = o.indexMap;\n        for (const entry of this.keys()) {\n            if (entry === value) {\n                if (indexMap[i] > -1) {\n                    nativePush.call(indexMap.deletedItems, entry);\n                }\n                nativeSplice.call(indexMap, i, 1);\n                return nativeDelete.call(this, value);\n            }\n            i++;\n        }\n        o.callSubscribers('delete', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return false;\n    }\n    for (const observe of [observeSet, observeClear, observeDelete]) {\n        Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n    }\n    function enableMapObservation() {\n        if (proto$1.set['observing'] !== true)\n            proto$1.set = observeSet;\n        if (proto$1.clear['observing'] !== true)\n            proto$1.clear = observeClear;\n        if (proto$1.delete['observing'] !== true)\n            proto$1.delete = observeDelete;\n    }\n    enableMapObservation();\n    function disableMapObservation() {\n        if (proto$1.set['observing'] === true)\n            proto$1.set = nativeSet;\n        if (proto$1.clear['observing'] === true)\n            proto$1.clear = nativeClear;\n        if (proto$1.delete['observing'] === true)\n            proto$1.delete = nativeDelete;\n    }\n    exports.MapObserver = class MapObserver {\n        constructor(lifecycle, map) {\n            this.lifecycle = lifecycle;\n            map.$observer = this;\n            this.collection = map;\n            this.resetIndexMap();\n        }\n    };\n    exports.MapObserver = __decorate([\n        collectionObserver(6 /* map */)\n    ], exports.MapObserver);\n    function getMapObserver(lifecycle, map) {\n        return map.$observer || new exports.MapObserver(lifecycle, map);\n    }\n\n    const proto$2 = Set.prototype;\n    const nativeAdd = proto$2.add; // TODO: probably want to make these internal again\n    const nativeClear$1 = proto$2.clear;\n    const nativeDelete$1 = proto$2.delete;\n    // note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls\n    // fortunately, add/delete/clear are easy to reconstruct for the indexMap\n    // https://tc39.github.io/ecma262/#sec-set.prototype.add\n    function observeAdd(value) {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeAdd.call(this, value);\n        }\n        const oldSize = this.size;\n        nativeAdd.call(this, value);\n        const newSize = this.size;\n        if (newSize === oldSize) {\n            return this;\n        }\n        o.indexMap[oldSize] = -2;\n        o.callSubscribers('add', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return this;\n    }\n    // https://tc39.github.io/ecma262/#sec-set.prototype.clear\n    function observeClear$1() {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeClear$1.call(this);\n        }\n        const size = this.size;\n        if (size > 0) {\n            const indexMap = o.indexMap;\n            let i = 0;\n            for (const entry of this.keys()) {\n                if (indexMap[i] > -1) {\n                    nativePush.call(indexMap.deletedItems, entry);\n                }\n                i++;\n            }\n            nativeClear$1.call(this);\n            indexMap.length = 0;\n            o.callSubscribers('clear', arguments, exports.LifecycleFlags.isCollectionMutation);\n        }\n        return undefined;\n    }\n    // https://tc39.github.io/ecma262/#sec-set.prototype.delete\n    function observeDelete$1(value) {\n        const o = this.$observer;\n        if (o === undefined) {\n            return nativeDelete$1.call(this, value);\n        }\n        const size = this.size;\n        if (size === 0) {\n            return false;\n        }\n        let i = 0;\n        const indexMap = o.indexMap;\n        for (const entry of this.keys()) {\n            if (entry === value) {\n                if (indexMap[i] > -1) {\n                    nativePush.call(indexMap.deletedItems, entry);\n                }\n                nativeSplice.call(indexMap, i, 1);\n                return nativeDelete$1.call(this, value);\n            }\n            i++;\n        }\n        o.callSubscribers('delete', arguments, exports.LifecycleFlags.isCollectionMutation);\n        return false;\n    }\n    for (const observe of [observeAdd, observeClear$1, observeDelete$1]) {\n        Object.defineProperty(observe, 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n    }\n    function enableSetObservation() {\n        if (proto$2.add['observing'] !== true)\n            proto$2.add = observeAdd;\n        if (proto$2.clear['observing'] !== true)\n            proto$2.clear = observeClear$1;\n        if (proto$2.delete['observing'] !== true)\n            proto$2.delete = observeDelete$1;\n    }\n    enableSetObservation();\n    function disableSetObservation() {\n        if (proto$2.add['observing'] === true)\n            proto$2.add = nativeAdd;\n        if (proto$2.clear['observing'] === true)\n            proto$2.clear = nativeClear$1;\n        if (proto$2.delete['observing'] === true)\n            proto$2.delete = nativeDelete$1;\n    }\n    exports.SetObserver = class SetObserver {\n        constructor(lifecycle, observedSet) {\n            this.lifecycle = lifecycle;\n            observedSet.$observer = this;\n            this.collection = observedSet;\n            this.resetIndexMap();\n        }\n    };\n    exports.SetObserver = __decorate([\n        collectionObserver(7 /* set */)\n    ], exports.SetObserver);\n    function getSetObserver(lifecycle, observedSet) {\n        return observedSet.$observer || new exports.SetObserver(lifecycle, observedSet);\n    }\n\n    const ISVGAnalyzer = kernel.DI.createInterface()\n        .withDefault(x => x.singleton(class {\n        isStandardSvgAttribute(node, attributeName) {\n            return false;\n        }\n    }));\n\n    const toStringTag$1 = Object.prototype.toString;\n    const IObserverLocator = kernel.DI.createInterface()\n        .withDefault(x => x.singleton(exports.ObserverLocator));\n    function getPropertyDescriptor(subject, name) {\n        let pd = Object.getOwnPropertyDescriptor(subject, name);\n        let proto = Object.getPrototypeOf(subject);\n        while (pd === undefined && proto !== null) {\n            pd = Object.getOwnPropertyDescriptor(proto, name);\n            proto = Object.getPrototypeOf(proto);\n        }\n        return pd;\n    }\n    exports.ObserverLocator = \n    /*@internal*/\n    class ObserverLocator {\n        constructor(lifecycle, eventManager, dirtyChecker, svgAnalyzer) {\n            this.lifecycle = lifecycle;\n            this.eventManager = eventManager;\n            this.dirtyChecker = dirtyChecker;\n            this.svgAnalyzer = svgAnalyzer;\n            this.adapters = [];\n        }\n        getObserver(obj, propertyName) {\n            if (obj.$synthetic === true) {\n                return obj.getObservers().getOrCreate(obj, propertyName);\n            }\n            let observersLookup = obj.$observers;\n            let observer;\n            if (observersLookup && propertyName in observersLookup) {\n                return observersLookup[propertyName];\n            }\n            observer = this.createPropertyObserver(obj, propertyName);\n            if (!observer.doNotCache) {\n                if (observersLookup === undefined) {\n                    observersLookup = this.getOrCreateObserversLookup(obj);\n                }\n                observersLookup[propertyName] = observer;\n            }\n            return observer;\n        }\n        addAdapter(adapter) {\n            this.adapters.push(adapter);\n        }\n        getAccessor(obj, propertyName) {\n            if (DOM.isNodeInstance(obj)) {\n                const tagName = obj['tagName'];\n                // this check comes first for hot path optimization\n                if (propertyName === 'textContent') {\n                    return new exports.ElementPropertyAccessor(this.lifecycle, obj, propertyName);\n                }\n                // TODO: optimize and make pluggable\n                if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css'\n                    || propertyName === 'value' && (tagName === 'INPUT' || tagName === 'SELECT')\n                    || propertyName === 'checked' && tagName === 'INPUT'\n                    || propertyName === 'model' && tagName === 'INPUT'\n                    || /^xlink:.+$/.exec(propertyName)) {\n                    return this.getObserver(obj, propertyName);\n                }\n                if (/^\\w+:|^data-|^aria-/.test(propertyName)\n                    || this.svgAnalyzer.isStandardSvgAttribute(obj, propertyName)\n                    || tagName === 'IMG' && propertyName === 'src'\n                    || tagName === 'A' && propertyName === 'href') {\n                    return new exports.DataAttributeAccessor(this.lifecycle, obj, propertyName);\n                }\n                return new exports.ElementPropertyAccessor(this.lifecycle, obj, propertyName);\n            }\n            return new PropertyAccessor(obj, propertyName);\n        }\n        getArrayObserver(observedArray) {\n            return getArrayObserver(this.lifecycle, observedArray);\n        }\n        getMapObserver(observedMap) {\n            return getMapObserver(this.lifecycle, observedMap);\n        }\n        getSetObserver(observedSet) {\n            return getSetObserver(this.lifecycle, observedSet);\n        }\n        getOrCreateObserversLookup(obj) {\n            return obj.$observers || this.createObserversLookup(obj);\n        }\n        createObserversLookup(obj) {\n            const value = {};\n            if (!Reflect.defineProperty(obj, '$observers', {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: value\n            })) {\n                kernel.Reporter.write(0, obj);\n            }\n            return value;\n        }\n        getAdapterObserver(obj, propertyName, descriptor) {\n            for (let i = 0, ii = this.adapters.length; i < ii; i++) {\n                const adapter = this.adapters[i];\n                const observer = adapter.getObserver(obj, propertyName, descriptor);\n                if (observer) {\n                    return observer;\n                }\n            }\n            return null;\n        }\n        createPropertyObserver(obj, propertyName) {\n            if (!(obj instanceof Object)) {\n                return new PrimitiveObserver(obj, propertyName);\n            }\n            let isNode;\n            if (DOM.isNodeInstance(obj)) {\n                if (propertyName === 'class') {\n                    return new exports.ClassAttributeAccessor(this.lifecycle, obj);\n                }\n                if (propertyName === 'style' || propertyName === 'css') {\n                    return new exports.StyleAttributeAccessor(this.lifecycle, obj);\n                }\n                const tagName = obj['tagName'];\n                const handler = this.eventManager.getElementHandler(obj, propertyName);\n                if (propertyName === 'value' && tagName === 'SELECT') {\n                    return new exports.SelectValueObserver(this.lifecycle, obj, handler, this);\n                }\n                if (propertyName === 'checked' && tagName === 'INPUT') {\n                    return new exports.CheckedObserver(this.lifecycle, obj, handler, this);\n                }\n                if (handler) {\n                    return new exports.ValueAttributeObserver(this.lifecycle, obj, propertyName, handler);\n                }\n                const xlinkResult = /^xlink:(.+)$/.exec(propertyName);\n                if (xlinkResult) {\n                    return new exports.XLinkAttributeAccessor(this.lifecycle, obj, propertyName, xlinkResult[1]);\n                }\n                if (propertyName === 'role'\n                    || /^\\w+:|^data-|^aria-/.test(propertyName)\n                    || this.svgAnalyzer.isStandardSvgAttribute(obj, propertyName)) {\n                    return new exports.DataAttributeAccessor(this.lifecycle, obj, propertyName);\n                }\n                isNode = true;\n            }\n            const tag = toStringTag$1.call(obj);\n            switch (tag) {\n                case '[object Array]':\n                    if (propertyName === 'length') {\n                        return this.getArrayObserver(obj).getLengthObserver();\n                    }\n                    return this.dirtyChecker.createProperty(obj, propertyName);\n                case '[object Map]':\n                    if (propertyName === 'size') {\n                        return this.getMapObserver(obj).getLengthObserver();\n                    }\n                    return this.dirtyChecker.createProperty(obj, propertyName);\n                case '[object Set]':\n                    if (propertyName === 'size') {\n                        return this.getSetObserver(obj).getLengthObserver();\n                    }\n                    return this.dirtyChecker.createProperty(obj, propertyName);\n            }\n            const descriptor = getPropertyDescriptor(obj, propertyName);\n            if (descriptor) {\n                if (descriptor.get || descriptor.set) {\n                    if (descriptor.get && descriptor.get.getObserver) {\n                        return descriptor.get.getObserver(obj);\n                    }\n                    // attempt to use an adapter before resorting to dirty checking.\n                    const adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);\n                    if (adapterObserver) {\n                        return adapterObserver;\n                    }\n                    if (isNode) {\n                        // TODO: use MutationObserver\n                        return this.dirtyChecker.createProperty(obj, propertyName);\n                    }\n                    return createComputedObserver(this, this.dirtyChecker, this.lifecycle, obj, propertyName, descriptor);\n                }\n            }\n            return new exports.SetterObserver(obj, propertyName);\n        }\n    };\n    exports.ObserverLocator = __decorate([\n        kernel.inject(ILifecycle, IEventManager, IDirtyChecker, ISVGAnalyzer)\n        /*@internal*/\n    ], exports.ObserverLocator);\n    function getCollectionObserver(lifecycle, collection) {\n        switch (toStringTag$1.call(collection)) {\n            case '[object Array]':\n                return getArrayObserver(lifecycle, collection);\n            case '[object Map]':\n                return getMapObserver(lifecycle, collection);\n            case '[object Set]':\n                return getSetObserver(lifecycle, collection);\n        }\n        return null;\n    }\n\n    exports.UpdateTriggerBindingBehavior = class UpdateTriggerBindingBehavior {\n        constructor(observerLocator) {\n            this.observerLocator = observerLocator;\n        }\n        bind(flags, scope, binding, ...events) {\n            if (events.length === 0) {\n                throw kernel.Reporter.error(9);\n            }\n            if (binding.mode !== exports.BindingMode.twoWay && binding.mode !== exports.BindingMode.fromView) {\n                throw kernel.Reporter.error(10);\n            }\n            // ensure the binding's target observer has been set.\n            const targetObserver = this.observerLocator.getObserver(binding.target, binding.targetProperty);\n            if (!targetObserver.handler) {\n                throw kernel.Reporter.error(10);\n            }\n            binding.targetObserver = targetObserver;\n            // stash the original element subscribe function.\n            targetObserver.originalHandler = binding.targetObserver.handler;\n            // replace the element subscribe function with one that uses the correct events.\n            targetObserver.handler = new EventSubscriber(events);\n        }\n        unbind(flags, scope, binding) {\n            // restore the state of the binding.\n            binding.targetObserver.handler.dispose();\n            binding.targetObserver.handler = binding.targetObserver.originalHandler;\n            binding.targetObserver.originalHandler = null;\n        }\n    };\n    exports.UpdateTriggerBindingBehavior = __decorate([\n        bindingBehavior('updateTrigger'),\n        kernel.inject(IObserverLocator)\n    ], exports.UpdateTriggerBindingBehavior);\n\n    class Call {\n        constructor(sourceExpression, target, targetProperty, observerLocator, locator) {\n            this.sourceExpression = sourceExpression;\n            this.locator = locator;\n            this.$nextBind = null;\n            this.$prevBind = null;\n            this.$state = 0 /* none */;\n            this.targetObserver = observerLocator.getObserver(target, targetProperty);\n        }\n        callSource(args) {\n            const overrideContext = this.$scope.overrideContext;\n            Object.assign(overrideContext, args);\n            const result = this.sourceExpression.evaluate(exports.LifecycleFlags.mustEvaluate, this.$scope, this.locator);\n            for (const prop in args) {\n                delete overrideContext[prop];\n            }\n            return result;\n        }\n        $bind(flags, scope) {\n            if (this.$state & 2 /* isBound */) {\n                if (this.$scope === scope) {\n                    return;\n                }\n                this.$unbind(flags | exports.LifecycleFlags.fromBind);\n            }\n            // add isBinding flag\n            this.$state |= 1 /* isBinding */;\n            this.$scope = scope;\n            const sourceExpression = this.sourceExpression;\n            if (hasBind(sourceExpression)) {\n                sourceExpression.bind(flags, scope, this);\n            }\n            this.targetObserver.setValue($args => this.callSource($args), flags);\n            // add isBound flag and remove isBinding flag\n            this.$state |= 2 /* isBound */;\n            this.$state &= ~1 /* isBinding */;\n        }\n        $unbind(flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            // add isUnbinding flag\n            this.$state |= 64 /* isUnbinding */;\n            const sourceExpression = this.sourceExpression;\n            if (hasUnbind(sourceExpression)) {\n                sourceExpression.unbind(flags, this.$scope, this);\n            }\n            this.$scope = null;\n            this.targetObserver.setValue(null, flags);\n            // remove isBound and isUnbinding flags\n            this.$state &= ~(2 /* isBound */ | 64 /* isUnbinding */);\n        }\n        // tslint:disable:no-empty no-any\n        observeProperty(obj, propertyName) { }\n        handleChange(newValue, previousValue, flags) { }\n    }\n\n    const IExpressionParser = kernel.DI.createInterface()\n        .withDefault(x => x.singleton(ExpressionParser));\n    /*@internal*/\n    class ExpressionParser {\n        constructor() {\n            this.expressionLookup = Object.create(null);\n            this.interpolationLookup = Object.create(null);\n            this.forOfLookup = Object.create(null);\n        }\n        parse(expression, bindingType) {\n            switch (bindingType) {\n                case 2048 /* Interpolation */:\n                    {\n                        let found = this.interpolationLookup[expression];\n                        if (found === undefined) {\n                            found = this.interpolationLookup[expression] = this.parseCore(expression, bindingType);\n                        }\n                        return found;\n                    }\n                case 539 /* ForCommand */:\n                    {\n                        let found = this.forOfLookup[expression];\n                        if (found === undefined) {\n                            found = this.forOfLookup[expression] = this.parseCore(expression, bindingType);\n                        }\n                        return found;\n                    }\n                default:\n                    {\n                        // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)\n                        // But don't cache it, because empty strings are always invalid for any other type of binding\n                        if (expression.length === 0 && (bindingType & (53 /* BindCommand */ | 49 /* OneTimeCommand */ | 50 /* ToViewCommand */))) {\n                            return PrimitiveLiteral.$empty;\n                        }\n                        let found = this.expressionLookup[expression];\n                        if (found === undefined) {\n                            found = this.expressionLookup[expression] = this.parseCore(expression, bindingType);\n                        }\n                        return found;\n                    }\n            }\n        }\n        cache(expressions) {\n            const { forOfLookup, expressionLookup, interpolationLookup } = this;\n            for (const expression in expressions) {\n                const expr = expressions[expression];\n                switch (expr.$kind) {\n                    case 24 /* Interpolation */:\n                        interpolationLookup[expression] = expr;\n                        break;\n                    case 55 /* ForOfStatement */:\n                        forOfLookup[expression] = expr;\n                        break;\n                    default:\n                        expressionLookup[expression] = expr;\n                }\n            }\n        }\n        parseCore(expression, bindingType) {\n            try {\n                const parts = expression.split('.');\n                const firstPart = parts[0];\n                let current;\n                if (firstPart.endsWith('()')) {\n                    current = new CallScope(firstPart.replace('()', ''), kernel.PLATFORM.emptyArray);\n                }\n                else {\n                    current = new AccessScope(parts[0]);\n                }\n                let index = 1;\n                while (index < parts.length) {\n                    const currentPart = parts[index];\n                    if (currentPart.endsWith('()')) {\n                        current = new CallMember(current, currentPart.replace('()', ''), kernel.PLATFORM.emptyArray);\n                    }\n                    else {\n                        current = new AccessMember(current, parts[index]);\n                    }\n                    index++;\n                }\n                return current;\n            }\n            catch (e) {\n                throw kernel.Reporter.error(3, e);\n            }\n        }\n    }\n\n    // tslint:disable:no-any\n    const { toView: toView$2, oneTime: oneTime$2 } = exports.BindingMode;\n    class MultiInterpolationBinding {\n        constructor(observerLocator, interpolation, target, targetProperty, mode, locator) {\n            this.observerLocator = observerLocator;\n            this.interpolation = interpolation;\n            this.target = target;\n            this.targetProperty = targetProperty;\n            this.mode = mode;\n            this.locator = locator;\n            this.$nextBind = null;\n            this.$prevBind = null;\n            this.$state = 0 /* none */;\n            this.$scope = null;\n            // Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include\n            // value converters and binding behaviors.\n            // Each expression represents one ${interpolation}, and for each we create a child TextBinding unless there is only one,\n            // in which case the renderer will create the TextBinding directly\n            const expressions = interpolation.expressions;\n            const parts = this.parts = Array(expressions.length);\n            for (let i = 0, ii = expressions.length; i < ii; ++i) {\n                parts[i] = new exports.InterpolationBinding(expressions[i], interpolation, target, targetProperty, mode, observerLocator, locator, i === 0);\n            }\n        }\n        $bind(flags, scope) {\n            if (this.$state & 2 /* isBound */) {\n                if (this.$scope === scope) {\n                    return;\n                }\n                this.$unbind(flags);\n            }\n            this.$state |= 2 /* isBound */;\n            this.$scope = scope;\n            const parts = this.parts;\n            for (let i = 0, ii = parts.length; i < ii; ++i) {\n                parts[i].$bind(flags, scope);\n            }\n        }\n        $unbind(flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            this.$state &= ~2 /* isBound */;\n            this.$scope = null;\n            const parts = this.parts;\n            for (let i = 0, ii = parts.length; i < ii; ++i) {\n                parts[i].$unbind(flags);\n            }\n        }\n    }\n    exports.InterpolationBinding = class InterpolationBinding {\n        constructor(sourceExpression, interpolation, target, targetProperty, mode, observerLocator, locator, isFirst) {\n            this.sourceExpression = sourceExpression;\n            this.interpolation = interpolation;\n            this.target = target;\n            this.targetProperty = targetProperty;\n            this.mode = mode;\n            this.observerLocator = observerLocator;\n            this.locator = locator;\n            this.isFirst = isFirst;\n            this.$state = 0 /* none */;\n            this.targetObserver = observerLocator.getAccessor(target, targetProperty);\n        }\n        updateTarget(value, flags) {\n            this.targetObserver.setValue(value, flags | exports.LifecycleFlags.updateTargetInstance);\n        }\n        handleChange(newValue, previousValue, flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            previousValue = this.targetObserver.getValue();\n            newValue = this.interpolation.evaluate(flags, this.$scope, this.locator);\n            if (newValue !== previousValue) {\n                this.updateTarget(newValue, flags);\n            }\n            if ((this.mode & oneTime$2) === 0) {\n                this.version++;\n                this.sourceExpression.connect(flags, this.$scope, this);\n                this.unobserve(false);\n            }\n        }\n        $bind(flags, scope) {\n            if (this.$state & 2 /* isBound */) {\n                if (this.$scope === scope) {\n                    return;\n                }\n                this.$unbind(flags);\n            }\n            this.$state |= 2 /* isBound */;\n            this.$scope = scope;\n            const sourceExpression = this.sourceExpression;\n            if (sourceExpression.bind) {\n                sourceExpression.bind(flags, scope, this);\n            }\n            // since the interpolation already gets the whole value, we only need to let the first\n            // text binding do the update if there are multiple\n            if (this.isFirst) {\n                this.updateTarget(this.interpolation.evaluate(flags, scope, this.locator), flags);\n            }\n            if (this.mode & toView$2) {\n                sourceExpression.connect(flags, scope, this);\n            }\n        }\n        $unbind(flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            this.$state &= ~2 /* isBound */;\n            const sourceExpression = this.sourceExpression;\n            if (sourceExpression.unbind) {\n                sourceExpression.unbind(flags, this.$scope, this);\n            }\n            this.$scope = null;\n            this.unobserve(true);\n        }\n    };\n    exports.InterpolationBinding = __decorate([\n        connectable()\n    ], exports.InterpolationBinding);\n\n    exports.LetBinding = class LetBinding {\n        constructor(sourceExpression, targetProperty, observerLocator, locator, toViewModel = false) {\n            this.sourceExpression = sourceExpression;\n            this.targetProperty = targetProperty;\n            this.observerLocator = observerLocator;\n            this.locator = locator;\n            this.toViewModel = toViewModel;\n            this.$nextBind = null;\n            this.$prevBind = null;\n            this.$state = 0 /* none */;\n            this.$scope = null;\n            this.target = null;\n            this.$lifecycle = locator.get(ILifecycle);\n        }\n        handleChange(newValue, previousValue, flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            if (flags & exports.LifecycleFlags.updateTargetInstance) {\n                const { target, targetProperty } = this;\n                previousValue = target[targetProperty];\n                newValue = this.sourceExpression.evaluate(flags, this.$scope, this.locator);\n                if (newValue !== previousValue) {\n                    target[targetProperty] = newValue;\n                }\n                return;\n            }\n            throw kernel.Reporter.error(15, flags);\n        }\n        $bind(flags, scope) {\n            if (this.$state & 2 /* isBound */) {\n                if (this.$scope === scope) {\n                    return;\n                }\n                this.$unbind(flags | exports.LifecycleFlags.fromBind);\n            }\n            // add isBinding flag\n            this.$state |= 1 /* isBinding */;\n            this.$scope = scope;\n            this.target = this.toViewModel ? scope.bindingContext : scope.overrideContext;\n            const sourceExpression = this.sourceExpression;\n            if (sourceExpression.bind) {\n                sourceExpression.bind(flags, scope, this);\n            }\n            // sourceExpression might have been changed during bind\n            this.target[this.targetProperty] = this.sourceExpression.evaluate(exports.LifecycleFlags.fromBind, scope, this.locator);\n            this.sourceExpression.connect(flags, scope, this);\n            // add isBound flag and remove isBinding flag\n            this.$state |= 2 /* isBound */;\n            this.$state &= ~1 /* isBinding */;\n        }\n        $unbind(flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            // add isUnbinding flag\n            this.$state |= 64 /* isUnbinding */;\n            const sourceExpression = this.sourceExpression;\n            if (sourceExpression.unbind) {\n                sourceExpression.unbind(flags, this.$scope, this);\n            }\n            this.$scope = null;\n            this.unobserve(true);\n            // remove isBound and isUnbinding flags\n            this.$state &= ~(2 /* isBound */ | 64 /* isUnbinding */);\n        }\n    };\n    exports.LetBinding = __decorate([\n        connectable()\n    ], exports.LetBinding);\n\n    class Listener {\n        constructor(targetEvent, delegationStrategy, sourceExpression, target, preventDefault, eventManager, locator) {\n            this.targetEvent = targetEvent;\n            this.delegationStrategy = delegationStrategy;\n            this.sourceExpression = sourceExpression;\n            this.target = target;\n            this.preventDefault = preventDefault;\n            this.eventManager = eventManager;\n            this.locator = locator;\n            this.$nextBind = null;\n            this.$prevBind = null;\n            this.$state = 0 /* none */;\n        }\n        callSource(event) {\n            const overrideContext = this.$scope.overrideContext;\n            overrideContext['$event'] = event;\n            const result = this.sourceExpression.evaluate(exports.LifecycleFlags.mustEvaluate, this.$scope, this.locator);\n            delete overrideContext['$event'];\n            if (result !== true && this.preventDefault) {\n                event.preventDefault();\n            }\n            return result;\n        }\n        handleEvent(event) {\n            this.callSource(event);\n        }\n        $bind(flags, scope) {\n            if (this.$state & 2 /* isBound */) {\n                if (this.$scope === scope) {\n                    return;\n                }\n                this.$unbind(flags | exports.LifecycleFlags.fromBind);\n            }\n            // add isBinding flag\n            this.$state |= 1 /* isBinding */;\n            this.$scope = scope;\n            const sourceExpression = this.sourceExpression;\n            if (hasBind(sourceExpression)) {\n                sourceExpression.bind(flags, scope, this);\n            }\n            this.handler = this.eventManager.addEventListener(this.target, this.targetEvent, this, this.delegationStrategy);\n            // add isBound flag and remove isBinding flag\n            this.$state |= 2 /* isBound */;\n            this.$state &= ~1 /* isBinding */;\n        }\n        $unbind(flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            // add isUnbinding flag\n            this.$state |= 64 /* isUnbinding */;\n            const sourceExpression = this.sourceExpression;\n            if (hasUnbind(sourceExpression)) {\n                sourceExpression.unbind(flags, this.$scope, this);\n            }\n            this.$scope = null;\n            this.handler.dispose();\n            this.handler = null;\n            // remove isBound and isUnbinding flags\n            this.$state &= ~(2 /* isBound */ | 64 /* isUnbinding */);\n        }\n        // tslint:disable:no-empty no-any\n        observeProperty(obj, propertyName) { }\n        handleChange(newValue, previousValue, flags) { }\n    }\n\n    class Ref {\n        constructor(sourceExpression, target, locator) {\n            this.sourceExpression = sourceExpression;\n            this.target = target;\n            this.locator = locator;\n            this.$nextBind = null;\n            this.$prevBind = null;\n            this.$state = 0 /* none */;\n        }\n        $bind(flags, scope) {\n            if (this.$state & 2 /* isBound */) {\n                if (this.$scope === scope) {\n                    return;\n                }\n                this.$unbind(flags | exports.LifecycleFlags.fromBind);\n            }\n            // add isBinding flag\n            this.$state |= 1 /* isBinding */;\n            this.$scope = scope;\n            const sourceExpression = this.sourceExpression;\n            if (hasBind(sourceExpression)) {\n                sourceExpression.bind(flags, scope, this);\n            }\n            this.sourceExpression.assign(flags, this.$scope, this.locator, this.target);\n            // add isBound flag and remove isBinding flag\n            this.$state |= 2 /* isBound */;\n            this.$state &= ~1 /* isBinding */;\n        }\n        $unbind(flags) {\n            if (!(this.$state & 2 /* isBound */)) {\n                return;\n            }\n            // add isUnbinding flag\n            this.$state |= 64 /* isUnbinding */;\n            if (this.sourceExpression.evaluate(flags, this.$scope, this.locator) === this.target) {\n                this.sourceExpression.assign(flags, this.$scope, this.locator, null);\n            }\n            const sourceExpression = this.sourceExpression;\n            if (hasUnbind(sourceExpression)) {\n                sourceExpression.unbind(flags, this.$scope, this);\n            }\n            this.$scope = null;\n            // remove isBound and isUnbinding flags\n            this.$state &= ~(2 /* isBound */ | 64 /* isUnbinding */);\n        }\n        // tslint:disable:no-empty no-any\n        observeProperty(obj, propertyName) { }\n        handleChange(newValue, previousValue, flags) { }\n    }\n\n    // tslint:disable:no-reserved-keywords\n    /*@internal*/\n    const customElementName = 'custom-element';\n    /*@internal*/\n    function customElementKey(name) {\n        return `${customElementName}:${name}`;\n    }\n    /*@internal*/\n    function customElementBehavior(node) {\n        return node.$customElement || null;\n    }\n    /*@internal*/\n    const customAttributeName = 'custom-attribute';\n    /*@internal*/\n    function customAttributeKey(name) {\n        return `${customAttributeName}:${name}`;\n    }\n    const instructionTypeValues = 'abcdefghijkl';\n    const ITargetedInstruction = kernel.DI.createInterface();\n    function isTargetedInstruction(value) {\n        const type = value.type;\n        return typeof type === 'string' && instructionTypeValues.indexOf(type) !== -1;\n    }\n    /*@internal*/\n    const buildRequired = Object.freeze({\n        required: true,\n        compiler: 'default'\n    });\n    const buildNotRequired = Object.freeze({\n        required: false,\n        compiler: 'default'\n    });\n    // Note: this is a little perf thing; having one predefined class with the properties always\n    // assigned in the same order ensures the browser can keep reusing the same generated hidden\n    // class\n    class DefaultTemplateDefinition {\n        constructor() {\n            this.name = 'unnamed';\n            this.template = null;\n            this.cache = 0;\n            this.build = buildNotRequired;\n            this.bindables = kernel.PLATFORM.emptyObject;\n            this.instructions = kernel.PLATFORM.emptyArray;\n            this.dependencies = kernel.PLATFORM.emptyArray;\n            this.surrogates = kernel.PLATFORM.emptyArray;\n            this.containerless = false;\n            this.shadowOptions = null;\n            this.hasSlots = false;\n        }\n    }\n    const templateDefinitionAssignables = [\n        'name',\n        'template',\n        'cache',\n        'build',\n        'containerless',\n        'shadowOptions',\n        'hasSlots'\n    ];\n    const templateDefinitionArrays = [\n        'instructions',\n        'dependencies',\n        'surrogates'\n    ];\n    function buildTemplateDefinition(ctor, nameOrDef, template, cache, build, bindables, instructions, dependencies, surrogates, containerless, shadowOptions, hasSlots) {\n        const def = new DefaultTemplateDefinition();\n        // all cases fall through intentionally\n        const argLen = arguments.length;\n        switch (argLen) {\n            case 12: if (hasSlots !== null)\n                def.hasSlots = hasSlots;\n            case 11: if (shadowOptions !== null)\n                def.shadowOptions = shadowOptions;\n            case 10: if (containerless !== null)\n                def.containerless = containerless;\n            case 9: if (surrogates !== null)\n                def.surrogates = kernel.PLATFORM.toArray(surrogates);\n            case 8: if (dependencies !== null)\n                def.dependencies = kernel.PLATFORM.toArray(dependencies);\n            case 7: if (instructions !== null)\n                def.instructions = kernel.PLATFORM.toArray(instructions);\n            case 6: if (bindables !== null)\n                def.bindables = Object.assign({}, bindables);\n            case 5: if (build !== null)\n                def.build = build === true ? buildRequired : build === false ? buildNotRequired : Object.assign({}, build);\n            case 4: if (cache !== null)\n                def.cache = cache;\n            case 3: if (template !== null)\n                def.template = template;\n            case 2:\n                if (ctor !== null) {\n                    if (ctor['bindables']) {\n                        def.bindables = Object.assign({}, ctor.bindables);\n                    }\n                    if (ctor['containerless']) {\n                        def.containerless = ctor.containerless;\n                    }\n                    if (ctor['shadowOptions']) {\n                        def.shadowOptions = ctor.shadowOptions;\n                    }\n                }\n                if (typeof nameOrDef === 'string') {\n                    if (nameOrDef.length > 0) {\n                        def.name = nameOrDef;\n                    }\n                }\n                else if (nameOrDef !== null) {\n                    templateDefinitionAssignables.forEach(prop => {\n                        if (nameOrDef[prop]) {\n                            def[prop] = nameOrDef[prop];\n                        }\n                    });\n                    templateDefinitionArrays.forEach(prop => {\n                        if (nameOrDef[prop]) {\n                            def[prop] = kernel.PLATFORM.toArray(nameOrDef[prop]);\n                        }\n                    });\n                    if (nameOrDef['bindables']) {\n                        if (def.bindables === kernel.PLATFORM.emptyObject) {\n                            def.bindables = Object.assign({}, nameOrDef.bindables);\n                        }\n                        else {\n                            Object.assign(def.bindables, nameOrDef.bindables);\n                        }\n                    }\n                }\n        }\n        // special handling for invocations that quack like a @customElement decorator\n        if (argLen === 2 && ctor !== null) {\n            if (typeof nameOrDef === 'string' || !('build' in nameOrDef)) {\n                def.build = buildRequired;\n            }\n        }\n        return def;\n    }\n\n    function bindable(configOrTarget, prop) {\n        let config;\n        const decorator = function decorate($target, $prop) {\n            const Type = $target.constructor;\n            let bindables = Type.bindables;\n            if (bindables === undefined) {\n                bindables = Type.bindables = {};\n            }\n            if (!config.attribute) {\n                config.attribute = kernel.PLATFORM.kebabCase($prop);\n            }\n            if (!config.callback) {\n                config.callback = `${$prop}Changed`;\n            }\n            if (!config.mode) {\n                config.mode = exports.BindingMode.toView;\n            }\n            if (arguments.length > 1) {\n                // Non invocation:\n                // - @bindable\n                // Invocation with or w/o opts:\n                // - @bindable()\n                // - @bindable({...opts})\n                config.property = $prop;\n            }\n            bindables[config.property] = config;\n        };\n        if (arguments.length > 1) {\n            // Non invocation:\n            // - @bindable\n            config = {};\n            return decorator(configOrTarget, prop);\n        }\n        else if (typeof configOrTarget === 'string') {\n            // ClassDecorator\n            // - @bindable('bar')\n            // Direct call:\n            // - @bindable('bar')(Foo)\n            config = {};\n            return decorator;\n        }\n        // Invocation with or w/o opts:\n        // - @bindable()\n        // - @bindable({...opts})\n        config = (configOrTarget || {});\n        return decorator;\n    }\n\n    function createElement(tagOrType, props, children) {\n        if (typeof tagOrType === 'string') {\n            return createElementForTag(tagOrType, props, children);\n        }\n        else {\n            return createElementForType(tagOrType, props, children);\n        }\n    }\n    class RenderPlan {\n        constructor(node, instructions, dependencies) {\n            this.node = node;\n            this.instructions = instructions;\n            this.dependencies = dependencies;\n        }\n        get definition() {\n            return this.lazyDefinition || (this.lazyDefinition =\n                buildTemplateDefinition(null, null, this.node, null, typeof this.node === 'string', null, this.instructions, this.dependencies));\n        }\n        getElementTemplate(engine, Type) {\n            return engine.getElementTemplate(this.definition, Type);\n        }\n        createView(engine, parentContext) {\n            return this.getViewFactory(engine, parentContext).create();\n        }\n        getViewFactory(engine, parentContext) {\n            return engine.getViewFactory(this.definition, parentContext);\n        }\n        /*@internal*/\n        mergeInto(parent, instructions, dependencies) {\n            DOM.appendChild(parent, this.node);\n            instructions.push(...this.instructions);\n            dependencies.push(...this.dependencies);\n        }\n    }\n    function createElementForTag(tagName, props, children) {\n        const instructions = [];\n        const allInstructions = [];\n        const dependencies = [];\n        const element = DOM.createElement(tagName);\n        let hasInstructions = false;\n        if (props) {\n            Object.keys(props)\n                .forEach(to => {\n                const value = props[to];\n                if (isTargetedInstruction(value)) {\n                    hasInstructions = true;\n                    instructions.push(value);\n                }\n                else {\n                    DOM.setAttribute(element, to, value);\n                }\n            });\n        }\n        if (hasInstructions) {\n            DOM.setAttribute(element, 'class', 'au');\n            allInstructions.push(instructions);\n        }\n        if (children) {\n            addChildren(element, children, allInstructions, dependencies);\n        }\n        return new RenderPlan(element, allInstructions, dependencies);\n    }\n    function createElementForType(Type, props, children) {\n        const tagName = Type.description.name;\n        const instructions = [];\n        const allInstructions = [instructions];\n        const dependencies = [];\n        const childInstructions = [];\n        const bindables = Type.description.bindables;\n        const element = DOM.createElement(tagName);\n        DOM.setAttribute(element, 'class', 'au');\n        if (!dependencies.includes(Type)) {\n            dependencies.push(Type);\n        }\n        instructions.push({\n            type: \"k\" /* hydrateElement */,\n            res: tagName,\n            instructions: childInstructions\n        });\n        if (props) {\n            Object.keys(props)\n                .forEach(to => {\n                const value = props[to];\n                if (isTargetedInstruction(value)) {\n                    childInstructions.push(value);\n                }\n                else {\n                    const bindable = bindables[to];\n                    if (bindable) {\n                        childInstructions.push({\n                            type: \"i\" /* setProperty */,\n                            to,\n                            value\n                        });\n                    }\n                    else {\n                        childInstructions.push({\n                            type: \"j\" /* setAttribute */,\n                            to,\n                            value\n                        });\n                    }\n                }\n            });\n        }\n        if (children) {\n            addChildren(element, children, allInstructions, dependencies);\n        }\n        return new RenderPlan(element, allInstructions, dependencies);\n    }\n    function addChildren(parent, children, allInstructions, dependencies) {\n        for (let i = 0, ii = children.length; i < ii; ++i) {\n            const current = children[i];\n            if (typeof current === 'string') {\n                DOM.appendChild(parent, DOM.createTextNode(current));\n            }\n            else if (DOM.isNodeInstance(current)) {\n                DOM.appendChild(parent, current);\n            }\n            else {\n                current.mergeInto(parent, allInstructions, dependencies);\n            }\n        }\n    }\n\n    /*@internal*/\n    function $attachAttribute(flags) {\n        if (this.$state & 8 /* isAttached */) {\n            return;\n        }\n        const lifecycle = this.$lifecycle;\n        lifecycle.beginAttach();\n        // add isAttaching flag\n        this.$state |= 4 /* isAttaching */;\n        flags |= exports.LifecycleFlags.fromAttach;\n        const hooks = this.$hooks;\n        if (hooks & 16 /* hasAttaching */) {\n            this.attaching(flags);\n        }\n        // add isAttached flag, remove isAttaching flag\n        this.$state |= 8 /* isAttached */;\n        this.$state &= ~4 /* isAttaching */;\n        if (hooks & 32 /* hasAttached */) {\n            lifecycle.enqueueAttached(this);\n        }\n        lifecycle.endAttach(flags);\n    }\n    /*@internal*/\n    function $attachElement(flags) {\n        if (this.$state & 8 /* isAttached */) {\n            return;\n        }\n        const lifecycle = this.$lifecycle;\n        lifecycle.beginAttach();\n        // add isAttaching flag\n        this.$state |= 4 /* isAttaching */;\n        flags |= exports.LifecycleFlags.fromAttach;\n        const hooks = this.$hooks;\n        if (hooks & 16 /* hasAttaching */) {\n            this.attaching(flags);\n        }\n        let current = this.$attachableHead;\n        while (current !== null) {\n            current.$attach(flags);\n            current = current.$nextAttach;\n        }\n        if (!(this.$state & 16 /* isMounted */)) {\n            lifecycle.enqueueMount(this);\n        }\n        // add isAttached flag, remove isAttaching flag\n        this.$state |= 8 /* isAttached */;\n        this.$state &= ~4 /* isAttaching */;\n        if (hooks & 32 /* hasAttached */) {\n            lifecycle.enqueueAttached(this);\n        }\n        lifecycle.endAttach(flags);\n    }\n    /*@internal*/\n    function $attachView(flags) {\n        if (this.$state & 8 /* isAttached */) {\n            return;\n        }\n        // add isAttaching flag\n        this.$state |= 4 /* isAttaching */;\n        flags |= exports.LifecycleFlags.fromAttach;\n        let current = this.$attachableHead;\n        while (current !== null) {\n            current.$attach(flags);\n            current = current.$nextAttach;\n        }\n        if (!(this.$state & 16 /* isMounted */)) {\n            this.$lifecycle.enqueueMount(this);\n        }\n        // add isAttached flag, remove isAttaching flag\n        this.$state |= 8 /* isAttached */;\n        this.$state &= ~4 /* isAttaching */;\n    }\n    /*@internal*/\n    function $detachAttribute(flags) {\n        if (this.$state & 8 /* isAttached */) {\n            const lifecycle = this.$lifecycle;\n            lifecycle.beginDetach();\n            // add isDetaching flag\n            this.$state |= 32 /* isDetaching */;\n            flags |= exports.LifecycleFlags.fromDetach;\n            const hooks = this.$hooks;\n            if (hooks & 64 /* hasDetaching */) {\n                this.detaching(flags);\n            }\n            // remove isAttached and isDetaching flags\n            this.$state &= ~(8 /* isAttached */ | 32 /* isDetaching */);\n            if (hooks & 128 /* hasDetached */) {\n                lifecycle.enqueueDetached(this);\n            }\n            lifecycle.endDetach(flags);\n        }\n    }\n    /*@internal*/\n    function $detachElement(flags) {\n        if (this.$state & 8 /* isAttached */) {\n            const lifecycle = this.$lifecycle;\n            lifecycle.beginDetach();\n            // add isDetaching flag\n            this.$state |= 32 /* isDetaching */;\n            flags |= exports.LifecycleFlags.fromDetach;\n            if (this.$state & 16 /* isMounted */) {\n                // Only unmount if either:\n                // - No parent view/element is queued for unmount yet, or\n                // - Aurelia is stopping (in which case all nodes need to return to their fragments for a clean mount on next start)\n                if (((flags & exports.LifecycleFlags.parentUnmountQueued) ^ exports.LifecycleFlags.parentUnmountQueued) | (flags & exports.LifecycleFlags.fromStopTask)) {\n                    lifecycle.enqueueUnmount(this);\n                    flags |= exports.LifecycleFlags.parentUnmountQueued;\n                }\n            }\n            const hooks = this.$hooks;\n            if (hooks & 64 /* hasDetaching */) {\n                this.detaching(flags);\n            }\n            let current = this.$attachableTail;\n            while (current !== null) {\n                current.$detach(flags);\n                current = current.$prevAttach;\n            }\n            // remove isAttached and isDetaching flags\n            this.$state &= ~(8 /* isAttached */ | 32 /* isDetaching */);\n            if (hooks & 128 /* hasDetached */) {\n                lifecycle.enqueueDetached(this);\n            }\n            lifecycle.endDetach(flags);\n        }\n    }\n    /*@internal*/\n    function $detachView(flags) {\n        if (this.$state & 8 /* isAttached */) {\n            // add isDetaching flag\n            this.$state |= 32 /* isDetaching */;\n            flags |= exports.LifecycleFlags.fromDetach;\n            if (this.$state & 16 /* isMounted */) {\n                // Only unmount if either:\n                // - No parent view/element is queued for unmount yet, or\n                // - Aurelia is stopping (in which case all nodes need to return to their fragments for a clean mount on next start)\n                if (((flags & exports.LifecycleFlags.parentUnmountQueued) ^ exports.LifecycleFlags.parentUnmountQueued) | (flags & exports.LifecycleFlags.fromStopTask)) {\n                    this.$lifecycle.enqueueUnmount(this);\n                    flags |= exports.LifecycleFlags.parentUnmountQueued;\n                }\n            }\n            let current = this.$attachableTail;\n            while (current !== null) {\n                current.$detach(flags);\n                current = current.$prevAttach;\n            }\n            // remove isAttached and isDetaching flags\n            this.$state &= ~(8 /* isAttached */ | 32 /* isDetaching */);\n        }\n    }\n    /*@internal*/\n    function $cacheAttribute(flags) {\n        flags |= exports.LifecycleFlags.fromCache;\n        if (this.$hooks & 2048 /* hasCaching */) {\n            this.caching(flags);\n        }\n    }\n    /*@internal*/\n    function $cacheElement(flags) {\n        flags |= exports.LifecycleFlags.fromCache;\n        if (this.$hooks & 2048 /* hasCaching */) {\n            this.caching(flags);\n        }\n        let current = this.$attachableTail;\n        while (current !== null) {\n            current.$cache(flags);\n            current = current.$prevAttach;\n        }\n    }\n    /*@internal*/\n    function $cacheView(flags) {\n        flags |= exports.LifecycleFlags.fromCache;\n        let current = this.$attachableTail;\n        while (current !== null) {\n            current.$cache(flags);\n            current = current.$prevAttach;\n        }\n    }\n    /*@internal*/\n    function $mountElement(flags) {\n        this.$state |= 16 /* isMounted */;\n        this.$projector.project(this.$nodes);\n    }\n    /*@internal*/\n    function $unmountElement(flags) {\n        this.$state &= ~16 /* isMounted */;\n        this.$projector.take(this.$nodes);\n    }\n    /*@internal*/\n    function $mountView(flags) {\n        this.$state |= 16 /* isMounted */;\n        this.$state &= ~256 /* needsMount */;\n        this.$nodes.insertBefore(this.location);\n    }\n    /*@internal*/\n    function $unmountView(flags) {\n        this.$state &= ~16 /* isMounted */;\n        this.$state |= 256 /* needsMount */;\n        this.$nodes.remove();\n        if (this.isFree) {\n            this.isFree = false;\n            if (this.cache.tryReturnToCache(this)) {\n                this.$state |= 128 /* isCached */;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*@internal*/\n    function $bindAttribute(flags, scope) {\n        flags |= exports.LifecycleFlags.fromBind;\n        if (this.$state & 2 /* isBound */) {\n            if (this.$scope === scope) {\n                return;\n            }\n            this.$unbind(flags);\n        }\n        const lifecycle = this.$lifecycle;\n        lifecycle.beginBind();\n        // add isBinding flag\n        this.$state |= 1 /* isBinding */;\n        const hooks = this.$hooks;\n        if (hooks & 8 /* hasBound */) {\n            lifecycle.enqueueBound(this);\n        }\n        this.$scope = scope;\n        if (hooks & 4 /* hasBinding */) {\n            this.binding(flags);\n        }\n        // add isBound flag and remove isBinding flag\n        this.$state |= 2 /* isBound */;\n        this.$state &= ~1 /* isBinding */;\n        lifecycle.endBind(flags);\n    }\n    /*@internal*/\n    function $bindElement(flags) {\n        if (this.$state & 2 /* isBound */) {\n            return;\n        }\n        const lifecycle = this.$lifecycle;\n        lifecycle.beginBind();\n        // add isBinding flag\n        this.$state |= 1 /* isBinding */;\n        const hooks = this.$hooks;\n        flags |= exports.LifecycleFlags.fromBind;\n        if (hooks & 8 /* hasBound */) {\n            lifecycle.enqueueBound(this);\n        }\n        if (hooks & 4 /* hasBinding */) {\n            this.binding(flags);\n        }\n        const scope = this.$scope;\n        let current = this.$bindableHead;\n        while (current !== null) {\n            current.$bind(flags, scope);\n            current = current.$nextBind;\n        }\n        // add isBound flag and remove isBinding flag\n        this.$state |= 2 /* isBound */;\n        this.$state &= ~1 /* isBinding */;\n        lifecycle.endBind(flags);\n    }\n    /*@internal*/\n    function $bindView(flags, scope) {\n        flags |= exports.LifecycleFlags.fromBind;\n        if (this.$state & 2 /* isBound */) {\n            if (this.$scope === scope) {\n                return;\n            }\n            this.$unbind(flags);\n        }\n        // add isBinding flag\n        this.$state |= 1 /* isBinding */;\n        this.$scope = scope;\n        let current = this.$bindableHead;\n        while (current !== null) {\n            current.$bind(flags, scope);\n            current = current.$nextBind;\n        }\n        // add isBound flag and remove isBinding flag\n        this.$state |= 2 /* isBound */;\n        this.$state &= ~1 /* isBinding */;\n    }\n    /*@internal*/\n    function $unbindAttribute(flags) {\n        if (this.$state & 2 /* isBound */) {\n            const lifecycle = this.$lifecycle;\n            lifecycle.beginUnbind();\n            // add isUnbinding flag\n            this.$state |= 64 /* isUnbinding */;\n            const hooks = this.$hooks;\n            flags |= exports.LifecycleFlags.fromUnbind;\n            if (hooks & 512 /* hasUnbound */) {\n                lifecycle.enqueueUnbound(this);\n            }\n            if (hooks & 256 /* hasUnbinding */) {\n                this.unbinding(flags);\n            }\n            // remove isBound and isUnbinding flags\n            this.$state &= ~(2 /* isBound */ | 64 /* isUnbinding */);\n            lifecycle.endUnbind(flags);\n        }\n    }\n    /*@internal*/\n    function $unbindElement(flags) {\n        if (this.$state & 2 /* isBound */) {\n            const lifecycle = this.$lifecycle;\n            lifecycle.beginUnbind();\n            // add isUnbinding flag\n            this.$state |= 64 /* isUnbinding */;\n            const hooks = this.$hooks;\n            flags |= exports.LifecycleFlags.fromUnbind;\n            if (hooks & 512 /* hasUnbound */) {\n                lifecycle.enqueueUnbound(this);\n            }\n            if (hooks & 256 /* hasUnbinding */) {\n                this.unbinding(flags);\n            }\n            let current = this.$bindableTail;\n            while (current !== null) {\n                current.$unbind(flags);\n                current = current.$prevBind;\n            }\n            // remove isBound and isUnbinding flags\n            this.$state &= ~(2 /* isBound */ | 64 /* isUnbinding */);\n            lifecycle.endUnbind(flags);\n        }\n    }\n    /*@internal*/\n    function $unbindView(flags) {\n        if (this.$state & 2 /* isBound */) {\n            // add isUnbinding flag\n            this.$state |= 64 /* isUnbinding */;\n            flags |= exports.LifecycleFlags.fromUnbind;\n            let current = this.$bindableTail;\n            while (current !== null) {\n                current.$unbind(flags);\n                current = current.$prevBind;\n            }\n            // remove isBound and isUnbinding flags\n            this.$state &= ~(2 /* isBound */ | 64 /* isUnbinding */);\n            this.$scope = null;\n        }\n    }\n\n    /*@internal*/\n    class View {\n        constructor($lifecycle, cache) {\n            this.$lifecycle = $lifecycle;\n            this.cache = cache;\n            this.$bindableHead = null;\n            this.$bindableTail = null;\n            this.$nextBind = null;\n            this.$prevBind = null;\n            this.$attachableHead = null;\n            this.$attachableTail = null;\n            this.$nextAttach = null;\n            this.$prevAttach = null;\n            this.$nextMount = null;\n            this.$mountFlags = 0;\n            this.$nextUnmount = null;\n            this.$unmountFlags = 0;\n            this.$nextUnbindAfterDetach = null;\n            this.$state = 0 /* none */;\n            this.$scope = null;\n            this.isFree = false;\n        }\n        hold(location, flags) {\n            if (!location.parentNode) { // unmet invariant: location must be a child of some other node\n                throw kernel.Reporter.error(60); // TODO: organize error codes\n            }\n            this.location = location;\n            const lastChild = this.$nodes.lastChild;\n            if (lastChild && lastChild.nextSibling === location) {\n                this.$state &= ~256 /* needsMount */;\n            }\n            else {\n                this.$state |= 256 /* needsMount */;\n            }\n        }\n        lockScope(scope) {\n            this.$scope = scope;\n            this.$bind = lockedBind;\n        }\n        release(flags) {\n            this.isFree = true;\n            if (this.$state & 8 /* isAttached */) {\n                return this.cache.canReturnToCache(this);\n            }\n            return this.$unmount(flags);\n        }\n    }\n    /*@internal*/\n    class ViewFactory {\n        constructor(name, template, lifecycle) {\n            this.name = name;\n            this.template = template;\n            this.lifecycle = lifecycle;\n            this.isCaching = false;\n            this.cacheSize = -1;\n            this.cache = null;\n        }\n        setCacheSize(size, doNotOverrideIfAlreadySet) {\n            if (size) {\n                if (size === '*') {\n                    size = ViewFactory.maxCacheSize;\n                }\n                else if (typeof size === 'string') {\n                    size = parseInt(size, 10);\n                }\n                if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {\n                    this.cacheSize = size;\n                }\n            }\n            if (this.cacheSize > 0) {\n                this.cache = [];\n            }\n            else {\n                this.cache = null;\n            }\n            this.isCaching = this.cacheSize > 0;\n        }\n        canReturnToCache(view) {\n            return this.cache !== null && this.cache.length < this.cacheSize;\n        }\n        tryReturnToCache(view) {\n            if (this.canReturnToCache(view)) {\n                view.$cache(exports.LifecycleFlags.none);\n                this.cache.push(view);\n                return true;\n            }\n            return false;\n        }\n        create() {\n            const cache = this.cache;\n            let view;\n            if (cache !== null && cache.length > 0) {\n                view = cache.pop();\n                view.$state &= ~128 /* isCached */;\n                return view;\n            }\n            view = new View(this.lifecycle, this);\n            this.template.render(view);\n            if (!view.$nodes) {\n                throw kernel.Reporter.error(90);\n            }\n            return view;\n        }\n    }\n    ViewFactory.maxCacheSize = 0xFFFF;\n    function lockedBind(flags) {\n        if (this.$state & 2 /* isBound */) {\n            return;\n        }\n        flags |= exports.LifecycleFlags.fromBind;\n        const lockedScope = this.$scope;\n        let current = this.$bindableHead;\n        while (current !== null) {\n            current.$bind(flags, lockedScope);\n            current = current.$nextBind;\n        }\n        this.$state |= 2 /* isBound */;\n    }\n    ((proto) => {\n        proto.$bind = $bindView;\n        proto.$unbind = $unbindView;\n        proto.$attach = $attachView;\n        proto.$detach = $detachView;\n        proto.$cache = $cacheView;\n        proto.$mount = $mountView;\n        proto.$unmount = $unmountView;\n    })(View.prototype);\n\n    function renderStrategy(nameOrSource) {\n        return target => RenderStrategyResource.define(nameOrSource, target);\n    }\n    const RenderStrategyResource = {\n        name: 'render-strategy',\n        keyFrom(name) {\n            return `${this.name}:${name}`;\n        },\n        isType(Type) {\n            return Type.kind === this;\n        },\n        define(nameOrSource, ctor) {\n            const description = typeof nameOrSource === 'string' ? { name: nameOrSource } : nameOrSource;\n            const Type = ctor;\n            Type.kind = RenderStrategyResource;\n            Type.description = description;\n            Type.register = registerRenderStrategy;\n            return Type;\n        }\n    };\n    /*@internal*/\n    function registerRenderStrategy(container) {\n        const resourceKey = RenderStrategyResource.keyFrom(this.description.name);\n        container.register(kernel.Registration.singleton(resourceKey, this));\n    }\n    const ITemplateCompiler = kernel.DI.createInterface().noDefault();\n    (function (ViewCompileFlags) {\n        ViewCompileFlags[ViewCompileFlags[\"none\"] = 1] = \"none\";\n        ViewCompileFlags[ViewCompileFlags[\"surrogate\"] = 2] = \"surrogate\";\n        ViewCompileFlags[ViewCompileFlags[\"shadowDOM\"] = 4] = \"shadowDOM\";\n    })(exports.ViewCompileFlags || (exports.ViewCompileFlags = {}));\n    /*@internal*/\n    function $hydrateAttribute(renderingEngine) {\n        const Type = this.constructor;\n        renderingEngine.applyRuntimeBehavior(Type, this);\n        if (this.$hooks & 2 /* hasCreated */) {\n            this.created();\n        }\n    }\n    /*@internal*/\n    function $hydrateElement(renderingEngine, host, options = kernel.PLATFORM.emptyObject) {\n        const Type = this.constructor;\n        const description = Type.description;\n        this.$scope = Scope.create(this, null);\n        renderingEngine.applyRuntimeBehavior(Type, this);\n        if (this.$hooks & 1024 /* hasRender */) {\n            const result = this.render(host, options.parts);\n            if (result && 'getElementTemplate' in result) {\n                const template = result.getElementTemplate(renderingEngine, Type);\n                template.render(this, host, options.parts);\n            }\n        }\n        else {\n            const template = renderingEngine.getElementTemplate(description, Type);\n            template.render(this, host, options.parts);\n        }\n        this.$host = host;\n        this.$projector = determineProjector(this, host, description);\n        if (this.$hooks & 2 /* hasCreated */) {\n            this.created();\n        }\n    }\n    /*@internal*/\n    const defaultShadowOptions = {\n        mode: 'open'\n    };\n    function determineProjector($customElement, host, definition) {\n        if (definition.shadowOptions || definition.hasSlots) {\n            if (definition.containerless) {\n                throw kernel.Reporter.error(21);\n            }\n            return new ShadowDOMProjector($customElement, host, definition);\n        }\n        if (definition.containerless) {\n            return new ContainerlessProjector($customElement, host);\n        }\n        return new HostProjector($customElement, host);\n    }\n    const IRenderingEngine = kernel.DI.createInterface()\n        .withDefault(x => x.singleton(exports.RenderingEngine));\n    const defaultCompilerName = 'default';\n    exports.RenderingEngine = \n    /*@internal*/\n    class RenderingEngine {\n        constructor(container, lifecycle, observerLocator, eventManager, parser, templateCompilers) {\n            this.container = container;\n            this.lifecycle = lifecycle;\n            this.observerLocator = observerLocator;\n            this.eventManager = eventManager;\n            this.parser = parser;\n            this.templateLookup = new Map();\n            this.factoryLookup = new Map();\n            this.behaviorLookup = new Map();\n            this.compilers = templateCompilers.reduce((acc, item) => {\n                acc[item.name] = item;\n                return acc;\n            }, Object.create(null));\n        }\n        getElementTemplate(definition, componentType) {\n            if (!definition) {\n                return null;\n            }\n            let found = this.templateLookup.get(definition);\n            if (!found) {\n                found = this.templateFromSource(definition);\n                //If the element has a view, support Recursive Components by adding self to own view template container.\n                if (found.renderContext !== null && componentType) {\n                    componentType.register(found.renderContext);\n                }\n                this.templateLookup.set(definition, found);\n            }\n            return found;\n        }\n        getViewFactory(definition, parentContext) {\n            if (!definition) {\n                return null;\n            }\n            let factory = this.factoryLookup.get(definition);\n            if (!factory) {\n                const validSource = buildTemplateDefinition(null, definition);\n                const template = this.templateFromSource(validSource, parentContext);\n                factory = new ViewFactory(validSource.name, template, this.lifecycle);\n                factory.setCacheSize(validSource.cache, true);\n                this.factoryLookup.set(definition, factory);\n            }\n            return factory;\n        }\n        applyRuntimeBehavior(Type, instance) {\n            let found = this.behaviorLookup.get(Type);\n            if (!found) {\n                found = RuntimeBehavior.create(Type, instance);\n                this.behaviorLookup.set(Type, found);\n            }\n            found.applyTo(instance, this.lifecycle);\n        }\n        createRenderer(context) {\n            return new Renderer(context, this.observerLocator, this.eventManager, this.parser, this);\n        }\n        templateFromSource(definition, parentContext) {\n            parentContext = parentContext || this.container;\n            if (definition && definition.template) {\n                if (definition.build.required) {\n                    const compilerName = definition.build.compiler || defaultCompilerName;\n                    const compiler = this.compilers[compilerName];\n                    if (!compiler) {\n                        throw kernel.Reporter.error(20, compilerName);\n                    }\n                    definition = compiler.compile(definition, new RuntimeCompilationResources(parentContext), exports.ViewCompileFlags.surrogate);\n                }\n                return new CompiledTemplate(this, parentContext, definition);\n            }\n            return noViewTemplate;\n        }\n    };\n    exports.RenderingEngine = __decorate([\n        kernel.inject(kernel.IContainer, ILifecycle, IObserverLocator, IEventManager, IExpressionParser, kernel.all(ITemplateCompiler))\n        /*@internal*/\n    ], exports.RenderingEngine);\n    const childObserverOptions$1 = { childList: true };\n    /*@internal*/\n    class ShadowDOMProjector {\n        constructor($customElement, host, definition) {\n            this.host = host;\n            this.shadowRoot = DOM.attachShadow(host, definition.shadowOptions || defaultShadowOptions);\n            host.$customElement = $customElement;\n            this.shadowRoot.$customElement = $customElement;\n        }\n        get children() {\n            return this.host.childNodes;\n        }\n        subscribeToChildrenChange(callback) {\n            DOM.createNodeObserver(this.host, callback, childObserverOptions$1);\n        }\n        provideEncapsulationSource(parentEncapsulationSource) {\n            return this.shadowRoot;\n        }\n        project(nodes) {\n            nodes.appendTo(this.host);\n            this.project = kernel.PLATFORM.noop;\n        }\n        take(nodes) {\n            // No special behavior is required because the host element removal\n            // will result in the projected nodes being removed, since they are in\n            // the ShadowDOM.\n        }\n    }\n    /*@internal*/\n    class ContainerlessProjector {\n        constructor($customElement, host) {\n            this.$customElement = $customElement;\n            if (host.childNodes.length) {\n                this.childNodes = kernel.PLATFORM.toArray(host.childNodes);\n            }\n            else {\n                this.childNodes = kernel.PLATFORM.emptyArray;\n            }\n            this.host = DOM.convertToRenderLocation(host);\n            this.host.$customElement = $customElement;\n        }\n        get children() {\n            return this.childNodes;\n        }\n        subscribeToChildrenChange(callback) {\n            // Do nothing since this scenario will never have children.\n        }\n        provideEncapsulationSource(parentEncapsulationSource) {\n            if (!parentEncapsulationSource) {\n                throw kernel.Reporter.error(22);\n            }\n            return parentEncapsulationSource;\n        }\n        project(nodes) {\n            if (this.$customElement.$state & 256 /* needsMount */) {\n                this.$customElement.$state &= ~256 /* needsMount */;\n                nodes.insertBefore(this.host);\n            }\n        }\n        take(nodes) {\n            this.$customElement.$state |= 256 /* needsMount */;\n            nodes.remove();\n        }\n    }\n    /*@internal*/\n    class HostProjector {\n        constructor($customElement, host) {\n            this.host = host;\n            host.$customElement = $customElement;\n            this.isAppHost = host.hasOwnProperty('$au');\n        }\n        get children() {\n            return kernel.PLATFORM.emptyArray;\n        }\n        subscribeToChildrenChange(callback) {\n            // Do nothing since this scenario will never have children.\n        }\n        provideEncapsulationSource(parentEncapsulationSource) {\n            return parentEncapsulationSource || this.host;\n        }\n        project(nodes) {\n            nodes.appendTo(this.host);\n            if (!this.isAppHost) {\n                this.project = kernel.PLATFORM.noop;\n            }\n        }\n        take(nodes) {\n            // No special behavior is required because the host element removal\n            // will result in the projected nodes being removed, since they are children.\n            if (this.isAppHost) {\n                // The only exception to that is the app host, which is not part of a removable node sequence\n                nodes.remove();\n            }\n        }\n    }\n    /** @internal */\n    class RuntimeBehavior {\n        constructor() { }\n        static create(Component, instance) {\n            const behavior = new RuntimeBehavior();\n            behavior.bindables = Component.description.bindables;\n            return behavior;\n        }\n        applyTo(instance, lifecycle) {\n            instance.$lifecycle = lifecycle;\n            if ('$projector' in instance) {\n                this.applyToElement(lifecycle, instance);\n            }\n            else {\n                this.applyToCore(instance);\n            }\n        }\n        applyToElement(lifecycle, instance) {\n            const observers = this.applyToCore(instance);\n            observers.$children = new exports.ChildrenObserver(lifecycle, instance);\n            Reflect.defineProperty(instance, '$children', {\n                enumerable: false,\n                get: function () {\n                    return this.$observers.$children.getValue();\n                }\n            });\n        }\n        applyToCore(instance) {\n            const observers = {};\n            const bindables = this.bindables;\n            const observableNames = Object.getOwnPropertyNames(bindables);\n            for (let i = 0, ii = observableNames.length; i < ii; ++i) {\n                const name = observableNames[i];\n                observers[name] = new exports.Observer(instance, name, bindables[name].callback);\n                createGetterSetter(instance, name);\n            }\n            Reflect.defineProperty(instance, '$observers', {\n                enumerable: false,\n                value: observers\n            });\n            return observers;\n        }\n    }\n    function createGetterSetter(instance, name) {\n        Reflect.defineProperty(instance, name, {\n            enumerable: true,\n            get: function () { return this.$observers[name].getValue(); },\n            set: function (value) { this.$observers[name].setValue(value, exports.LifecycleFlags.updateTargetInstance); }\n        });\n    }\n    /*@internal*/\n    exports.ChildrenObserver = class ChildrenObserver {\n        constructor(lifecycle, customElement) {\n            this.lifecycle = lifecycle;\n            this.customElement = customElement;\n            this.hasChanges = false;\n            this.children = null;\n            this.observing = false;\n        }\n        getValue() {\n            if (!this.observing) {\n                this.observing = true;\n                this.customElement.$projector.subscribeToChildrenChange(() => this.onChildrenChanged());\n                this.children = findElements(this.customElement.$projector.children);\n            }\n            return this.children;\n        }\n        setValue(newValue) { }\n        flush(flags) {\n            this.callSubscribers(this.children, undefined, flags | exports.LifecycleFlags.updateTargetInstance);\n            this.hasChanges = false;\n        }\n        subscribe(subscriber) {\n            this.addSubscriber(subscriber);\n        }\n        unsubscribe(subscriber) {\n            this.removeSubscriber(subscriber);\n        }\n        onChildrenChanged() {\n            this.children = findElements(this.customElement.$projector.children);\n            if ('$childrenChanged' in this.customElement) {\n                this.customElement.$childrenChanged();\n            }\n            this.lifecycle.enqueueFlush(this);\n            this.hasChanges = true;\n        }\n    };\n    exports.ChildrenObserver = __decorate([\n        subscriberCollection(exports.MutationKind.instance)\n    ], exports.ChildrenObserver);\n    /*@internal*/\n    function findElements(nodes) {\n        const components = [];\n        for (let i = 0, ii = nodes.length; i < ii; ++i) {\n            const current = nodes[i];\n            const component = customElementBehavior(current);\n            if (component !== null) {\n                components.push(component);\n            }\n        }\n        return components;\n    }\n    /*@internal*/\n    class RuntimeCompilationResources {\n        constructor(context) {\n            this.context = context;\n        }\n        find(kind, name) {\n            const key = kind.keyFrom(name);\n            const resolver = this.context.getResolver(key, false);\n            if (resolver !== null && resolver.getFactory) {\n                const factory = resolver.getFactory(this.context);\n                if (factory !== null) {\n                    return factory.type.description || null;\n                }\n            }\n            return null;\n        }\n        create(kind, name) {\n            const key = kind.keyFrom(name);\n            if (this.context.has(key, false)) {\n                return this.context.get(key) || null;\n            }\n            return null;\n        }\n    }\n    // This is the main implementation of ITemplate.\n    // It is used to create instances of IView based on a compiled TemplateDefinition.\n    // TemplateDefinitions are hand-coded today, but will ultimately be the output of the\n    // TemplateCompiler either through a JIT or AOT process.\n    // Essentially, CompiledTemplate wraps up the small bit of code that is needed to take a TemplateDefinition\n    // and create instances of it on demand.\n    /*@internal*/\n    class CompiledTemplate {\n        constructor(renderingEngine, parentRenderContext, templateDefinition) {\n            this.templateDefinition = templateDefinition;\n            this.factory = NodeSequenceFactory.createFor(templateDefinition.template);\n            this.renderContext = createRenderContext(renderingEngine, parentRenderContext, templateDefinition.dependencies);\n        }\n        render(renderable, host, parts) {\n            const nodes = renderable.$nodes = this.factory.createNodeSequence();\n            renderable.$context = this.renderContext;\n            this.renderContext.render(renderable, nodes.findTargets(), this.templateDefinition, host, parts);\n        }\n    }\n    // This is an implementation of ITemplate that always returns a node sequence representing \"no DOM\" to render.\n    /*@internal*/\n    const noViewTemplate = {\n        renderContext: null,\n        render(renderable) {\n            renderable.$nodes = NodeSequence.empty;\n            renderable.$context = null;\n        }\n    };\n    function createRenderContext(renderingEngine, parentRenderContext, dependencies) {\n        const context = parentRenderContext.createChild();\n        const renderableProvider = new InstanceProvider();\n        const elementProvider = new InstanceProvider();\n        const instructionProvider = new InstanceProvider();\n        const factoryProvider = new ViewFactoryProvider(renderingEngine);\n        const renderLocationProvider = new InstanceProvider();\n        const renderer = renderingEngine.createRenderer(context);\n        DOM.registerElementResolver(context, elementProvider);\n        context.registerResolver(IViewFactory, factoryProvider);\n        context.registerResolver(IRenderable, renderableProvider);\n        context.registerResolver(ITargetedInstruction, instructionProvider);\n        context.registerResolver(IRenderLocation, renderLocationProvider);\n        if (dependencies) {\n            context.register(...dependencies);\n        }\n        context.render = function (renderable, targets, templateDefinition, host, parts) {\n            renderer.render(renderable, targets, templateDefinition, host, parts);\n        };\n        context.beginComponentOperation = function (renderable, target, instruction, factory, parts, location) {\n            renderableProvider.prepare(renderable);\n            elementProvider.prepare(target);\n            instructionProvider.prepare(instruction);\n            if (factory) {\n                factoryProvider.prepare(factory, parts);\n            }\n            if (location) {\n                renderLocationProvider.prepare(location);\n            }\n            return context;\n        };\n        context.dispose = function () {\n            factoryProvider.dispose();\n            renderableProvider.dispose();\n            instructionProvider.dispose();\n            elementProvider.dispose();\n            renderLocationProvider.dispose();\n        };\n        return context;\n    }\n    /*@internal*/\n    class InstanceProvider {\n        constructor() {\n            this.instance = null;\n        }\n        prepare(instance) {\n            this.instance = instance;\n        }\n        resolve(handler, requestor) {\n            if (this.instance === undefined) { // unmet precondition: call prepare\n                throw kernel.Reporter.error(50); // TODO: organize error codes\n            }\n            return this.instance;\n        }\n        dispose() {\n            this.instance = null;\n        }\n    }\n    /*@internal*/\n    class ViewFactoryProvider {\n        constructor(renderingEngine) {\n            this.renderingEngine = renderingEngine;\n        }\n        prepare(factory, parts) {\n            this.factory = factory;\n            this.replacements = parts || kernel.PLATFORM.emptyObject;\n        }\n        resolve(handler, requestor) {\n            const factory = this.factory;\n            if (factory === undefined) { // unmet precondition: call prepare\n                throw kernel.Reporter.error(50); // TODO: organize error codes\n            }\n            if (!factory.name || !factory.name.length) { // unmet invariant: factory must have a name\n                throw kernel.Reporter.error(51); // TODO: organize error codes\n            }\n            const found = this.replacements[factory.name];\n            if (found) {\n                return this.renderingEngine.getViewFactory(found, requestor);\n            }\n            return this.factory;\n        }\n        dispose() {\n            this.factory = null;\n            this.replacements = null;\n        }\n    }\n    function addBindable(renderable, bindable) {\n        bindable.$prevBind = renderable.$bindableTail;\n        bindable.$nextBind = null;\n        if (renderable.$bindableTail === null) {\n            renderable.$bindableHead = bindable;\n        }\n        else {\n            renderable.$bindableTail.$nextBind = bindable;\n        }\n        renderable.$bindableTail = bindable;\n    }\n    function addAttachable(renderable, attachable) {\n        attachable.$prevAttach = renderable.$attachableTail;\n        attachable.$nextAttach = null;\n        if (renderable.$attachableTail === null) {\n            renderable.$attachableHead = attachable;\n        }\n        else {\n            renderable.$attachableTail.$nextAttach = attachable;\n        }\n        renderable.$attachableTail = attachable;\n    }\n    // tslint:disable:function-name\n    // tslint:disable:no-any\n    /* @internal */\n    class Renderer {\n        constructor(context, observerLocator, eventManager, parser, renderingEngine) {\n            this.context = context;\n            this.observerLocator = observerLocator;\n            this.eventManager = eventManager;\n            this.parser = parser;\n            this.renderingEngine = renderingEngine;\n        }\n        render(renderable, targets, definition, host, parts) {\n            const targetInstructions = definition.instructions;\n            if (targets.length !== targetInstructions.length) {\n                if (targets.length > targetInstructions.length) {\n                    throw kernel.Reporter.error(30);\n                }\n                else {\n                    throw kernel.Reporter.error(31);\n                }\n            }\n            for (let i = 0, ii = targets.length; i < ii; ++i) {\n                const instructions = targetInstructions[i];\n                const target = targets[i];\n                for (let j = 0, jj = instructions.length; j < jj; ++j) {\n                    const current = instructions[j];\n                    this[current.type](renderable, target, current, parts);\n                }\n            }\n            if (host) {\n                const surrogateInstructions = definition.surrogates;\n                for (let i = 0, ii = surrogateInstructions.length; i < ii; ++i) {\n                    const current = surrogateInstructions[i];\n                    this[current.type](renderable, host, current, parts);\n                }\n            }\n        }\n        hydrateElementInstance(renderable, target, instruction, component) {\n            const childInstructions = instruction.instructions;\n            component.$hydrate(this.renderingEngine, target, instruction);\n            for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n                const current = childInstructions[i];\n                const currentType = current.type;\n                this[currentType](renderable, component, current);\n            }\n            addBindable(renderable, component);\n            addAttachable(renderable, component);\n        }\n        [\"a\" /* textBinding */](renderable, target, instruction) {\n            const next = target.nextSibling;\n            DOM.treatAsNonWhitespace(next);\n            DOM.remove(target);\n            const $from = instruction.from;\n            const expr = ($from.$kind ? $from : this.parser.parse($from, 2048 /* Interpolation */));\n            if (expr.isMulti) {\n                addBindable(renderable, new MultiInterpolationBinding(this.observerLocator, expr, next, 'textContent', exports.BindingMode.toView, this.context));\n            }\n            else {\n                addBindable(renderable, new exports.InterpolationBinding(expr.firstExpression, expr, next, 'textContent', exports.BindingMode.toView, this.observerLocator, this.context, true));\n            }\n        }\n        [\"b\" /* interpolation */](renderable, target, instruction) {\n            const $from = instruction.from;\n            const expr = ($from.$kind ? $from : this.parser.parse($from, 2048 /* Interpolation */));\n            if (expr.isMulti) {\n                addBindable(renderable, new MultiInterpolationBinding(this.observerLocator, expr, target, instruction.to, exports.BindingMode.toView, this.context));\n            }\n            else {\n                addBindable(renderable, new exports.InterpolationBinding(expr.firstExpression, expr, target, instruction.to, exports.BindingMode.toView, this.observerLocator, this.context, true));\n            }\n        }\n        [\"c\" /* propertyBinding */](renderable, target, instruction) {\n            const $from = instruction.from;\n            addBindable(renderable, new exports.Binding($from.$kind ? $from : this.parser.parse($from, 48 /* IsPropertyCommand */ | instruction.mode), target, instruction.to, instruction.mode, this.observerLocator, this.context));\n        }\n        [\"d\" /* iteratorBinding */](renderable, target, instruction) {\n            const $from = instruction.from;\n            addBindable(renderable, new exports.Binding($from.$kind ? $from : this.parser.parse($from, 539 /* ForCommand */), target, instruction.to, exports.BindingMode.toView, this.observerLocator, this.context));\n        }\n        [\"e\" /* listenerBinding */](renderable, target, instruction) {\n            const $from = instruction.from;\n            addBindable(renderable, new Listener(instruction.to, instruction.strategy, $from.$kind ? $from : this.parser.parse($from, 80 /* IsEventCommand */ | (instruction.strategy + 6 /* DelegationStrategyDelta */)), target, instruction.preventDefault, this.eventManager, this.context));\n        }\n        [\"f\" /* callBinding */](renderable, target, instruction) {\n            const $from = instruction.from;\n            addBindable(renderable, new Call($from.$kind ? $from : this.parser.parse($from, 153 /* CallCommand */), target, instruction.to, this.observerLocator, this.context));\n        }\n        [\"g\" /* refBinding */](renderable, target, instruction) {\n            const $from = instruction.from;\n            addBindable(renderable, new Ref($from.$kind ? $from : this.parser.parse($from, 1280 /* IsRef */), target, this.context));\n        }\n        [\"h\" /* stylePropertyBinding */](renderable, target, instruction) {\n            const $from = instruction.from;\n            addBindable(renderable, new exports.Binding($from.$kind ? $from : this.parser.parse($from, 48 /* IsPropertyCommand */ | exports.BindingMode.toView), target.style, instruction.to, exports.BindingMode.toView, this.observerLocator, this.context));\n        }\n        [\"i\" /* setProperty */](renderable, target, instruction) {\n            target[instruction.to] = instruction.value;\n        }\n        [\"j\" /* setAttribute */](renderable, target, instruction) {\n            DOM.setAttribute(target, instruction.to, instruction.value);\n        }\n        [\"k\" /* hydrateElement */](renderable, target, instruction) {\n            const context = this.context;\n            const operation = context.beginComponentOperation(renderable, target, instruction, null, null, target, true);\n            const component = context.get(customElementKey(instruction.res));\n            this.hydrateElementInstance(renderable, target, instruction, component);\n            operation.dispose();\n        }\n        [\"l\" /* hydrateAttribute */](renderable, target, instruction) {\n            const childInstructions = instruction.instructions;\n            const context = this.context;\n            const operation = context.beginComponentOperation(renderable, target, instruction);\n            const component = context.get(customAttributeKey(instruction.res));\n            component.$hydrate(this.renderingEngine);\n            for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n                const current = childInstructions[i];\n                this[current.type](renderable, component, current);\n            }\n            addBindable(renderable, component);\n            addAttachable(renderable, component);\n            operation.dispose();\n        }\n        [\"m\" /* hydrateTemplateController */](renderable, target, instruction, parts) {\n            const childInstructions = instruction.instructions;\n            const factory = this.renderingEngine.getViewFactory(instruction.def, this.context);\n            const context = this.context;\n            const operation = context.beginComponentOperation(renderable, target, instruction, factory, parts, DOM.convertToRenderLocation(target), false);\n            const component = context.get(customAttributeKey(instruction.res));\n            component.$hydrate(this.renderingEngine);\n            if (instruction.link) {\n                component.link(renderable.$attachableTail);\n            }\n            for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n                const current = childInstructions[i];\n                this[current.type](renderable, component, current);\n            }\n            addBindable(renderable, component);\n            addAttachable(renderable, component);\n            operation.dispose();\n        }\n        [\"z\" /* renderStrategy */](renderable, target, instruction) {\n            const strategyName = instruction.name;\n            if (this[strategyName] === undefined) {\n                const strategy = this.context.get(RenderStrategyResource.keyFrom(strategyName));\n                if (strategy === null || strategy === undefined) {\n                    throw new Error(`Unknown renderStrategy \"${strategyName}\"`);\n                }\n                this[strategyName] = strategy.render.bind(strategy);\n            }\n            this[strategyName](renderable, target, instruction);\n        }\n        [\"n\" /* letElement */](renderable, target, instruction) {\n            target.remove();\n            const childInstructions = instruction.instructions;\n            const toViewModel = instruction.toViewModel;\n            for (let i = 0, ii = childInstructions.length; i < ii; ++i) {\n                const childInstruction = childInstructions[i];\n                const $from = childInstruction.from;\n                addBindable(renderable, new exports.LetBinding($from.$kind ? $from : this.parser.parse($from, 48 /* IsPropertyCommand */), childInstruction.to, this.observerLocator, this.context, toViewModel));\n            }\n        }\n    }\n\n    /**\n     * Decorator: Indicates that the decorated class is a custom element.\n     */\n    function customElement(nameOrSource) {\n        return target => CustomElementResource.define(nameOrSource, target);\n    }\n    function useShadowDOM(targetOrOptions) {\n        const options = typeof targetOrOptions === 'function' || !targetOrOptions\n            ? defaultShadowOptions\n            : targetOrOptions;\n        function useShadowDOMDecorator(target) {\n            target.shadowOptions = options;\n            return target;\n        }\n        return typeof targetOrOptions === 'function' ? useShadowDOMDecorator(targetOrOptions) : useShadowDOMDecorator;\n    }\n    function containerlessDecorator(target) {\n        target.containerless = true;\n        return target;\n    }\n    function containerless(target) {\n        return target === undefined ? containerlessDecorator : containerlessDecorator(target);\n    }\n    const CustomElementResource = {\n        name: customElementName,\n        keyFrom: customElementKey,\n        isType(Type) {\n            return Type.kind === this;\n        },\n        behaviorFor: customElementBehavior,\n        define(nameOrSource, ctor = null) {\n            if (!nameOrSource) {\n                throw kernel.Reporter.error(70);\n            }\n            const Type = (ctor === null ? class HTMLOnlyElement {\n            } : ctor);\n            const description = buildTemplateDefinition(Type, nameOrSource);\n            const proto = Type.prototype;\n            Type.kind = CustomElementResource;\n            Type.description = description;\n            Type.register = registerElement;\n            proto.$hydrate = $hydrateElement;\n            proto.$bind = $bindElement;\n            proto.$attach = $attachElement;\n            proto.$detach = $detachElement;\n            proto.$unbind = $unbindElement;\n            proto.$cache = $cacheElement;\n            proto.$prevBind = null;\n            proto.$nextBind = null;\n            proto.$prevAttach = null;\n            proto.$nextAttach = null;\n            proto.$nextUnbindAfterDetach = null;\n            proto.$scope = null;\n            proto.$hooks = 0;\n            proto.$state = 256 /* needsMount */;\n            proto.$bindableHead = null;\n            proto.$bindableTail = null;\n            proto.$attachableHead = null;\n            proto.$attachableTail = null;\n            proto.$mount = $mountElement;\n            proto.$unmount = $unmountElement;\n            proto.$nextMount = null;\n            proto.$nextUnmount = null;\n            proto.$projector = null;\n            if ('flush' in proto) {\n                proto.$nextFlush = null;\n            }\n            if ('binding' in proto)\n                proto.$hooks |= 4 /* hasBinding */;\n            if ('bound' in proto) {\n                proto.$hooks |= 8 /* hasBound */;\n                proto.$nextBound = null;\n            }\n            if ('unbinding' in proto)\n                proto.$hooks |= 256 /* hasUnbinding */;\n            if ('unbound' in proto) {\n                proto.$hooks |= 512 /* hasUnbound */;\n                proto.$nextUnbound = null;\n            }\n            if ('render' in proto)\n                proto.$hooks |= 1024 /* hasRender */;\n            if ('created' in proto)\n                proto.$hooks |= 2 /* hasCreated */;\n            if ('attaching' in proto)\n                proto.$hooks |= 16 /* hasAttaching */;\n            if ('attached' in proto) {\n                proto.$hooks |= 32 /* hasAttached */;\n                proto.$nextAttached = null;\n            }\n            if ('detaching' in proto)\n                proto.$hooks |= 64 /* hasDetaching */;\n            if ('caching' in proto)\n                proto.$hooks |= 2048 /* hasCaching */;\n            if ('detached' in proto) {\n                proto.$hooks |= 128 /* hasDetached */;\n                proto.$nextDetached = null;\n            }\n            return Type;\n        }\n    };\n    /*@internal*/\n    function registerElement(container) {\n        const resourceKey = CustomElementResource.keyFrom(this.description.name);\n        container.register(kernel.Registration.transient(resourceKey, this));\n    }\n    // tslint:enable:align\n    // TODO\n    // ## DefaultSlotProjector\n    // An implementation of IElementProjector that can handle a subset of default\n    // slot projection scenarios without needing real Shadow DOM.\n    // ### Conditions\n    // We can do a one-time, static composition of the content and view,\n    // to emulate shadow DOM, if the following constraints are met:\n    // * There must be exactly one slot and it must be a default slot.\n    // * The default slot must not have any fallback content.\n    // * The default slot must not have a custom element as its immediate parent or\n    //   a slot attribute (re-projection).\n    // ### Projection\n    // The projector copies all content nodes to the slot's location.\n    // The copy process should inject a comment node before and after the slotted\n    // content, so that the bounds of the content can be clearly determined,\n    // even if the slotted content has template controllers or string interpolation.\n    // ### Encapsulation Source\n    // Uses the same strategy as HostProjector.\n    // ### Children\n    // The projector adds a mutation observer to the parent node of the\n    // slot comment. When direct children of that node change, the projector\n    // will gather up all nodes between the start and end slot comments.\n\n    const composeSource = {\n        name: 'au-compose',\n        containerless: true\n    };\n    const composeProps = ['subject', 'composing'];\n    exports.Compose = class Compose {\n        constructor(renderable, instruction, renderingEngine, coordinator) {\n            this.renderable = renderable;\n            this.renderingEngine = renderingEngine;\n            this.coordinator = coordinator;\n            this.subject = null;\n            this.composing = false;\n            this.properties = null;\n            this.lastSubject = null;\n            this.coordinator.onSwapComplete = () => {\n                this.composing = false;\n            };\n            this.properties = instruction.instructions\n                .filter((x) => !composeProps.includes(x.to))\n                .reduce((acc, item) => {\n                if (item.to) {\n                    acc[item.to] = item;\n                }\n                return acc;\n            }, {});\n        }\n        binding(flags) {\n            this.startComposition(this.subject, undefined, flags);\n            this.coordinator.binding(flags, this.$scope);\n        }\n        attaching(flags) {\n            this.coordinator.attaching(flags);\n        }\n        detaching(flags) {\n            this.coordinator.detaching(flags);\n        }\n        unbinding(flags) {\n            this.lastSubject = null;\n            this.coordinator.unbinding(flags);\n        }\n        caching(flags) {\n            this.coordinator.caching(flags);\n        }\n        subjectChanged(newValue, previousValue, flags) {\n            this.startComposition(newValue, previousValue, flags);\n        }\n        startComposition(subject, previousSubject, flags) {\n            if (this.lastSubject === subject) {\n                return;\n            }\n            this.lastSubject = subject;\n            if (subject instanceof Promise) {\n                subject = subject.then(x => this.resolveView(x, flags));\n            }\n            else {\n                subject = this.resolveView(subject, flags);\n            }\n            this.composing = true;\n            this.coordinator.compose(subject, flags);\n        }\n        resolveView(subject, flags) {\n            const view = this.provideViewFor(subject);\n            if (view) {\n                view.hold(this.$projector.host, flags);\n                view.lockScope(this.renderable.$scope);\n                return view;\n            }\n            return null;\n        }\n        provideViewFor(subject) {\n            if (!subject) {\n                return null;\n            }\n            if ('lockScope' in subject) { // IView\n                return subject;\n            }\n            if ('createView' in subject) { // RenderPlan\n                return subject.createView(this.renderingEngine, this.renderable.$context);\n            }\n            if ('create' in subject) { // IViewFactory\n                return subject.create();\n            }\n            if ('template' in subject) { // Raw Template Definition\n                return this.renderingEngine.getViewFactory(subject, this.renderable.$context).create();\n            }\n            // Constructable (Custom Element Constructor)\n            return createElement(subject, this.properties, this.$projector.children).createView(this.renderingEngine, this.renderable.$context);\n        }\n    };\n    __decorate([\n        bindable\n    ], exports.Compose.prototype, \"subject\", void 0);\n    __decorate([\n        bindable\n    ], exports.Compose.prototype, \"composing\", void 0);\n    exports.Compose = __decorate([\n        customElement(composeSource),\n        kernel.inject(IRenderable, ITargetedInstruction, IRenderingEngine, exports.CompositionCoordinator)\n    ], exports.Compose);\n\n    /**\n     * Decorator: Indicates that the decorated class is a custom attribute.\n     */\n    function customAttribute(nameOrDef) {\n        return target => CustomAttributeResource.define(nameOrDef, target);\n    }\n    /**\n     * Decorator: Applied to custom attributes. Indicates that whatever element the\n     * attribute is placed on should be converted into a template and that this\n     * attribute controls the instantiation of the template.\n     */\n    function templateController(nameOrDef) {\n        return target => CustomAttributeResource.define(typeof nameOrDef === 'string'\n            ? { isTemplateController: true, name: nameOrDef }\n            : Object.assign({ isTemplateController: true }, nameOrDef), target);\n    }\n    const CustomAttributeResource = {\n        name: customAttributeName,\n        keyFrom: customAttributeKey,\n        isType(Type) {\n            return Type.kind === this;\n        },\n        define(nameOrSource, ctor) {\n            const Type = ctor;\n            const description = createCustomAttributeDescription(typeof nameOrSource === 'string' ? { name: nameOrSource } : nameOrSource, Type);\n            const proto = Type.prototype;\n            Type.kind = CustomAttributeResource;\n            Type.description = description;\n            Type.register = registerAttribute;\n            proto.$hydrate = $hydrateAttribute;\n            proto.$bind = $bindAttribute;\n            proto.$attach = $attachAttribute;\n            proto.$detach = $detachAttribute;\n            proto.$unbind = $unbindAttribute;\n            proto.$cache = $cacheAttribute;\n            proto.$prevBind = null;\n            proto.$nextBind = null;\n            proto.$prevAttach = null;\n            proto.$nextAttach = null;\n            proto.$nextUnbindAfterDetach = null;\n            proto.$scope = null;\n            proto.$hooks = 0;\n            proto.$state = 0;\n            if ('flush' in proto) {\n                proto.$nextFlush = null;\n            }\n            if ('binding' in proto)\n                proto.$hooks |= 4 /* hasBinding */;\n            if ('bound' in proto) {\n                proto.$hooks |= 8 /* hasBound */;\n                proto.$nextBound = null;\n            }\n            if ('unbinding' in proto)\n                proto.$hooks |= 256 /* hasUnbinding */;\n            if ('unbound' in proto) {\n                proto.$hooks |= 512 /* hasUnbound */;\n                proto.$nextUnbound = null;\n            }\n            if ('created' in proto)\n                proto.$hooks |= 2 /* hasCreated */;\n            if ('attaching' in proto)\n                proto.$hooks |= 16 /* hasAttaching */;\n            if ('attached' in proto) {\n                proto.$hooks |= 32 /* hasAttached */;\n                proto.$nextAttached = null;\n            }\n            if ('detaching' in proto)\n                proto.$hooks |= 64 /* hasDetaching */;\n            if ('caching' in proto)\n                proto.$hooks |= 2048 /* hasCaching */;\n            if ('detached' in proto) {\n                proto.$hooks |= 128 /* hasDetached */;\n                proto.$nextDetached = null;\n            }\n            return Type;\n        }\n    };\n    /*@internal*/\n    function registerAttribute(container) {\n        const description = this.description;\n        const resourceKey = CustomAttributeResource.keyFrom(description.name);\n        const aliases = description.aliases;\n        container.register(kernel.Registration.transient(resourceKey, this));\n        for (let i = 0, ii = aliases.length; i < ii; ++i) {\n            const aliasKey = CustomAttributeResource.keyFrom(aliases[i]);\n            container.register(kernel.Registration.alias(resourceKey, aliasKey));\n        }\n    }\n    /*@internal*/\n    function createCustomAttributeDescription(def, Type) {\n        return {\n            name: def.name,\n            aliases: def.aliases || kernel.PLATFORM.emptyArray,\n            defaultBindingMode: def.defaultBindingMode || exports.BindingMode.toView,\n            isTemplateController: def.isTemplateController || false,\n            bindables: Object.assign({}, Type.bindables, def.bindables)\n        };\n    }\n\n    exports.If = class If {\n        constructor(ifFactory, location, coordinator) {\n            this.ifFactory = ifFactory;\n            this.location = location;\n            this.coordinator = coordinator;\n            this.value = false;\n            this.elseFactory = null;\n            this.ifView = null;\n            this.elseView = null;\n        }\n        binding(flags) {\n            const view = this.updateView(flags);\n            this.coordinator.compose(view, flags);\n            this.coordinator.binding(flags, this.$scope);\n        }\n        attaching(flags) {\n            this.coordinator.attaching(flags);\n        }\n        detaching(flags) {\n            this.coordinator.detaching(flags);\n        }\n        unbinding(flags) {\n            this.coordinator.unbinding(flags);\n        }\n        caching(flags) {\n            if (this.ifView !== null && this.ifView.release(flags)) {\n                this.ifView = null;\n            }\n            if (this.elseView !== null && this.elseView.release(flags)) {\n                this.elseView = null;\n            }\n            this.coordinator.caching(flags);\n        }\n        valueChanged(newValue, oldValue, flags) {\n            if (flags & exports.LifecycleFlags.fromFlush) {\n                const view = this.updateView(flags);\n                this.coordinator.compose(view, flags);\n            }\n            else {\n                this.$lifecycle.enqueueFlush(this);\n            }\n        }\n        flush(flags) {\n            const view = this.updateView(flags);\n            this.coordinator.compose(view, flags);\n        }\n        /*@internal*/\n        updateView(flags) {\n            let view;\n            if (this.value) {\n                view = this.ifView = this.ensureView(this.ifView, this.ifFactory, flags);\n            }\n            else if (this.elseFactory !== null) {\n                view = this.elseView = this.ensureView(this.elseView, this.elseFactory, flags);\n            }\n            else {\n                view = null;\n            }\n            return view;\n        }\n        /*@internal*/\n        ensureView(view, factory, flags) {\n            if (view === null) {\n                view = factory.create();\n            }\n            view.hold(this.location, flags);\n            return view;\n        }\n    };\n    __decorate([\n        bindable\n    ], exports.If.prototype, \"value\", void 0);\n    exports.If = __decorate([\n        templateController('if'),\n        kernel.inject(IViewFactory, IRenderLocation, exports.CompositionCoordinator)\n    ], exports.If);\n    exports.Else = class Else {\n        constructor(factory) {\n            this.factory = factory;\n        }\n        link(ifBehavior) {\n            ifBehavior.elseFactory = this.factory;\n        }\n    };\n    exports.Else = __decorate([\n        templateController('else'),\n        kernel.inject(IViewFactory)\n    ], exports.Else);\n\n    exports.Repeat = class Repeat {\n        constructor(location, renderable, factory) {\n            this.location = location;\n            this.renderable = renderable;\n            this.factory = factory;\n            this.encapsulationSource = null;\n            this.views = [];\n            this.observer = null;\n            this.hasPendingInstanceMutation = false;\n        }\n        binding(flags) {\n            this.checkCollectionObserver();\n        }\n        bound(flags) {\n            let current = this.renderable.$bindableHead;\n            while (current !== null) {\n                if (current.target === this && current.targetProperty === 'items') {\n                    this.forOf = current.sourceExpression;\n                    break;\n                }\n                current = current.$nextBind;\n            }\n            this.local = this.forOf.declaration.evaluate(flags, this.$scope, null);\n            this.processViews(null, flags);\n        }\n        attaching(flags) {\n            const { views, location } = this;\n            for (let i = 0, ii = views.length; i < ii; ++i) {\n                const view = views[i];\n                view.hold(location, flags);\n                view.$attach(flags);\n            }\n        }\n        detaching(flags) {\n            const { views } = this;\n            for (let i = 0, ii = views.length; i < ii; ++i) {\n                const view = views[i];\n                view.$detach(flags);\n                view.release(flags);\n            }\n        }\n        unbound(flags) {\n            this.checkCollectionObserver();\n            const { views } = this;\n            for (let i = 0, ii = views.length; i < ii; ++i) {\n                const view = views[i];\n                view.$unbind(flags);\n            }\n        }\n        // called by SetterObserver (sync)\n        itemsChanged(newValue, oldValue, flags) {\n            this.checkCollectionObserver();\n            this.processViews(null, flags | exports.LifecycleFlags.updateTargetInstance);\n        }\n        // called by a CollectionObserver (async)\n        handleBatchedChange(indexMap) {\n            this.processViews(indexMap, exports.LifecycleFlags.fromFlush | exports.LifecycleFlags.updateTargetInstance);\n        }\n        // if the indexMap === null, it is an instance mutation, otherwise it's an items mutation\n        processViews(indexMap, flags) {\n            const { views, $lifecycle } = this;\n            if (this.$state & 2 /* isBound */) {\n                const { local, $scope, factory, forOf, items } = this;\n                const oldLength = views.length;\n                const newLength = forOf.count(items);\n                if (oldLength < newLength) {\n                    views.length = newLength;\n                    for (let i = oldLength; i < newLength; ++i) {\n                        views[i] = factory.create();\n                    }\n                }\n                else if (newLength < oldLength) {\n                    $lifecycle.beginDetach();\n                    for (let i = newLength, view = views[i]; i < oldLength; view = views[++i]) {\n                        view.release(flags);\n                        view.$detach(flags);\n                    }\n                    $lifecycle.endDetach(flags);\n                    $lifecycle.beginUnbind();\n                    for (let i = newLength, view = views[i]; i < oldLength; view = views[++i]) {\n                        view.$unbind(flags);\n                    }\n                    $lifecycle.endUnbind(flags);\n                    views.length = newLength;\n                    if (newLength === 0) {\n                        return;\n                    }\n                }\n                else if (newLength === 0) {\n                    return;\n                }\n                $lifecycle.beginBind();\n                if (indexMap === null) {\n                    forOf.iterate(items, (arr, i, item) => {\n                        const view = views[i];\n                        if (!!view.$scope && view.$scope.bindingContext[local] === item) {\n                            view.$bind(flags, Scope.fromParent($scope, view.$scope.bindingContext));\n                        }\n                        else {\n                            view.$bind(flags, Scope.fromParent($scope, BindingContext.create(local, item)));\n                        }\n                    });\n                }\n                else {\n                    forOf.iterate(items, (arr, i, item) => {\n                        const view = views[i];\n                        if (indexMap[i] === i && !!view.$scope) {\n                            view.$bind(flags, Scope.fromParent($scope, view.$scope.bindingContext));\n                        }\n                        else {\n                            view.$bind(flags, Scope.fromParent($scope, BindingContext.create(local, item)));\n                        }\n                    });\n                }\n                $lifecycle.endBind(flags);\n            }\n            if (this.$state & 8 /* isAttached */) {\n                const { location } = this;\n                $lifecycle.beginAttach();\n                if (indexMap === null) {\n                    for (let i = 0, ii = views.length; i < ii; ++i) {\n                        const view = views[i];\n                        view.hold(location, flags);\n                        view.$attach(flags);\n                    }\n                }\n                else {\n                    for (let i = 0, ii = views.length; i < ii; ++i) {\n                        if (indexMap[i] !== i) {\n                            const view = views[i];\n                            view.hold(location, flags);\n                            view.$attach(flags);\n                        }\n                    }\n                }\n                $lifecycle.endAttach(flags);\n            }\n        }\n        checkCollectionObserver() {\n            const oldObserver = this.observer;\n            if (this.$state & (2 /* isBound */ | 1 /* isBinding */)) {\n                const newObserver = this.observer = getCollectionObserver(this.$lifecycle, this.items);\n                if (oldObserver !== newObserver) {\n                    if (oldObserver) {\n                        oldObserver.unsubscribeBatched(this);\n                    }\n                }\n                if (newObserver) {\n                    newObserver.subscribeBatched(this);\n                }\n            }\n            else if (oldObserver) {\n                oldObserver.unsubscribeBatched(this);\n            }\n        }\n    };\n    __decorate([\n        bindable\n    ], exports.Repeat.prototype, \"items\", void 0);\n    exports.Repeat = __decorate([\n        kernel.inject(IRenderLocation, IRenderable, IViewFactory),\n        templateController('repeat')\n    ], exports.Repeat);\n\n    exports.Replaceable = class Replaceable {\n        constructor(factory, location) {\n            this.factory = factory;\n            this.currentView = this.factory.create();\n            this.currentView.hold(location, exports.LifecycleFlags.fromCreate);\n        }\n        binding(flags) {\n            this.currentView.$bind(flags, this.$scope);\n        }\n        attaching(flags) {\n            this.currentView.$attach(flags);\n        }\n        detaching(flags) {\n            this.currentView.$detach(flags);\n        }\n        unbinding(flags) {\n            this.currentView.$unbind(flags);\n        }\n    };\n    exports.Replaceable = __decorate([\n        templateController('replaceable'),\n        kernel.inject(IViewFactory, IRenderLocation)\n    ], exports.Replaceable);\n\n    exports.With = class With {\n        constructor(factory, location) {\n            this.factory = factory;\n            this.value = null;\n            this.currentView = null;\n            this.currentView = this.factory.create();\n            this.currentView.hold(location, exports.LifecycleFlags.fromCreate);\n        }\n        valueChanged() {\n            if (this.$state & 2 /* isBound */) {\n                this.bindChild(exports.LifecycleFlags.fromBindableHandler);\n            }\n        }\n        binding(flags) {\n            this.bindChild(flags);\n        }\n        attaching(flags) {\n            this.currentView.$attach(flags);\n        }\n        detaching(flags) {\n            this.currentView.$detach(flags);\n        }\n        unbinding(flags) {\n            this.currentView.$unbind(flags);\n        }\n        bindChild(flags) {\n            const scope = Scope.fromParent(this.$scope, this.value);\n            this.currentView.$bind(flags, scope);\n        }\n    };\n    __decorate([\n        bindable\n    ], exports.With.prototype, \"value\", void 0);\n    exports.With = __decorate([\n        templateController('with'),\n        kernel.inject(IViewFactory, IRenderLocation)\n    ], exports.With);\n\n    class Aurelia {\n        constructor(container = kernel.DI.createContainer()) {\n            this.container = container;\n            this.components = [];\n            this.startTasks = [];\n            this.stopTasks = [];\n            this.isStarted = false;\n            this._root = null;\n            kernel.Registration\n                .instance(Aurelia, this)\n                .register(container, Aurelia);\n        }\n        register(...params) {\n            this.container.register(...params);\n            return this;\n        }\n        app(config) {\n            const component = config.component;\n            const host = config.host;\n            const startTask = () => {\n                host.$au = this;\n                if (!this.components.includes(component)) {\n                    this._root = component;\n                    this.components.push(component);\n                    const re = this.container.get(IRenderingEngine);\n                    component.$hydrate(re, host);\n                }\n                component.$bind(exports.LifecycleFlags.fromStartTask | exports.LifecycleFlags.fromBind);\n                component.$attach(exports.LifecycleFlags.fromStartTask);\n            };\n            this.startTasks.push(startTask);\n            this.stopTasks.push(() => {\n                component.$detach(exports.LifecycleFlags.fromStopTask);\n                component.$unbind(exports.LifecycleFlags.fromStopTask | exports.LifecycleFlags.fromUnbind);\n                host.$au = null;\n            });\n            if (this.isStarted) {\n                startTask();\n            }\n            return this;\n        }\n        root() {\n            return this._root;\n        }\n        start() {\n            for (const runStartTask of this.startTasks) {\n                runStartTask();\n            }\n            this.isStarted = true;\n            return this;\n        }\n        stop() {\n            this.isStarted = false;\n            for (const runStopTask of this.stopTasks) {\n                runStopTask();\n            }\n            return this;\n        }\n    }\n    kernel.PLATFORM.global.Aurelia = Aurelia;\n\n    exports.enableArrayObservation = enableArrayObservation;\n    exports.disableArrayObservation = disableArrayObservation;\n    exports.nativePush = nativePush;\n    exports.nativePop = nativePop;\n    exports.nativeShift = nativeShift;\n    exports.nativeUnshift = nativeUnshift;\n    exports.nativeSplice = nativeSplice;\n    exports.nativeReverse = nativeReverse;\n    exports.nativeSort = nativeSort;\n    exports.enableMapObservation = enableMapObservation;\n    exports.disableMapObservation = disableMapObservation;\n    exports.nativeSet = nativeSet;\n    exports.nativeMapDelete = nativeDelete;\n    exports.nativeMapClear = nativeClear;\n    exports.enableSetObservation = enableSetObservation;\n    exports.disableSetObservation = disableSetObservation;\n    exports.nativeAdd = nativeAdd;\n    exports.nativeSetDelete = nativeDelete$1;\n    exports.nativeSetClear = nativeClear$1;\n    exports.BindingModeBehavior = BindingModeBehavior;\n    exports.debounceCallSource = debounceCallSource;\n    exports.debounceCall = debounceCall;\n    exports.ISanitizer = ISanitizer;\n    exports.handleSelfEvent = handleSelfEvent;\n    exports.throttle = throttle;\n    exports.connects = connects;\n    exports.observes = observes;\n    exports.callsFunction = callsFunction;\n    exports.hasAncestor = hasAncestor;\n    exports.isAssignable = isAssignable;\n    exports.isLeftHandSide = isLeftHandSide;\n    exports.isPrimary = isPrimary;\n    exports.isResource = isResource;\n    exports.hasBind = hasBind;\n    exports.hasUnbind = hasUnbind;\n    exports.isLiteral = isLiteral;\n    exports.arePureLiterals = arePureLiterals;\n    exports.isPureLiteral = isPureLiteral;\n    exports.BindingBehavior = BindingBehavior;\n    exports.ValueConverter = ValueConverter;\n    exports.Assign = Assign;\n    exports.Conditional = Conditional;\n    exports.AccessThis = AccessThis;\n    exports.AccessScope = AccessScope;\n    exports.AccessMember = AccessMember;\n    exports.AccessKeyed = AccessKeyed;\n    exports.CallScope = CallScope;\n    exports.CallMember = CallMember;\n    exports.CallFunction = CallFunction;\n    exports.Binary = Binary;\n    exports.Unary = Unary;\n    exports.PrimitiveLiteral = PrimitiveLiteral;\n    exports.HtmlLiteral = HtmlLiteral;\n    exports.ArrayLiteral = ArrayLiteral;\n    exports.ObjectLiteral = ObjectLiteral;\n    exports.Template = Template;\n    exports.TaggedTemplate = TaggedTemplate;\n    exports.ArrayBindingPattern = ArrayBindingPattern;\n    exports.ObjectBindingPattern = ObjectBindingPattern;\n    exports.BindingIdentifier = BindingIdentifier;\n    exports.ForOfStatement = ForOfStatement;\n    exports.Interpolation = Interpolation;\n    exports.IterateForOfStatement = IterateForOfStatement;\n    exports.CountForOfStatement = CountForOfStatement;\n    exports.bindingBehavior = bindingBehavior;\n    exports.BindingBehaviorResource = BindingBehaviorResource;\n    exports.InternalObserversLookup = InternalObserversLookup;\n    exports.BindingContext = BindingContext;\n    exports.Scope = Scope;\n    exports.OverrideContext = OverrideContext;\n    exports.Call = Call;\n    exports.collectionObserver = collectionObserver;\n    exports.computed = computed;\n    exports.createComputedObserver = createComputedObserver;\n    exports.GetterController = GetterController;\n    exports.IDirtyChecker = IDirtyChecker;\n    exports.DirtyChecker = DirtyChecker;\n    exports.findOriginalEventTarget = findOriginalEventTarget;\n    exports.ListenerTracker = ListenerTracker;\n    exports.DelegateOrCaptureSubscription = DelegateOrCaptureSubscription;\n    exports.TriggerSubscription = TriggerSubscription;\n    exports.EventSubscriber = EventSubscriber;\n    exports.IEventManager = IEventManager;\n    exports.EventManager = EventManager;\n    exports.IExpressionParser = IExpressionParser;\n    exports.ExpressionParser = ExpressionParser;\n    exports.MultiInterpolationBinding = MultiInterpolationBinding;\n    exports.Listener = Listener;\n    exports.IObserverLocator = IObserverLocator;\n    exports.getCollectionObserver = getCollectionObserver;\n    exports.PrimitiveObserver = PrimitiveObserver;\n    exports.Ref = Ref;\n    exports.ISignaler = ISignaler;\n    exports.Signaler = Signaler;\n    exports.subscriberCollection = subscriberCollection;\n    exports.batchedSubscriberCollection = batchedSubscriberCollection;\n    exports.ISVGAnalyzer = ISVGAnalyzer;\n    exports.PropertyAccessor = PropertyAccessor;\n    exports.targetObserver = targetObserver;\n    exports.valueConverter = valueConverter;\n    exports.ValueConverterResource = ValueConverterResource;\n    exports.bindable = bindable;\n    exports.createElement = createElement;\n    exports.RenderPlan = RenderPlan;\n    exports.customAttribute = customAttribute;\n    exports.templateController = templateController;\n    exports.CustomAttributeResource = CustomAttributeResource;\n    exports.registerAttribute = registerAttribute;\n    exports.createCustomAttributeDescription = createCustomAttributeDescription;\n    exports.customElement = customElement;\n    exports.useShadowDOM = useShadowDOM;\n    exports.containerless = containerless;\n    exports.CustomElementResource = CustomElementResource;\n    exports.registerElement = registerElement;\n    exports.$attachAttribute = $attachAttribute;\n    exports.$attachElement = $attachElement;\n    exports.$attachView = $attachView;\n    exports.$detachAttribute = $detachAttribute;\n    exports.$detachElement = $detachElement;\n    exports.$detachView = $detachView;\n    exports.$cacheAttribute = $cacheAttribute;\n    exports.$cacheElement = $cacheElement;\n    exports.$cacheView = $cacheView;\n    exports.$mountElement = $mountElement;\n    exports.$unmountElement = $unmountElement;\n    exports.$mountView = $mountView;\n    exports.$unmountView = $unmountView;\n    exports.$bindAttribute = $bindAttribute;\n    exports.$bindElement = $bindElement;\n    exports.$bindView = $bindView;\n    exports.$unbindAttribute = $unbindAttribute;\n    exports.$unbindElement = $unbindElement;\n    exports.$unbindView = $unbindView;\n    exports.renderStrategy = renderStrategy;\n    exports.RenderStrategyResource = RenderStrategyResource;\n    exports.registerRenderStrategy = registerRenderStrategy;\n    exports.ITemplateCompiler = ITemplateCompiler;\n    exports.$hydrateAttribute = $hydrateAttribute;\n    exports.$hydrateElement = $hydrateElement;\n    exports.defaultShadowOptions = defaultShadowOptions;\n    exports.IRenderingEngine = IRenderingEngine;\n    exports.ShadowDOMProjector = ShadowDOMProjector;\n    exports.ContainerlessProjector = ContainerlessProjector;\n    exports.HostProjector = HostProjector;\n    exports.RuntimeBehavior = RuntimeBehavior;\n    exports.findElements = findElements;\n    exports.RuntimeCompilationResources = RuntimeCompilationResources;\n    exports.CompiledTemplate = CompiledTemplate;\n    exports.noViewTemplate = noViewTemplate;\n    exports.createRenderContext = createRenderContext;\n    exports.InstanceProvider = InstanceProvider;\n    exports.ViewFactoryProvider = ViewFactoryProvider;\n    exports.addBindable = addBindable;\n    exports.addAttachable = addAttachable;\n    exports.Renderer = Renderer;\n    exports.View = View;\n    exports.ViewFactory = ViewFactory;\n    exports.Aurelia = Aurelia;\n    exports.customElementName = customElementName;\n    exports.customElementKey = customElementKey;\n    exports.customElementBehavior = customElementBehavior;\n    exports.customAttributeName = customAttributeName;\n    exports.customAttributeKey = customAttributeKey;\n    exports.ITargetedInstruction = ITargetedInstruction;\n    exports.isTargetedInstruction = isTargetedInstruction;\n    exports.buildRequired = buildRequired;\n    exports.buildTemplateDefinition = buildTemplateDefinition;\n    exports.ELEMENT_NODE = ELEMENT_NODE;\n    exports.ATTRIBUTE_NODE = ATTRIBUTE_NODE;\n    exports.TEXT_NODE = TEXT_NODE;\n    exports.COMMENT_NODE = COMMENT_NODE;\n    exports.DOCUMENT_FRAGMENT_NODE = DOCUMENT_FRAGMENT_NODE;\n    exports.INode = INode;\n    exports.IRenderLocation = IRenderLocation;\n    exports.DOM = DOM;\n    exports.NodeSequence = NodeSequence;\n    exports.TextNodeSequence = TextNodeSequence;\n    exports.FragmentNodeSequence = FragmentNodeSequence;\n    exports.NodeSequenceFactory = NodeSequenceFactory;\n    exports.AuMarker = AuMarker;\n    exports.IRenderable = IRenderable;\n    exports.IViewFactory = IViewFactory;\n    exports.ILifecycle = ILifecycle;\n    exports.IFlushLifecycle = IFlushLifecycle;\n    exports.IBindLifecycle = IBindLifecycle;\n    exports.IAttachLifecycle = IAttachLifecycle;\n    exports.Lifecycle = Lifecycle;\n    exports.LifecycleTask = LifecycleTask;\n    exports.AggregateLifecycleTask = AggregateLifecycleTask;\n    exports.PromiseSwap = PromiseSwap;\n    exports.PromiseTask = PromiseTask;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2luZGV4LnVtZC5qcz8xMTFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDN0csSUFBSSxTQUM4QztBQUNsRCxDQUFDLG1DQUFtQzs7QUFFcEM7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0RBQXdEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0RBQW9EOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjLEVBQUU7QUFDekM7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QixvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsR0FBRyxLQUFLO0FBQ3hDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0RBQWtEO0FBQ2xELFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DLEVBQUU7QUFDNUQsK0JBQStCLEVBQUU7QUFDakMsMEJBQTBCLEVBQUU7QUFDNUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxnQkFBZ0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb05BQW9OLFlBQVk7QUFDaE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssa0RBQWtEOztBQUV2RCxXQUFXLG9DQUFvQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQSx1REFBdUQsbUVBQW1FO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsR0FBRyxLQUFLO0FBQ3hDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCLEVBQUU7QUFDNUQsa0NBQWtDLG9CQUFvQixFQUFFO0FBQ3hELGtDQUFrQyxvQkFBb0IsRUFBRTtBQUN4RCxxQ0FBcUMsZUFBZSxFQUFFO0FBQ3RELG1DQUFtQyxVQUFVLEVBQUU7QUFDL0Msd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRCwyQ0FBMkMsRUFBRTtBQUM3Qyx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw2REFBNkQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFDQUFxQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdFQUFnRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx1RUFBdUU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsdUVBQXVFO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx1RUFBdUU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQXFEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsR0FBRyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0IsR0FBRyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLGtIQUFrSDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsR0FBRyxLQUFLO0FBQ3hDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0VBQW9FLHFCQUFxQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0REFBNEQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUMsRUFBRTtBQUN6RSxtQ0FBbUMsb0ZBQW9GO0FBQ3ZILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUNoRDtBQUNBLHdEQUF3RDtBQUN4RCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0EseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLDZCQUE2Qiw2QkFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxR0FBcUcscUJBQXFCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBLHVCQUF1Qix1Q0FBdUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxlQUFlO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsY0FBYzs7QUFFaEUsQ0FBQztBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9pbmRleC51bWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGF1cmVsaWEva2VybmVsJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0BhdXJlbGlhL2tlcm5lbCddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbC5ydW50aW1lID0ge30pLGdsb2JhbC5rZXJuZWwpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGtlcm5lbCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcbiAgICB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgICBUSElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxuICAgIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXG4gICAgTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cblxuICAgIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xuICAgIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4gICAgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICAgIH1cblxuICAgIChmdW5jdGlvbiAoTGlmZWN5Y2xlRmxhZ3MpIHtcbiAgICAgICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJub25lXCJdID0gMF0gPSBcIm5vbmVcIjtcbiAgICAgICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJtdXN0RXZhbHVhdGVcIl0gPSA1MjQyODhdID0gXCJtdXN0RXZhbHVhdGVcIjtcbiAgICAgICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJtdXRhdGlvblwiXSA9IDNdID0gXCJtdXRhdGlvblwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImlzQ29sbGVjdGlvbk11dGF0aW9uXCJdID0gMV0gPSBcImlzQ29sbGVjdGlvbk11dGF0aW9uXCI7XG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiaXNJbnN0YW5jZU11dGF0aW9uXCJdID0gMl0gPSBcImlzSW5zdGFuY2VNdXRhdGlvblwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcInVwZGF0ZVwiXSA9IDI4XSA9IFwidXBkYXRlXCI7XG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1widXBkYXRlVGFyZ2V0T2JzZXJ2ZXJcIl0gPSA0XSA9IFwidXBkYXRlVGFyZ2V0T2JzZXJ2ZXJcIjtcbiAgICAgICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJ1cGRhdGVUYXJnZXRJbnN0YW5jZVwiXSA9IDhdID0gXCJ1cGRhdGVUYXJnZXRJbnN0YW5jZVwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcInVwZGF0ZVNvdXJjZUV4cHJlc3Npb25cIl0gPSAxNl0gPSBcInVwZGF0ZVNvdXJjZUV4cHJlc3Npb25cIjtcbiAgICAgICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJmcm9tXCJdID0gNTI0MjU2XSA9IFwiZnJvbVwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21GbHVzaFwiXSA9IDk2XSA9IFwiZnJvbUZsdXNoXCI7XG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbUFzeW5jRmx1c2hcIl0gPSAzMl0gPSBcImZyb21Bc3luY0ZsdXNoXCI7XG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbVN5bmNGbHVzaFwiXSA9IDY0XSA9IFwiZnJvbVN5bmNGbHVzaFwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21TdGFydFRhc2tcIl0gPSAxMjhdID0gXCJmcm9tU3RhcnRUYXNrXCI7XG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbVN0b3BUYXNrXCJdID0gMjU2XSA9IFwiZnJvbVN0b3BUYXNrXCI7XG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbUJpbmRcIl0gPSA1MTJdID0gXCJmcm9tQmluZFwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21VbmJpbmRcIl0gPSAxMDI0XSA9IFwiZnJvbVVuYmluZFwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21BdHRhY2hcIl0gPSAyMDQ4XSA9IFwiZnJvbUF0dGFjaFwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21EZXRhY2hcIl0gPSA0MDk2XSA9IFwiZnJvbURldGFjaFwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21DYWNoZVwiXSA9IDgxOTJdID0gXCJmcm9tQ2FjaGVcIjtcbiAgICAgICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJmcm9tQ3JlYXRlXCJdID0gMTYzODRdID0gXCJmcm9tQ3JlYXRlXCI7XG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbURPTUV2ZW50XCJdID0gMzI3NjhdID0gXCJmcm9tRE9NRXZlbnRcIjtcbiAgICAgICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJmcm9tT2JzZXJ2ZXJTZXR0ZXJcIl0gPSA2NTUzNl0gPSBcImZyb21PYnNlcnZlclNldHRlclwiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImZyb21CaW5kYWJsZUhhbmRsZXJcIl0gPSAxMzEwNzJdID0gXCJmcm9tQmluZGFibGVIYW5kbGVyXCI7XG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbUxpZmVjeWNsZVRhc2tcIl0gPSAyNjIxNDRdID0gXCJmcm9tTGlmZWN5Y2xlVGFza1wiO1xuICAgICAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcInBhcmVudFVubW91bnRRdWV1ZWRcIl0gPSAxMDQ4NTc2XSA9IFwicGFyZW50VW5tb3VudFF1ZXVlZFwiO1xuICAgICAgICAvLyB0aGlzIGZsYWcgaXMgZm9yIHRoZSBzeW5jaHJvbm91cyBmbHVzaCBiZWZvcmUgZGV0YWNoIChubyBwb2ludCBpbiB1cGRhdGluZyB0aGVcbiAgICAgICAgLy8gRE9NIGlmIGl0J3MgYWJvdXQgdG8gYmUgZGV0YWNoZWQpXG4gICAgICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZG9Ob3RVcGRhdGVET01cIl0gPSAyMDk3MTUyXSA9IFwiZG9Ob3RVcGRhdGVET01cIjtcbiAgICB9KShleHBvcnRzLkxpZmVjeWNsZUZsYWdzIHx8IChleHBvcnRzLkxpZmVjeWNsZUZsYWdzID0ge30pKTtcbiAgICAoZnVuY3Rpb24gKE11dGF0aW9uS2luZCkge1xuICAgICAgICBNdXRhdGlvbktpbmRbTXV0YXRpb25LaW5kW1wiaW5zdGFuY2VcIl0gPSAxXSA9IFwiaW5zdGFuY2VcIjtcbiAgICAgICAgTXV0YXRpb25LaW5kW011dGF0aW9uS2luZFtcImNvbGxlY3Rpb25cIl0gPSAyXSA9IFwiY29sbGVjdGlvblwiO1xuICAgIH0pKGV4cG9ydHMuTXV0YXRpb25LaW5kIHx8IChleHBvcnRzLk11dGF0aW9uS2luZCA9IHt9KSk7XG5cbiAgICBjb25zdCBJUmVuZGVyYWJsZSA9IGtlcm5lbC5ESS5jcmVhdGVJbnRlcmZhY2UoKS5ub0RlZmF1bHQoKTtcbiAgICBjb25zdCBJVmlld0ZhY3RvcnkgPSBrZXJuZWwuREkuY3JlYXRlSW50ZXJmYWNlKCkubm9EZWZhdWx0KCk7XG4gICAgY29uc3QgbWFya2VyID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBjb25zdCBJTGlmZWN5Y2xlID0ga2VybmVsLkRJLmNyZWF0ZUludGVyZmFjZSgpLndpdGhEZWZhdWx0KHggPT4geC5zaW5nbGV0b24oTGlmZWN5Y2xlKSk7XG4gICAgY29uc3QgSUZsdXNoTGlmZWN5Y2xlID0gSUxpZmVjeWNsZTtcbiAgICBjb25zdCBJQmluZExpZmVjeWNsZSA9IElMaWZlY3ljbGU7XG4gICAgY29uc3QgSUF0dGFjaExpZmVjeWNsZSA9IElMaWZlY3ljbGU7XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNsYXNzIExpZmVjeWNsZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmJpbmREZXB0aCA9IDA7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuYXR0YWNoRGVwdGggPSAwO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmRldGFjaERlcHRoID0gMDtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy51bmJpbmREZXB0aCA9IDA7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuZmx1c2hIZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5mbHVzaFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmNvbm5lY3RIZWFkID0gdGhpczsgLy8gdGhpcyBjYXN0IGlzIHNhZmUgYmVjYXVzZSB3ZSBrbm93IGV4YWN0bHkgd2hpY2ggcHJvcGVydGllcyB3ZSdsbCB1c2VcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5jb25uZWN0VGFpbCA9IHRoaXM7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMucGF0Y2hIZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5wYXRjaFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmJvdW5kSGVhZCA9IHRoaXM7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuYm91bmRUYWlsID0gdGhpcztcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5tb3VudEhlYWQgPSB0aGlzO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLm1vdW50VGFpbCA9IHRoaXM7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuYXR0YWNoZWRIZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5hdHRhY2hlZFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLnVubW91bnRIZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy51bm1vdW50VGFpbCA9IHRoaXM7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuZGV0YWNoZWRIZWFkID0gdGhpczsgLy9MT0xcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5kZXRhY2hlZFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLnVuYmluZEFmdGVyRGV0YWNoSGVhZCA9IHRoaXM7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMudW5iaW5kQWZ0ZXJEZXRhY2hUYWlsID0gdGhpcztcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy51bmJvdW5kSGVhZCA9IHRoaXM7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMudW5ib3VuZFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmZsdXNoZWQgPSBudWxsO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLnByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5mbHVzaENvdW50ID0gMDtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5jb25uZWN0Q291bnQgPSAwO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLnBhdGNoQ291bnQgPSAwO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmJvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLm1vdW50Q291bnQgPSAwO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmF0dGFjaGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLnVubW91bnRDb3VudCA9IDA7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuZGV0YWNoZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMudW5iaW5kQWZ0ZXJEZXRhY2hDb3VudCA9IDA7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMudW5ib3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBkdW1teSBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhlIGxpZmVjeWNsZSBjb25mb3JtIHRvIHRoZSBpbnRlcmZhY2VzXG4gICAgICAgICAgICAvLyBvZiB0aGUgY29tcG9uZW50cyBpdCBtYW5hZ2VzLiBUaGlzIGFsbG93cyB0aGUgbGlmZWN5Y2xlIGl0c2VsZiB0byBiZSB0aGUgZmlyc3QgbGlua1xuICAgICAgICAgICAgLy8gaW4gdGhlIGNoYWluIGFuZCByZW1vdmVzIHRoZSBuZWVkIGZvciBhbiBhZGRpdGlvbmFsIG51bGwgY2hlY2sgb24gZWFjaCBhZGRpdGlvbi5cbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy4kbmV4dEZsdXNoID0gbWFya2VyO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmZsdXNoID0ga2VybmVsLlBMQVRGT1JNLm5vb3A7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuJG5leHRDb25uZWN0ID0gbWFya2VyO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLmNvbm5lY3QgPSBrZXJuZWwuUExBVEZPUk0ubm9vcDtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy4kbmV4dFBhdGNoID0gbWFya2VyO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLnBhdGNoID0ga2VybmVsLlBMQVRGT1JNLm5vb3A7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuJG5leHRCb3VuZCA9IG1hcmtlcjtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5ib3VuZCA9IGtlcm5lbC5QTEFURk9STS5ub29wO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLiRuZXh0TW91bnQgPSBtYXJrZXI7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuJG1vdW50ID0ga2VybmVsLlBMQVRGT1JNLm5vb3A7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuJG5leHRBdHRhY2hlZCA9IG1hcmtlcjtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy5hdHRhY2hlZCA9IGtlcm5lbC5QTEFURk9STS5ub29wO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLiRuZXh0VW5tb3VudCA9IG1hcmtlcjtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy4kdW5tb3VudCA9IGtlcm5lbC5QTEFURk9STS5ub29wO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLiRuZXh0RGV0YWNoZWQgPSBtYXJrZXI7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMuZGV0YWNoZWQgPSBrZXJuZWwuUExBVEZPUk0ubm9vcDtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy4kbmV4dFVuYmluZEFmdGVyRGV0YWNoID0gbWFya2VyO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLiR1bmJpbmQgPSBrZXJuZWwuUExBVEZPUk0ubm9vcDtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi8gdGhpcy4kbmV4dFVuYm91bmQgPSBtYXJrZXI7XG4gICAgICAgICAgICAvKkBpbnRlcm5hbCovIHRoaXMudW5ib3VuZCA9IGtlcm5lbC5QTEFURk9STS5ub29wO1xuICAgICAgICAgICAgLypAaW50ZXJuYWwqLyB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyVGFzayh0YXNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YXNrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXNrID0gbmV3IEFnZ3JlZ2F0ZUxpZmVjeWNsZVRhc2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGFzay5hZGRUYXNrKHRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaFRhc2sodGFzaykge1xuICAgICAgICAgICAgaWYgKHRoaXMudGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhc2sgPT09IHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFzay5yZW1vdmVUYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdG9yKSB7XG4gICAgICAgICAgICAvLyBRdWV1ZSBhIGZsdXNoKCkgY2FsbGJhY2s7IHRoZSBkZXB0aCBpcyBqdXN0IGZvciBkZWJ1Z2dpbmcgLyB0ZXN0aW5nIHB1cnBvc2VzIGFuZCBoYXNcbiAgICAgICAgICAgIC8vIG5vIGVmZmVjdCBvbiBleGVjdXRpb24uIGZsdXNoKCkgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcyxcbiAgICAgICAgICAgIC8vIG9yIGl0IGNhbiBiZSBtYW51YWxseSBpbnZva2VkIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgICBpZiAodGhpcy5mbHVzaEhlYWQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoZWQgPSB0aGlzLnByb21pc2UudGhlbigoKSA9PiB0aGlzLnByb2Nlc3NGbHVzaFF1ZXVlKGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUFzeW5jRmx1c2gpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0b3IuJG5leHRGbHVzaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rvci4kbmV4dEZsdXNoID0gbWFya2VyO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hUYWlsLiRuZXh0Rmx1c2ggPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFRhaWwgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgKyt0aGlzLmZsdXNoQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaGVkO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NGbHVzaFF1ZXVlKGZsYWdzKSB7XG4gICAgICAgICAgICBmbGFncyB8PSBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21TeW5jRmx1c2g7XG4gICAgICAgICAgICAvLyBmbHVzaCBjYWxsYmFja3MgbWF5IGxlYWQgdG8gYWRkaXRpb25hbCBmbHVzaCBvcGVyYXRpb25zLCBzbyBrZWVwIGxvb3BpbmcgdW50aWxcbiAgICAgICAgICAgIC8vIHRoZSBmbHVzaCBoZWFkIGlzIGJhY2sgdG8gYHRoaXNgICh0aG91Z2ggdGhpcyB3aWxsIHR5cGljYWxseSBoYXBwZW4gaW4gdGhlIGZpcnN0IGl0ZXJhdGlvbilcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmZsdXNoQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZsdXNoSGVhZC4kbmV4dEZsdXNoO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hIZWFkID0gdGhpcy5mbHVzaFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudC4kbmV4dEZsdXNoO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LiRuZXh0Rmx1c2ggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmZsdXNoKGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudCAhPT0gbWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiZWdpbkJpbmQoKSB7XG4gICAgICAgICAgICArK3RoaXMuYmluZERlcHRoO1xuICAgICAgICB9XG4gICAgICAgIGVucXVldWVCb3VuZChyZXF1ZXN0b3IpIHtcbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgc3RhbmRhcmQgc2luZ2x5IGxpbmtlZCBsaXN0IGZvciBib3VuZCBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0b3IuJG5leHRCb3VuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rvci4kbmV4dEJvdW5kID0gbWFya2VyO1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRUYWlsLiRuZXh0Qm91bmQgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZFRhaWwgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgKyt0aGlzLmJvdW5kQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZUNvbm5lY3QocmVxdWVzdG9yKSB7XG4gICAgICAgICAgICAvLyBlbnF1ZXVlIGNvbm5lY3QgYW5kIHBhdGNoIGNhbGxzIGluIHNlcGFyYXRlIGxpc3RzIHNvIHRoYXQgdGhleSBjYW4gYmUgaW52b2tlZFxuICAgICAgICAgICAgLy8gaW5kZXBlbmRlbnRseSBmcm9tIGVhY2hvdGhlclxuICAgICAgICAgICAgLy8gVE9ETzogc2VlIGlmIHdlIGNhbiBlbGltaW5hdGUvb3B0aW1pemUgc29tZSBvZiB0aGlzLCBiZWNhdXNlIHRoaXMgaXMgYSByZWxhdGl2ZWx5IGhvdCBwYXRoXG4gICAgICAgICAgICAvLyAoZmlyc3QgZ2V0IGFsbCB0aGUgbmVjZXNzYXJ5IGludGVncmF0aW9uIHRlc3RzIHdvcmtpbmcsIHRoZW4gbG9vayBmb3Igb3B0aW1pemF0aW9ucylcbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgc3RhbmRhcmQgc2luZ2x5IGxpbmtlZCBsaXN0IGZvciBjb25uZWN0IGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Rvci4kbmV4dENvbm5lY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0b3IuJG5leHRDb25uZWN0ID0gbWFya2VyO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRhaWwuJG5leHRDb25uZWN0ID0gcmVxdWVzdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRhaWwgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgKyt0aGlzLmNvbm5lY3RDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgc3RhbmRhcmQgc2luZ2x5IGxpbmtlZCBsaXN0IGZvciBwYXRjaCBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0b3IuJG5leHRQYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rvci4kbmV4dFBhdGNoID0gbWFya2VyO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hUYWlsLiRuZXh0UGF0Y2ggPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaFRhaWwgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgKyt0aGlzLnBhdGNoQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0Nvbm5lY3RRdWV1ZShmbGFncykge1xuICAgICAgICAgICAgLy8gY29ubmVjdHMgY2Fubm90IGxlYWQgdG8gYWRkaXRpb25hbCBjb25uZWN0cywgc28gd2UgZG9uJ3QgbmVlZCB0byBsb29wIGhlcmVcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmNvbm5lY3RIZWFkLiRuZXh0Q29ubmVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RIZWFkID0gdGhpcy5jb25uZWN0VGFpbCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmNvbm5lY3QoZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudC4kbmV4dENvbm5lY3Q7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuJG5leHRDb25uZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudCAhPT0gbWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzUGF0Y2hRdWV1ZShmbGFncykge1xuICAgICAgICAgICAgLy8gZmx1c2ggYmVmb3JlIHBhdGNoaW5nLCBidXQgb25seSBpZiB0aGlzIGlzIHRoZSBpbml0aWFsIGJpbmQ7XG4gICAgICAgICAgICAvLyBubyBET00gaXMgYXR0YWNoZWQgeWV0IHNvIHdlIGNhbiBzYWZlbHkgbGV0IGV2ZXJ5dGhpbmcgcHJvcGFnYXRlXG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21TdGFydFRhc2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NGbHVzaFF1ZXVlKGZsYWdzIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tU3luY0ZsdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBhdGNoIGNhbGxiYWNrcyBtYXkgbGVhZCB0byBhZGRpdGlvbmFsIGJpbmQgb3BlcmF0aW9ucywgc28ga2VlcCBsb29waW5nIHVudGlsXG4gICAgICAgICAgICAvLyB0aGUgcGF0Y2ggaGVhZCBpcyBiYWNrIHRvIGB0aGlzYCAodGhvdWdoIHRoaXMgd2lsbCB0eXBpY2FsbHkgaGFwcGVuIGluIHRoZSBmaXJzdCBpdGVyYXRpb24pXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wYXRjaENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnBhdGNoSGVhZC4kbmV4dFBhdGNoO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hIZWFkID0gdGhpcy5wYXRjaFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wYXRjaChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBjdXJyZW50LiRuZXh0UGF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuJG5leHRQYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnQgIT09IG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5kQmluZChmbGFncykge1xuICAgICAgICAgICAgLy8gY2xvc2UgLyBzaHJpbmsgYSBiaW5kIGJhdGNoXG4gICAgICAgICAgICBpZiAoLS10aGlzLmJpbmREZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhc2sgIT09IG51bGwgJiYgIXRoaXMudGFzay5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFzay5vd25lciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0JpbmRRdWV1ZShmbGFncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExpZmVjeWNsZVRhc2suZG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQmluZFF1ZXVlKGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBmbHVzaCBiZWZvcmUgcHJvY2Vzc2luZyBib3VuZCBjYWxsYmFja3MsIGJ1dCBvbmx5IGlmIHRoaXMgaXMgdGhlIGluaXRpYWwgYmluZDtcbiAgICAgICAgICAgIC8vIG5vIERPTSBpcyBhdHRhY2hlZCB5ZXQgc28gd2UgY2FuIHNhZmVseSBsZXQgZXZlcnl0aGluZyBwcm9wYWdhdGVcbiAgICAgICAgICAgIGlmIChmbGFncyAmIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbVN0YXJ0VGFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ZsdXNoUXVldWUoZmxhZ3MgfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21TeW5jRmx1c2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYm91bmQgY2FsbGJhY2tzIG1heSBsZWFkIHRvIGFkZGl0aW9uYWwgYmluZCBvcGVyYXRpb25zLCBzbyBrZWVwIGxvb3BpbmcgdW50aWxcbiAgICAgICAgICAgIC8vIHRoZSBib3VuZCBoZWFkIGlzIGJhY2sgdG8gYHRoaXNgICh0aG91Z2ggdGhpcyB3aWxsIHR5cGljYWxseSBoYXBwZW4gaW4gdGhlIGZpcnN0IGl0ZXJhdGlvbilcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmJvdW5kQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuYm91bmRIZWFkLiRuZXh0Qm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZEhlYWQgPSB0aGlzLmJvdW5kVGFpbCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmJvdW5kKGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGN1cnJlbnQuJG5leHRCb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC4kbmV4dEJvdW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudCAhPT0gbWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiZWdpblVuYmluZCgpIHtcbiAgICAgICAgICAgIC8vIG9wZW4gdXAgLyBleHBhbmQgYW4gdW5iaW5kIGJhdGNoOyB0aGUgdmVyeSBmaXJzdCBjYWxsZXIgd2lsbCBjbG9zZSBpdCBhZ2FpbiB3aXRoIGVuZFVuYmluZFxuICAgICAgICAgICAgKyt0aGlzLnVuYmluZERlcHRoO1xuICAgICAgICB9XG4gICAgICAgIGVucXVldWVVbmJvdW5kKHJlcXVlc3Rvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgaWRlbXBvdGVudDsgYWRkaW5nIHRoZSBzYW1lIGl0ZW0gbW9yZSB0aGFuIG9uY2UgaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAgICAgICAgICAgLy8gYWRkaW5nIGl0IG9uY2UuXG4gICAgICAgICAgICAvLyBidWlsZCBhIHN0YW5kYXJkIHNpbmdseSBsaW5rZWQgbGlzdCBmb3IgdW5ib3VuZCBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0b3IuJG5leHRVbmJvdW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdG9yLiRuZXh0VW5ib3VuZCA9IG1hcmtlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYm91bmRUYWlsLiRuZXh0VW5ib3VuZCA9IHJlcXVlc3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYm91bmRUYWlsID0gcmVxdWVzdG9yO1xuICAgICAgICAgICAgICAgICsrdGhpcy51bmJvdW5kQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5kVW5iaW5kKGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBjbG9zZSAvIHNocmluayBhbiB1bmJpbmQgYmF0Y2hcbiAgICAgICAgICAgIGlmICgtLXRoaXMudW5iaW5kRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXNrICE9PSBudWxsICYmICF0aGlzLnRhc2suZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhc2sub3duZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NVbmJpbmRRdWV1ZShmbGFncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExpZmVjeWNsZVRhc2suZG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzVW5iaW5kUXVldWUoZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIHVuYm91bmQgY2FsbGJhY2tzIG1heSBsZWFkIHRvIGFkZGl0aW9uYWwgdW5iaW5kIG9wZXJhdGlvbnMsIHNvIGtlZXAgbG9vcGluZyB1bnRpbFxuICAgICAgICAgICAgLy8gdGhlIHVuYm91bmQgaGVhZCBpcyBiYWNrIHRvIGB0aGlzYCAodGhvdWdoIHRoaXMgd2lsbCB0eXBpY2FsbHkgaGFwcGVuIGluIHRoZSBmaXJzdCBpdGVyYXRpb24pXG4gICAgICAgICAgICB3aGlsZSAodGhpcy51bmJvdW5kQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy51bmJvdW5kSGVhZC4kbmV4dFVuYm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJvdW5kSGVhZCA9IHRoaXMudW5ib3VuZFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC51bmJvdW5kKGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGN1cnJlbnQuJG5leHRVbmJvdW5kO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LiRuZXh0VW5ib3VuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnQgIT09IG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmVnaW5BdHRhY2goKSB7XG4gICAgICAgICAgICAvLyBvcGVuIHVwIC8gZXhwYW5kIGFuIGF0dGFjaCBiYXRjaDsgdGhlIHZlcnkgZmlyc3QgY2FsbGVyIHdpbGwgY2xvc2UgaXQgYWdhaW4gd2l0aCBlbmRBdHRhY2hcbiAgICAgICAgICAgICsrdGhpcy5hdHRhY2hEZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlTW91bnQocmVxdWVzdG9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBpZGVtcG90ZW50OyBhZGRpbmcgdGhlIHNhbWUgaXRlbSBtb3JlIHRoYW4gb25jZSBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gICAgICAgICAgICAvLyBhZGRpbmcgaXQgb25jZS5cbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgc3RhbmRhcmQgc2luZ2x5IGxpbmtlZCBsaXN0IGZvciBtb3VudCBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0b3IuJG5leHRNb3VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rvci4kbmV4dE1vdW50ID0gbWFya2VyO1xuICAgICAgICAgICAgICAgIHRoaXMubW91bnRUYWlsLiRuZXh0TW91bnQgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudFRhaWwgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgKyt0aGlzLm1vdW50Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZUF0dGFjaGVkKHJlcXVlc3Rvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgaWRlbXBvdGVudDsgYWRkaW5nIHRoZSBzYW1lIGl0ZW0gbW9yZSB0aGFuIG9uY2UgaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAgICAgICAgICAgLy8gYWRkaW5nIGl0IG9uY2UuXG4gICAgICAgICAgICAvLyBidWlsZCBhIHN0YW5kYXJkIHNpbmdseSBsaW5rZWQgbGlzdCBmb3IgYXR0YWNoZWQgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAocmVxdWVzdG9yLiRuZXh0QXR0YWNoZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0b3IuJG5leHRBdHRhY2hlZCA9IG1hcmtlcjtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaGVkVGFpbC4kbmV4dEF0dGFjaGVkID0gcmVxdWVzdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoZWRUYWlsID0gcmVxdWVzdG9yO1xuICAgICAgICAgICAgICAgICsrdGhpcy5hdHRhY2hlZENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVuZEF0dGFjaChmbGFncykge1xuICAgICAgICAgICAgLy8gY2xvc2UgLyBzaHJpbmsgYW4gYXR0YWNoIGJhdGNoXG4gICAgICAgICAgICBpZiAoLS10aGlzLmF0dGFjaERlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFzayAhPT0gbnVsbCAmJiAhdGhpcy50YXNrLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrLm93bmVyID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzQXR0YWNoUXVldWUoZmxhZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBMaWZlY3ljbGVUYXNrLmRvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dGFjaFF1ZXVlKGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBmbHVzaCBhbmQgcGF0Y2ggYmVmb3JlIHN0YXJ0aW5nIHRoZSBhdHRhY2ggbGlmZWN5Y2xlIHRvIGVuc3VyZSBiYXRjaGVkIGNvbGxlY3Rpb24gY2hhbmdlcyBhcmUgcHJvcGFnYXRlZCB0byByZXBlYXRlcnNcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgRE9NIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ZsdXNoUXVldWUoZmxhZ3MgfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21TeW5jRmx1c2gpO1xuICAgICAgICAgICAgLy8gVE9ETzogcHJldmVudCBkdXBsaWNhdGUgdXBkYXRlcyBjb21pbmcgZnJvbSB0aGUgcGF0Y2ggcXVldWUgKG9yIHBlcmhhcHMgaXQncyBqdXN0IG5vdCBuZWVkZWQgaW4gaXRzIGVudGlyZXR5PylcbiAgICAgICAgICAgIC8vdGhpcy5wcm9jZXNzUGF0Y2hRdWV1ZShmbGFncyB8IExpZmVjeWNsZUZsYWdzLmZyb21TeW5jRmx1c2gpO1xuICAgICAgICAgICAgaWYgKHRoaXMubW91bnRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TW91bnQgPSB0aGlzLm1vdW50SGVhZC4kbmV4dE1vdW50O1xuICAgICAgICAgICAgICAgIHRoaXMubW91bnRIZWFkID0gdGhpcy5tb3VudFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0TW91bnQ7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TW91bnQuJG1vdW50KGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE1vdW50ID0gY3VycmVudE1vdW50LiRuZXh0TW91bnQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNb3VudC4kbmV4dE1vdW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1vdW50ID0gbmV4dE1vdW50O1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnRNb3VudCAhPT0gbWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbm5lY3QgYWxsIGNvbm5lY3QtcXVldWVkIGJpbmRpbmdzIEFGVEVSIG1vdW50aW5nIGlzIGRvbmUsIHNvIHRoYXQgdGhlIERPTSBpcyB2aXNpYmxlIGFzYXAsXG4gICAgICAgICAgICAvLyBidXQgY29ubmVjdCBCRUZPUkUgcnVubmluZyB0aGUgYXR0YWNoZWQgY2FsbGJhY2tzIHRvIGVuc3VyZSBhbnkgY2hhbmdlcyBtYWRlIGR1cmluZyB0aG9zZSBjYWxsYmFja3NcbiAgICAgICAgICAgIC8vIGFyZSBzdGlsbCBhY2NvdW50ZWQgZm9yLlxuICAgICAgICAgICAgLy8gVE9ETzogYWRkIGEgZmxhZy9vcHRpb24gdG8gZnVydGhlciBkZWxheSBjb25uZWN0IHdpdGggYSBSQUYgY2FsbGJhY2sgKHRoZSB0cmFkZW9mZiB3b3VsZCBiZSB0aGF0IHdlJ2QgbmVlZFxuICAgICAgICAgICAgLy8gdG8gcnVuIGFuIGFkZGl0aW9uYWwgcGF0Y2ggY3ljbGUgYmVmb3JlIHRoYXQgY29ubmVjdCwgd2hpY2ggY2FuIGJlIGV4cGVuc2l2ZSBhbmQgdW5uZWNlc3NhcnkgaW4gbW9zdCByZWFsXG4gICAgICAgICAgICAvLyB3b3JsZCBzY2VuYXJpb3MsIGJ1dCBjYW4gc2lnbmlmaWNhbnRseSBzcGVlZCB0aGluZ3MgdXAgd2l0aCBuZXN0ZWQsIGhpZ2hseSB2b2xhdGlsZSBkYXRhIGxpa2UgaW4gZGJtb25zdGVyKVxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29ubmVjdFF1ZXVlKGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MubXVzdEV2YWx1YXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dGFjaGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hlZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEF0dGFjaGVkID0gdGhpcy5hdHRhY2hlZEhlYWQuJG5leHRBdHRhY2hlZDtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaGVkSGVhZCA9IHRoaXMuYXR0YWNoZWRUYWlsID0gdGhpcztcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEF0dGFjaGVkO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEF0dGFjaGVkLmF0dGFjaGVkKGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEF0dGFjaGVkID0gY3VycmVudEF0dGFjaGVkLiRuZXh0QXR0YWNoZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRhY2hlZC4kbmV4dEF0dGFjaGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEF0dGFjaGVkID0gbmV4dEF0dGFjaGVkO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnRBdHRhY2hlZCAhPT0gbWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiZWdpbkRldGFjaCgpIHtcbiAgICAgICAgICAgIC8vIG9wZW4gdXAgLyBleHBhbmQgYSBkZXRhY2ggYmF0Y2g7IHRoZSB2ZXJ5IGZpcnN0IGNhbGxlciB3aWxsIGNsb3NlIGl0IGFnYWluIHdpdGggZW5kRGV0YWNoXG4gICAgICAgICAgICArK3RoaXMuZGV0YWNoRGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZVVubW91bnQocmVxdWVzdG9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBpZGVtcG90ZW50OyBhZGRpbmcgdGhlIHNhbWUgaXRlbSBtb3JlIHRoYW4gb25jZSBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gICAgICAgICAgICAvLyBhZGRpbmcgaXQgb25jZS5cbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgc3RhbmRhcmQgc2luZ2x5IGxpbmtlZCBsaXN0IGZvciB1bm1vdW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Rvci4kbmV4dFVubW91bnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0b3IuJG5leHRVbm1vdW50ID0gbWFya2VyO1xuICAgICAgICAgICAgICAgIHRoaXMudW5tb3VudFRhaWwuJG5leHRVbm1vdW50ID0gcmVxdWVzdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMudW5tb3VudFRhaWwgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgKyt0aGlzLnVubW91bnRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlRGV0YWNoZWQocmVxdWVzdG9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBpZGVtcG90ZW50OyBhZGRpbmcgdGhlIHNhbWUgaXRlbSBtb3JlIHRoYW4gb25jZSBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gICAgICAgICAgICAvLyBhZGRpbmcgaXQgb25jZS5cbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgc3RhbmRhcmQgc2luZ2x5IGxpbmtlZCBsaXN0IGZvciBkZXRhY2hlZCBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0b3IuJG5leHREZXRhY2hlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rvci4kbmV4dERldGFjaGVkID0gbWFya2VyO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoZWRUYWlsLiRuZXh0RGV0YWNoZWQgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hlZFRhaWwgPSByZXF1ZXN0b3I7XG4gICAgICAgICAgICAgICAgKyt0aGlzLmRldGFjaGVkQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZVVuYmluZEFmdGVyRGV0YWNoKHJlcXVlc3Rvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgaWRlbXBvdGVudDsgYWRkaW5nIHRoZSBzYW1lIGl0ZW0gbW9yZSB0aGFuIG9uY2UgaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAgICAgICAgICAgLy8gYWRkaW5nIGl0IG9uY2UuXG4gICAgICAgICAgICAvLyBidWlsZCBhIHN0YW5kYXJkIHNpbmdseSBsaW5rZWQgbGlzdCBmb3IgdW5iaW5kQWZ0ZXJEZXRhY2ggY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAocmVxdWVzdG9yLiRuZXh0VW5iaW5kQWZ0ZXJEZXRhY2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0b3IuJG5leHRVbmJpbmRBZnRlckRldGFjaCA9IG1hcmtlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYmluZEFmdGVyRGV0YWNoVGFpbC4kbmV4dFVuYmluZEFmdGVyRGV0YWNoID0gcmVxdWVzdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMudW5iaW5kQWZ0ZXJEZXRhY2hUYWlsID0gcmVxdWVzdG9yO1xuICAgICAgICAgICAgICAgICsrdGhpcy51bmJpbmRBZnRlckRldGFjaENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVuZERldGFjaChmbGFncykge1xuICAgICAgICAgICAgLy8gY2xvc2UgLyBzaHJpbmsgYSBkZXRhY2ggYmF0Y2hcbiAgICAgICAgICAgIGlmICgtLXRoaXMuZGV0YWNoRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YXNrICE9PSBudWxsICYmICF0aGlzLnRhc2suZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhc2sub3duZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NEZXRhY2hRdWV1ZShmbGFncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExpZmVjeWNsZVRhc2suZG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzRGV0YWNoUXVldWUoZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIGZsdXNoIGJlZm9yZSB1bm1vdW50aW5nIHRvIGVuc3VyZSBiYXRjaGVkIGNvbGxlY3Rpb24gY2hhbmdlcyBwcm9wYWdhdGUgdG8gdGhlIHJlcGVhdGVycyxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1heSBsZWFkIHRvIGFkZGl0aW9uYWwgdW5tb3VudCBvcGVyYXRpb25zXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NGbHVzaFF1ZXVlKGZsYWdzIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tRmx1c2ggfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmRvTm90VXBkYXRlRE9NKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnVubW91bnRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVubW91bnRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRVbm1vdW50ID0gdGhpcy51bm1vdW50SGVhZC4kbmV4dFVubW91bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy51bm1vdW50SGVhZCA9IHRoaXMudW5tb3VudFRhaWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VW5tb3VudDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVbm1vdW50LiR1bm1vdW50KGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFVubW91bnQgPSBjdXJyZW50VW5tb3VudC4kbmV4dFVubW91bnQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVbm1vdW50LiRuZXh0VW5tb3VudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVbm1vdW50ID0gbmV4dFVubW91bnQ7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudFVubW91bnQgIT09IG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZXRhY2hlZENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREZXRhY2hlZCA9IHRoaXMuZGV0YWNoZWRIZWFkLiRuZXh0RGV0YWNoZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hlZEhlYWQgPSB0aGlzLmRldGFjaGVkVGFpbCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgbGV0IG5leHREZXRhY2hlZDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXRhY2hlZC5kZXRhY2hlZChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHREZXRhY2hlZCA9IGN1cnJlbnREZXRhY2hlZC4kbmV4dERldGFjaGVkO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGV0YWNoZWQuJG5leHREZXRhY2hlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXRhY2hlZCA9IG5leHREZXRhY2hlZDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50RGV0YWNoZWQgIT09IG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51bmJpbmRBZnRlckRldGFjaENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5VbmJpbmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYmluZEFmdGVyRGV0YWNoQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50VW5iaW5kID0gdGhpcy51bmJpbmRBZnRlckRldGFjaEhlYWQuJG5leHRVbmJpbmRBZnRlckRldGFjaDtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYmluZEFmdGVyRGV0YWNoSGVhZCA9IHRoaXMudW5iaW5kQWZ0ZXJEZXRhY2hUYWlsID0gdGhpcztcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFVuYmluZDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVbmJpbmQuJHVuYmluZChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRVbmJpbmQgPSBjdXJyZW50VW5iaW5kLiRuZXh0VW5iaW5kQWZ0ZXJEZXRhY2g7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVbmJpbmQuJG5leHRVbmJpbmRBZnRlckRldGFjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVbmJpbmQgPSBuZXh0VW5iaW5kO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnRVbmJpbmQgIT09IG1hcmtlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRVbmJpbmQoZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuQ29tcG9zaXRpb25Db29yZGluYXRvciA9IGNsYXNzIENvbXBvc2l0aW9uQ29vcmRpbmF0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigkbGlmZWN5Y2xlKSB7XG4gICAgICAgICAgICB0aGlzLiRsaWZlY3ljbGUgPSAkbGlmZWN5Y2xlO1xuICAgICAgICAgICAgdGhpcy5vblN3YXBDb21wbGV0ZSA9IGtlcm5lbC5QTEFURk9STS5ub29wO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN3YXBUYXNrID0gTGlmZWN5Y2xlVGFzay5kb25lO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXJuZWwuUmVnaXN0cmF0aW9uLnRyYW5zaWVudCh0aGlzLCB0aGlzKS5yZWdpc3Rlcihjb250YWluZXIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvc2UodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zd2FwVGFzay5kb25lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVucXVldWUobmV3IFByb21pc2VTd2FwKHRoaXMsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc05leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcCh2YWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnF1ZXVlKG5ldyBQcm9taXNlU3dhcCh0aGlzLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3dhcFRhc2suY2FuQ2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwVGFzay5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZyhmbGFncywgc2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VmlldyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcuJGJpbmQoZmxhZ3MsIHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VmlldyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcuJGF0dGFjaChmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoaW5nKGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLmlzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlldy4kZGV0YWNoKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bmJpbmRpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3LiR1bmJpbmQoZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhY2hpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVucXVldWUodmlldykge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2godmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dhcCh2aWV3LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFZpZXcgPT09IHZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCAkbGlmZWN5Y2xlID0gdGhpcy4kbGlmZWN5Y2xlO1xuICAgICAgICAgICAgY29uc3Qgc3dhcFRhc2sgPSBuZXcgQWdncmVnYXRlTGlmZWN5Y2xlVGFzaygpO1xuICAgICAgICAgICAgbGV0IGxpZmVjeWNsZVRhc2s7XG4gICAgICAgICAgICBsZXQgY3VycmVudFZpZXcgPSB0aGlzLmN1cnJlbnRWaWV3O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWaWV3ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlVGFzayA9IExpZmVjeWNsZVRhc2suZG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRsaWZlY3ljbGUuZW5xdWV1ZVVuYmluZEFmdGVyRGV0YWNoKGN1cnJlbnRWaWV3KTtcbiAgICAgICAgICAgICAgICAkbGlmZWN5Y2xlLmJlZ2luRGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFZpZXcuJGRldGFjaChmbGFncyk7XG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlVGFzayA9ICRsaWZlY3ljbGUuZW5kRGV0YWNoKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3YXBUYXNrLmFkZFRhc2sobGlmZWN5Y2xlVGFzayk7XG4gICAgICAgICAgICBjdXJyZW50VmlldyA9IHRoaXMuY3VycmVudFZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWaWV3ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlVGFzayA9IExpZmVjeWNsZVRhc2suZG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxpZmVjeWNsZS5iZWdpbkJpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZpZXcuJGJpbmQoZmxhZ3MsIHRoaXMuc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAkbGlmZWN5Y2xlLmVuZEJpbmQoZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICRsaWZlY3ljbGUuYmVnaW5BdHRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZpZXcuJGF0dGFjaChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZVRhc2sgPSAkbGlmZWN5Y2xlLmVuZEF0dGFjaChmbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaWZlY3ljbGVUYXNrID0gTGlmZWN5Y2xlVGFzay5kb25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3YXBUYXNrLmFkZFRhc2sobGlmZWN5Y2xlVGFzayk7XG4gICAgICAgICAgICBpZiAoc3dhcFRhc2suZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dhcFRhc2sgPSBMaWZlY3ljbGVUYXNrLmRvbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN3YXBDb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwVGFzayA9IHN3YXBUYXNrO1xuICAgICAgICAgICAgICAgIHRoaXMuc3dhcFRhc2sud2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3dhcENvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc05leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzTmV4dCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlICE9PSBudWxsICYmIHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoUHJvbWlzZVN3YXAuaXMobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwVGFzayA9IG5leHQuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcChuZXh0LCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21MaWZlY3ljbGVUYXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN3YXBUYXNrID0gTGlmZWN5Y2xlVGFzay5kb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkNvbXBvc2l0aW9uQ29vcmRpbmF0b3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAga2VybmVsLmluamVjdChJTGlmZWN5Y2xlKVxuICAgIF0sIGV4cG9ydHMuQ29tcG9zaXRpb25Db29yZGluYXRvcik7XG4gICAgY29uc3QgTGlmZWN5Y2xlVGFzayA9IHtcbiAgICAgICAgZG9uZToge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIGNhbkNhbmNlbCgpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5XG4gICAgICAgICAgICBjYW5jZWwoKSB7IH0sXG4gICAgICAgICAgICB3YWl0KCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY2xhc3MgQWdncmVnYXRlTGlmZWN5Y2xlVGFzayB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qQGludGVybmFsKi9cbiAgICAgICAgICAgIHRoaXMub3duZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YXNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy53YWl0ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhZGRUYXNrKHRhc2spIHtcbiAgICAgICAgICAgIGlmICghdGFzay5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50YXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgICAgIHRhc2sud2FpdCgpLnRoZW4oKCkgPT4gdGhpcy50cnlDb21wbGV0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUYXNrKHRhc2spIHtcbiAgICAgICAgICAgIGlmICh0YXNrLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLnRhc2tzLmluZGV4T2YodGFzayk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vd25lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm93bmVyLmZpbmlzaFRhc2sodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYW5DYW5jZWwoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFza3MuZXZlcnkoeCA9PiB4LmNhbkNhbmNlbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5DYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFza3MuZm9yRWFjaCh4ID0+IHguY2FuY2VsKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdhaXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53YWl0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FpdGVyID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJvbWlzZS1tdXN0LWNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FpdGVyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHRoaXMucmVzb2x2ZSA9IHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRlcjtcbiAgICAgICAgfVxuICAgICAgICB0cnlDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50YXNrcy5ldmVyeSh4ID0+IHguZG9uZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbXBsZXRlKG5vdENhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChub3RDYW5jZWxsZWQgJiYgdGhpcy5vd25lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3duZXIucHJvY2Vzc0RldGFjaFF1ZXVlKGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUxpZmVjeWNsZVRhc2spO1xuICAgICAgICAgICAgICAgIHRoaXMub3duZXIucHJvY2Vzc1VuYmluZFF1ZXVlKGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUxpZmVjeWNsZVRhc2spO1xuICAgICAgICAgICAgICAgIHRoaXMub3duZXIucHJvY2Vzc0JpbmRRdWV1ZShleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21MaWZlY3ljbGVUYXNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLnByb2Nlc3NBdHRhY2hRdWV1ZShleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21MaWZlY3ljbGVUYXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3duZXIuZmluaXNoVGFzayh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgY2xhc3MgUHJvbWlzZVN3YXAge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb29yZGluYXRvciwgcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRvciA9IGNvb3JkaW5hdG9yO1xuICAgICAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpcyhvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3RhcnQnIGluIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExpZmVjeWNsZVRhc2suZG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS50aGVuKHggPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25SZXNvbHZlKHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjYW5DYW5jZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZG9uZTtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5DYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdhaXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIG9uUmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRvci5jb21wb3NlKHZhbHVlLCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21MaWZlY3ljbGVUYXNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpqc2RvYy1mb3JtYXRcbiAgICAvKipcbiAgICAgKiBBIGdlbmVyYWwtcHVycG9zZSBJTGlmZWN5Y2xlVGFzayBpbXBsZW1lbnRhdGlvbiB0aGF0IGNhbiBiZSBwbGFjZWRcbiAgICAgKiBiZWZvcmUgYW4gYXR0YWNoZWQsIGRldGFjaGVkLCBib3VuZCBvciB1bmJvdW5kIGhvb2sgZHVyaW5nIGF0dGFjaGluZyxcbiAgICAgKiBkZXRhY2hpbmcsIGJpbmRpbmcgb3IgdW5iaW5kaW5nLCByZXNwZWN0aXZlbHkuXG4gICAgICpcbiAgICAgKiBUaGUgcHJvdmlkZWQgcHJvbWlzZSB3aWxsIGJlIGF3YWl0ZWQgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nIGxpZmVjeWNsZVxuICAgICAqIGhvb2sgKGFuZCBhbnkgaG9va3MgZm9sbG93aW5nIGl0KSBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogVGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZFxuICAgICAqIGFuZCBiZWZvcmUgdGhlIG5leHQgbGlmZWN5Y2xlIGhvb2suXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgIGBgYHRzXG4gICAgZXhwb3J0IGNsYXNzIE15Vmlld01vZGVsIHtcbiAgICAgIHByaXZhdGUgJGxpZmVjeWNsZTogSUxpZmVjeWNsZTsgLy8gc2V0IGJlZm9yZSBjcmVhdGVkKCkgaG9va1xuICAgICAgcHJpdmF0ZSBhbnN3ZXI6IG51bWJlcjtcblxuICAgICAgcHVibGljIGJpbmRpbmcoZmxhZ3M6IExpZmVjeWNsZUZsYWdzKTogdm9pZCB7XG4gICAgICAgIC8vIHRoaXMuYW5zd2VyID09PSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy4kbGlmZWN5Y2xlLnJlZ2lzdGVyVGFzayhuZXcgUHJvbWlzZVRhc2soXG4gICAgICAgICAgdGhpcy5nZXRBbnN3ZXJBc3luYyxcbiAgICAgICAgICBhbnN3ZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5hbnN3ZXIgPSBhbnN3ZXI7XG4gICAgICAgICAgfVxuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgcHVibGljIGJvdW5kKGZsYWdzOiBMaWZlY3ljbGVGbGFncyk6IHZvaWQge1xuICAgICAgICAvLyB0aGlzLmFuc3dlciA9PT0gNDJcbiAgICAgIH1cblxuICAgICAgcHJpdmF0ZSBnZXRBbnN3ZXJBc3luYygpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiA0Mik7XG4gICAgICB9XG4gICAgfVxuICAgIGBgYFxuICAgICAqL1xuICAgIC8vIHRzbGludDplbmFibGU6anNkb2MtZm9ybWF0XG4gICAgY2xhc3MgUHJvbWlzZVRhc2sge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9taXNlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYW5DYW5jZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZG9uZTtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5DYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdhaXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZGluZ0JlaGF2aW9yKG5hbWVPclNvdXJjZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpbmRpbmdCZWhhdmlvclJlc291cmNlLmRlZmluZShuYW1lT3JTb3VyY2UsIHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IEJpbmRpbmdCZWhhdmlvclJlc291cmNlID0ge1xuICAgICAgICBuYW1lOiAnYmluZGluZy1iZWhhdmlvcicsXG4gICAgICAgIGtleUZyb20obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX06JHtuYW1lfWA7XG4gICAgICAgIH0sXG4gICAgICAgIGlzVHlwZShUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZS5raW5kID09PSB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmUobmFtZU9yU291cmNlLCBjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBUeXBlID0gY3RvcjtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdHlwZW9mIG5hbWVPclNvdXJjZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHsgbmFtZTogbmFtZU9yU291cmNlIH1cbiAgICAgICAgICAgICAgICA6IG5hbWVPclNvdXJjZTtcbiAgICAgICAgICAgIFR5cGUua2luZCA9IEJpbmRpbmdCZWhhdmlvclJlc291cmNlO1xuICAgICAgICAgICAgVHlwZS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgVHlwZS5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuICAgICAgICAgICAgcmV0dXJuIFR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoa2VybmVsLlJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oQmluZGluZ0JlaGF2aW9yUmVzb3VyY2Uua2V5RnJvbSh0aGlzLmRlc2NyaXB0aW9uLm5hbWUpLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcbiAgICBjb25zdCBBVFRSSUJVVEVfTk9ERSA9IDI7XG4gICAgY29uc3QgVEVYVF9OT0RFID0gMztcbiAgICBjb25zdCBDT01NRU5UX05PREUgPSA4O1xuICAgIGNvbnN0IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbiAgICBmdW5jdGlvbiBpc1JlbmRlckxvY2F0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudGV4dENvbnRlbnQgPT09ICdhdS1lbmQnO1xuICAgIH1cbiAgICBjb25zdCBJTm9kZSA9IGtlcm5lbC5ESS5jcmVhdGVJbnRlcmZhY2UoKS5ub0RlZmF1bHQoKTtcbiAgICBjb25zdCBJUmVuZGVyTG9jYXRpb24gPSBrZXJuZWwuREkuY3JlYXRlSW50ZXJmYWNlKCkubm9EZWZhdWx0KCk7XG4gICAgLy8gdHNsaW50OmRpc2FibGU6bm8tYW55XG4gICAgY29uc3QgRE9NID0ge1xuICAgICAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50KG1hcmt1cE9yTm9kZSkge1xuICAgICAgICAgICAgaWYgKG1hcmt1cE9yTm9kZSA9PT0gdW5kZWZpbmVkIHx8IG1hcmt1cE9yTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFya3VwT3JOb2RlLm5vZGVUeXBlID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrdXBPck5vZGUuY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrdXBPck5vZGUuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobWFya3VwT3JOb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRE9NLmNyZWF0ZVRlbXBsYXRlKG1hcmt1cE9yTm9kZSkuY29udGVudDtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlVGVtcGxhdGUobWFya3VwKSB7XG4gICAgICAgICAgICBpZiAobWFya3VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHN1YnNjcmliZXIsIHB1Ymxpc2hlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgKHB1Ymxpc2hlciB8fCBkb2N1bWVudCkuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9LFxuICAgICAgICBhdHRhY2hTaGFkb3coaG9zdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGhvc3QuYXR0YWNoU2hhZG93KG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZU5vZGUobm9kZSwgZGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKGRlZXAgIT09IGZhbHNlKTsgLy8gdXNlIHRydWUgdW5sZXNzIHRoZSBjYWxsZXIgZXhwbGljaXRseSBwYXNzZXMgaW4gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydFRvUmVuZGVyTG9jYXRpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKGlzUmVuZGVyTG9jYXRpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTsgLy8gaXQncyBhbHJlYWR5IGEgUmVuZGVyTG9jYXRpb24gKGNvbnZlcnRlZCBieSBGcmFnbWVudE5vZGVTZXF1ZW5jZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoNTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb25FbmQgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCdhdS1lbmQnKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uU3RhcnQgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCdhdS1zdGFydCcpO1xuICAgICAgICAgICAgRE9NLnJlcGxhY2VOb2RlKGxvY2F0aW9uRW5kLCBub2RlKTtcbiAgICAgICAgICAgIERPTS5pbnNlcnRCZWZvcmUobG9jYXRpb25TdGFydCwgbG9jYXRpb25FbmQpO1xuICAgICAgICAgICAgbG9jYXRpb25FbmQuJHN0YXJ0ID0gbG9jYXRpb25TdGFydDtcbiAgICAgICAgICAgIGxvY2F0aW9uU3RhcnQuJG5vZGVzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBsb2NhdGlvbkVuZDtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlQ29tbWVudCh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlRWxlbWVudChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlTm9kZU9ic2VydmVyKHRhcmdldCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVUZXh0Tm9kZSh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEJlZm9yZShub2RlVG9JbnNlcnQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0LCByZWZlcmVuY2VOb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNBbGxXaGl0ZXNwYWNlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmF1SW50ZXJwb2xhdGlvblRhcmdldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAvLyBmb3IgcGVyZiBiZW5jaG1hcmsgb2YgdGhpcyBjb21wYXJlZCB0byB0aGUgcmVnZXggbWV0aG9kOiBodHRwOi8vanNiZW4uY2gvcDcwcTIgKGFsc28gYSBnZW5lcmFsIGNhc2UgYWdhaW5zdCB1c2luZyByZWdleClcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hhckNvZGVzIDAtMHgyMCgzMikgY2FuIGFsbCBiZSBjb25zaWRlcmVkIHdoaXRlc3BhY2UgKG5vbi13aGl0ZXNwYWNlIGNoYXJzIGluIHRoaXMgcmFuZ2UgZG9uJ3QgaGF2ZSBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBhbnl3YXkpXG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA+IDB4MjApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNDb21tZW50Tm9kZVR5cGUobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEb2N1bWVudEZyYWdtZW50VHlwZShub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbGVtZW50Tm9kZVR5cGUobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNOb2RlSW5zdGFuY2UocG90ZW50aWFsTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvdGVudGlhbE5vZGUubm9kZVR5cGUgPiAwO1xuICAgICAgICB9LFxuICAgICAgICBpc1RleHROb2RlVHlwZShub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFO1xuICAgICAgICB9LFxuICAgICAgICBtaWdyYXRlQ2hpbGROb2RlcyhjdXJyZW50UGFyZW50LCBuZXdQYXJlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50UGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBET00uYXBwZW5kQ2hpbGQobmV3UGFyZW50LCBjdXJyZW50UGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckVsZW1lbnRSZXNvbHZlcihjb250YWluZXIsIHJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihJTm9kZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIoRWxlbWVudCwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIoSFRNTEVsZW1lbnQsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKFNWR0VsZW1lbnQsIHJlc29sdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZShub2RlLCBuYW1lKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHN1YnNjcmliZXIsIHB1Ymxpc2hlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgKHB1Ymxpc2hlciB8fCBkb2N1bWVudCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICByZXBsYWNlTm9kZShuZXdDaGlsZCwgb2xkQ2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvbGRDaGlsZC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyZWF0QXNOb25XaGl0ZXNwYWNlKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIHNlZSBpc0FsbFdoaXRlc3BhY2UgYWJvdmVcbiAgICAgICAgICAgIG5vZGUuYXVJbnRlcnBvbGF0aW9uVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBJTm9kZVNlcXVlbmNlIHRoYXQgcmVwcmVzZW50cyBcIm5vIERPTVwiIHRvIHJlbmRlci5cbiAgICAvLyBJdCdzIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMgdG8gYXZvaWQgbnVsbCBhbmQgdG8gZW5jb2RlXG4gICAgLy8gdGhlIGV4cGxpY2l0IGlkZWEgb2YgXCJubyB2aWV3XCIuXG4gICAgY29uc3QgZW1wdHlTZXF1ZW5jZSA9IHtcbiAgICAgICAgZmlyc3RDaGlsZDogbnVsbCxcbiAgICAgICAgbGFzdENoaWxkOiBudWxsLFxuICAgICAgICBjaGlsZE5vZGVzOiBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheSxcbiAgICAgICAgZmluZFRhcmdldHMoKSB7IHJldHVybiBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheTsgfSxcbiAgICAgICAgaW5zZXJ0QmVmb3JlKHJlZk5vZGUpIHsgfSxcbiAgICAgICAgYXBwZW5kVG8ocGFyZW50KSB7IH0sXG4gICAgICAgIHJlbW92ZSgpIHsgfVxuICAgIH07XG4gICAgY29uc3QgTm9kZVNlcXVlbmNlID0ge1xuICAgICAgICBlbXB0eTogZW1wdHlTZXF1ZW5jZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gc3BlY2lhbGl6ZWQgSU5vZGVTZXF1ZW5jZSB3aXRoIG9wdGltaXphdGlvbnMgZm9yIHRleHQgKGludGVycG9sYXRpb24pIGJpbmRpbmdzXG4gICAgICogVGhlIGNvbnRyYWN0IG9mIHRoaXMgSU5vZGVTZXF1ZW5jZSBpczpcbiAgICAgKiAtIHRoZSBwcmV2aW91cyBlbGVtZW50IGlzIGFuIGBhdS1tYXJrZXJgIG5vZGVcbiAgICAgKiAtIHRleHQgaXMgdGhlIGFjdHVhbCB0ZXh0IG5vZGVcbiAgICAgKi9cbiAgICBjbGFzcyBUZXh0Tm9kZVNlcXVlbmNlIHtcbiAgICAgICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IFt0ZXh0XTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0cyA9IFtuZXcgQXVNYXJrZXIodGV4dCldO1xuICAgICAgICB9XG4gICAgICAgIGZpbmRUYXJnZXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0cztcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRCZWZvcmUocmVmTm9kZSkge1xuICAgICAgICAgICAgcmVmTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmZpcnN0Q2hpbGQsIHJlZk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZFRvKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlKCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRzbGludDplbmFibGU6bm8tYW55XG4gICAgLy8gVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gZm9ybSBvZiBJTm9kZVNlcXVlbmNlLlxuICAgIC8vIEV2ZXJ5IGN1c3RvbSBlbGVtZW50IG9yIHRlbXBsYXRlIGNvbnRyb2xsZXIgd2hvc2Ugbm9kZSBzZXF1ZW5jZSBpcyBiYXNlZCBvbiBhbiBIVE1MIHRlbXBsYXRlXG4gICAgLy8gaGFzIGFuIGluc3RhbmNlIG9mIHRoaXMgdW5kZXIgdGhlIGhvb2QuIEFueW9uZSB3aG8gd2FudHMgdG8gY3JlYXRlIGEgbm9kZSBzZXF1ZW5jZSBmcm9tXG4gICAgLy8gYSBzdHJpbmcgb2YgbWFya3VwIHdvdWxkIGFsc28gcmVjZWl2ZSBhbiBpbnN0YW5jZSBvZiB0aGlzLlxuICAgIC8vIENvbXBpbGVkVGVtcGxhdGVzIGNyZWF0ZSBpbnN0YW5jZXMgb2YgRnJhZ21lbnROb2RlU2VxdWVuY2UuXG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNsYXNzIEZyYWdtZW50Tm9kZVNlcXVlbmNlIHtcbiAgICAgICAgY29uc3RydWN0b3IoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGVMaXN0ID0gZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbCgnLmF1Jyk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgaWkgPSB0YXJnZXROb2RlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRzID0gdGhpcy50YXJnZXRzID0gQXJyYXkoaWkpO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBpaSkge1xuICAgICAgICAgICAgICAgIC8vIGVhZ2VybHkgY29udmVydCBhbGwgbWFya2VycyB0byBJUmVuZGVyTG9jYXRpb25zIChvdGhlcndpc2UgdGhlIHJlbmRlcmVyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBkbyBpdCBhbnl3YXkpIGFuZCBzdG9yZSB0aGVtIGluIHRoZSB0YXJnZXQgbGlzdCAoc2luY2UgdGhlIGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gY2FuJ3QgYmUgcXVlcmllZClcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXROb2RlTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnQVUtTUFSS0VSJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RlIHRoZSByZW5kZXJlciB3aWxsIHN0aWxsIGNhbGwgdGhpcyBtZXRob2QsIGJ1dCBpdCB3aWxsIGp1c3QgcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBsb2NhdGlvbiBpZiBpdCBzZWVzIGl0J3MgYWxyZWFkeSBhIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHNbaV0gPSBET00uY29udmVydFRvUmVuZGVyTG9jYXRpb24odGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gc3RvcmUgbm9uLW1hcmtlcnMgZm9yIGNvbnNpc3RlbnQgb3JkZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0c1tpXSA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlTGlzdCA9IGZyYWdtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIGlpID0gY2hpbGROb2RlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzID0gQXJyYXkoaWkpO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBpaSkge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNbaV0gPSBjaGlsZE5vZGVMaXN0W2ldO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IGZyYWdtZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZmluZFRhcmdldHMoKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRzO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydEJlZm9yZShyZWZOb2RlKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICByZWZOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZnJhZ21lbnQsIHJlZk5vZGUpO1xuICAgICAgICAgICAgLy8gaW50ZXJuYWxseSB3ZSBjb3VsZCBnZW5lcmFsbHkgYXNzdW1lIHRoYXQgdGhpcyBpcyBhbiBJUmVuZGVyTG9jYXRpb24sXG4gICAgICAgICAgICAvLyBidXQgc2luY2UgdGhpcyBpcyBhbHNvIHB1YmxpYyBBUEkgd2Ugc3RpbGwgbmVlZCB0byBkb3VibGUgY2hlY2tcbiAgICAgICAgICAgIC8vIChvciBob3JyaWJsZSB0aGluZ3MgbWlnaHQgaGFwcGVuKVxuICAgICAgICAgICAgaWYgKGlzUmVuZGVyTG9jYXRpb24ocmVmTm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IHJlZk5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0ID0gcmVmTm9kZS4kc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0LiRub2RlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydC4kbm9kZXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBOb2RlU2VxdWVuY2UgdXNlcyB0aGUgc2FtZSBSZW5kZXJMb2NhdGlvbiwgaXQncyBhbiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBhIHJlcGVhdGVyIChvciBzb21ldGhpbmcgc2ltaWxhcikgYW5kIHdlIHNob3VsZG4ndCByZW1vdmUgYWxsIG5vZGVzIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgLSBlbmQgc2luY2UgdGhhdCB3b3VsZCBhbHdheXMgcmVtb3ZlIGFsbCBpdGVtcyBmcm9tIGEgcmVwZWF0ZXIsIGV2ZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBvbmx5IG9uZSBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIHNldCAkbm9kZXMgdG8gUExBVEZPUk0uZW1wdHlPYmplY3QgdG8gMSkgdGVsbCBvdGhlciBzZXF1ZW5jZXMgdGhhdCBpdCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9jY3VwaWVkIGFuZCAyKSBwcmV2ZW50IHN0YXJ0LiRub2RlcyA9PT0gdGhpcyBmcm9tIGV2ZXIgZXZhbHVhdGluZyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1cmluZyByZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICBzdGFydC4kbm9kZXMgPSBrZXJuZWwuUExBVEZPUk0uZW1wdHlPYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGVuZFRvKHBhcmVudCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZnJhZ21lbnQpO1xuICAgICAgICAgICAgLy8gdGhpcyBjYW4gbmV2ZXIgYmUgYSBSZW5kZXJMb2NhdGlvbiwgYW5kIGlmIGZvciB3aGF0ZXZlciByZWFzb24gd2UgbW92ZWRcbiAgICAgICAgICAgIC8vIGZyb20gYSBSZW5kZXJMb2NhdGlvbiB0byBhIGhvc3QsIG1ha2Ugc3VyZSBcInN0YXJ0XCIgYW5kIFwiZW5kXCIgYXJlIG51bGxcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlKCkge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnQgIT09IG51bGwgJiYgdGhpcy5zdGFydC4kbm9kZXMgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBiZXR3ZWVuIGEgdmFsaWQgXCJzdGFydFwiIGFuZCBcImVuZFwiIChlLmcuIGlmL2Vsc2UsIGNvbnRhaW5lcmxlc3MsIG9yIGFcbiAgICAgICAgICAgICAgICAvLyByZXBlYXRlciB3aXRoIGEgc2luZ2xlIGl0ZW0pIHRoZW4gc2ltcGx5IHJlbW92ZSBldmVyeXRoaW5nIGluLWJldHdlZW4gKGJ1dCBub3RcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tbWVudHMgdGhlbXNlbHZlcyBhcyB0aGV5IGJlbG9uZyB0byB0aGUgcGFyZW50KVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5zdGFydC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBjdXJyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC4kbm9kZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UganVzdCByZW1vdmUgZnJvbSBmaXJzdCB0byBsYXN0IGNoaWxkIGluIHRoZSByZWd1bGFyIHdheVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBhcmVudE5vZGUgIT09IGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjdXJyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBOb2RlU2VxdWVuY2VGYWN0b3J5IHtcbiAgICAgICAgY29uc3RydWN0b3IoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBmcmFnbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgc3dpdGNoIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVOb2RlU2VxdWVuY2UgPSAoKSA9PiBOb2RlU2VxdWVuY2UuZW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdBVS1NQVJLRVInIHx8IHRhcmdldC5ub2RlTmFtZSA9PT0gJyNjb21tZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNoaWxkTm9kZXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFICYmIHRleHQudGV4dENvbnRlbnQgPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZXBDbG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZSA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5UeXBlID0gVGV4dE5vZGVTZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoIGlmIG5vdCByZXR1cm5lZFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVlcENsb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVHlwZSA9IEZyYWdtZW50Tm9kZVNlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjcmVhdGVGb3IobWFya3VwT3JOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IERPTS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KG1hcmt1cE9yTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVTZXF1ZW5jZUZhY3RvcnkoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZU5vZGVTZXF1ZW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5UeXBlKHRoaXMubm9kZS5jbG9uZU5vZGUodGhpcy5kZWVwQ2xvbmUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgY2xhc3MgQXVNYXJrZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihuZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm5leHRTaWJsaW5nID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcGFyZW50Tm9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRTaWJsaW5nLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlKCkgeyB9XG4gICAgfVxuICAgIChwcm90byA9PiB7XG4gICAgICAgIHByb3RvLnByZXZpb3VzU2libGluZyA9IG51bGw7XG4gICAgICAgIHByb3RvLmZpcnN0Q2hpbGQgPSBudWxsO1xuICAgICAgICBwcm90by5sYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgICBwcm90by5jaGlsZE5vZGVzID0ga2VybmVsLlBMQVRGT1JNLmVtcHR5QXJyYXk7XG4gICAgICAgIHByb3RvLm5vZGVOYW1lID0gJ0FVLU1BUktFUic7XG4gICAgICAgIHByb3RvLm5vZGVUeXBlID0gRUxFTUVOVF9OT0RFO1xuICAgIH0pKEF1TWFya2VyLnByb3RvdHlwZSk7XG5cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmVyQ29sbGVjdGlvbihtdXRhdGlvbktpbmQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIHByb3RvLl9zdWJzY3JpYmVyRmxhZ3MgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICBwcm90by5fc3Vic2NyaWJlcjAgPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uX3N1YnNjcmliZXIxID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLl9zdWJzY3JpYmVyMiA9IG51bGw7XG4gICAgICAgICAgICBwcm90by5fc3Vic2NyaWJlcnNSZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLmFkZFN1YnNjcmliZXIgPSBhZGRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgcHJvdG8ucmVtb3ZlU3Vic2NyaWJlciA9IHJlbW92ZVN1YnNjcmliZXI7XG4gICAgICAgICAgICBwcm90by5oYXNTdWJzY3JpYmVyID0gaGFzU3Vic2NyaWJlcjtcbiAgICAgICAgICAgIHByb3RvLmhhc1N1YnNjcmliZXJzID0gaGFzU3Vic2NyaWJlcnM7XG4gICAgICAgICAgICBwcm90by5jYWxsU3Vic2NyaWJlcnMgPSAobXV0YXRpb25LaW5kID09PSBleHBvcnRzLk11dGF0aW9uS2luZC5pbnN0YW5jZSA/IGNhbGxQcm9wZXJ0eVN1YnNjcmliZXJzIDogY2FsbENvbGxlY3Rpb25TdWJzY3JpYmVycyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFN1YnNjcmliZXIoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5oYXNTdWJzY3JpYmVyKHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlckZsYWdzID0gdGhpcy5fc3Vic2NyaWJlckZsYWdzO1xuICAgICAgICBpZiAoIShzdWJzY3JpYmVyRmxhZ3MgJiAxIC8qIFN1YnNjcmliZXIwICovKSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcjAgPSBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlckZsYWdzIHw9IDEgLyogU3Vic2NyaWJlcjAgKi87XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdWJzY3JpYmVyRmxhZ3MgJiAyIC8qIFN1YnNjcmliZXIxICovKSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcjEgPSBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlckZsYWdzIHw9IDIgLyogU3Vic2NyaWJlcjEgKi87XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdWJzY3JpYmVyRmxhZ3MgJiA0IC8qIFN1YnNjcmliZXIyICovKSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcjIgPSBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlckZsYWdzIHw9IDQgLyogU3Vic2NyaWJlcjIgKi87XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdWJzY3JpYmVyRmxhZ3MgJiA4IC8qIFN1YnNjcmliZXJzUmVzdCAqLykpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZXJzUmVzdCA9IFtzdWJzY3JpYmVyXTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZXJGbGFncyB8PSA4IC8qIFN1YnNjcmliZXJzUmVzdCAqLztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzUmVzdC5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlU3Vic2NyaWJlcihzdWJzY3JpYmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJGbGFncyA9IHRoaXMuX3N1YnNjcmliZXJGbGFncztcbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAxIC8qIFN1YnNjcmliZXIwICovKSAmJiB0aGlzLl9zdWJzY3JpYmVyMCA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcjAgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlckZsYWdzICY9IH4xIC8qIFN1YnNjcmliZXIwICovO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAyIC8qIFN1YnNjcmliZXIxICovKSAmJiB0aGlzLl9zdWJzY3JpYmVyMSA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcjEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlckZsYWdzICY9IH4yIC8qIFN1YnNjcmliZXIxICovO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiA0IC8qIFN1YnNjcmliZXIyICovKSAmJiB0aGlzLl9zdWJzY3JpYmVyMiA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcjIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlckZsYWdzICY9IH40IC8qIFN1YnNjcmliZXIyICovO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNjcmliZXJGbGFncyAmIDggLyogU3Vic2NyaWJlcnNSZXN0ICovKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzUmVzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnNbaV0gPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZXJGbGFncyAmPSB+OCAvKiBTdWJzY3JpYmVyc1Jlc3QgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbFByb3BlcnR5U3Vic2NyaWJlcnMobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RlOiBjaGFuZ2UgaGFuZGxlcnMgbWF5IGhhdmUgdGhlIHNpZGUtZWZmZWN0IG9mIGFkZGluZy9yZW1vdmluZyBzdWJzY3JpYmVycyB0byB0aGlzIGNvbGxlY3Rpb24gZHVyaW5nIHRoaXNcbiAgICAgICAgICogY2FsbFN1YnNjcmliZXJzIGludm9jYXRpb24sIHNvIHdlJ3JlIGNhY2hpbmcgdGhlbSBhbGwgYmVmb3JlIGludm9raW5nIGFueS5cbiAgICAgICAgICogU3Vic2NyaWJlcnMgYWRkZWQgZHVyaW5nIHRoaXMgaW52b2NhdGlvbiBhcmUgbm90IGludm9rZWQgKGFuZCB0aGV5IHNob3VsZG4ndCBiZSkuXG4gICAgICAgICAqIFN1YnNjcmliZXJzIHJlbW92ZWQgZHVyaW5nIHRoaXMgaW52b2NhdGlvbiB3aWxsIHN0aWxsIGJlIGludm9rZWQgKGFuZCB0aGV5IGFsc28gc2hvdWxkbid0IGJlLFxuICAgICAgICAgKiBob3dldmVyIHRoaXMgaXMgYWNjb3VudGVkIGZvciB2aWEgJGlzQm91bmQgYW5kIHNpbWlsYXIgZmxhZ3Mgb24gdGhlIHN1YnNjcmliZXIgb2JqZWN0cylcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIwID0gdGhpcy5fc3Vic2NyaWJlcjA7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIxID0gdGhpcy5fc3Vic2NyaWJlcjE7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIyID0gdGhpcy5fc3Vic2NyaWJlcjI7XG4gICAgICAgIGxldCBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNjcmliZXJzUmVzdDtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNjcmliZXIwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyMC5oYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaWJlcjEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIxLmhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJzY3JpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlcjIuaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc3Vic2NyaWJlcnMgJiYgc3Vic2NyaWJlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQ29sbGVjdGlvblN1YnNjcmliZXJzKG9yaWdpbiwgYXJncywgZmxhZ3MpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcjAgPSB0aGlzLl9zdWJzY3JpYmVyMDtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcjEgPSB0aGlzLl9zdWJzY3JpYmVyMTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcjIgPSB0aGlzLl9zdWJzY3JpYmVyMjtcbiAgICAgICAgbGV0IHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNSZXN0O1xuICAgICAgICBpZiAoc3Vic2NyaWJlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaWJlcjAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIwLmhhbmRsZUNoYW5nZShvcmlnaW4sIGFyZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaWJlcjEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIxLmhhbmRsZUNoYW5nZShvcmlnaW4sIGFyZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaWJlcjIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIyLmhhbmRsZUNoYW5nZShvcmlnaW4sIGFyZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBzdWJzY3JpYmVycyAmJiBzdWJzY3JpYmVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuaGFuZGxlQ2hhbmdlKG9yaWdpbiwgYXJncywgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpZmVjeWNsZS5lbnF1ZXVlRmx1c2godGhpcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1N1YnNjcmliZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlckZsYWdzICE9PSAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1N1YnNjcmliZXIoc3Vic2NyaWJlcikge1xuICAgICAgICAvLyBGbGFncyBoZXJlIGlzIGp1c3QgYSBwZXJmIHR3ZWFrXG4gICAgICAgIC8vIENvbXBhcmVkIHRvIG5vdCB1c2luZyBmbGFncywgaXQncyBhIG1vZGVyYXRlIHNwZWVkLXVwIHdoZW4gdGhpcyBjb2xsZWN0aW9uIGRvZXMgbm90IGhhdmUgdGhlIHN1YnNjcmliZXI7XG4gICAgICAgIC8vIGFuZCBtaW5vciBzbG93LWRvd24gd2hlbiBpdCBkb2VzLCBhbmQgdGhlIGZvcm1lciBpcyBtb3JlIGNvbW1vbiB0aGFuIHRoZSBsYXR0ZXIuXG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJGbGFncyA9IHRoaXMuX3N1YnNjcmliZXJGbGFncztcbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAxIC8qIFN1YnNjcmliZXIwICovKSAmJiB0aGlzLl9zdWJzY3JpYmVyMCA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAyIC8qIFN1YnNjcmliZXIxICovKSAmJiB0aGlzLl9zdWJzY3JpYmVyMSA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiA0IC8qIFN1YnNjcmliZXIyICovKSAmJiB0aGlzLl9zdWJzY3JpYmVyMiA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNjcmliZXJGbGFncyAmIDggLyogU3Vic2NyaWJlcnNSZXN0ICovKSB7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGNoZWNrIGxlbmd0aDsgaWYgdGhlIGZsYWcgaXMgc2V0LCB0aGVyZSdzIGFsd2F5cyBhdCBsZWFzdCBvbmVcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNSZXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3Vic2NyaWJlcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyc1tpXSA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXRjaGVkU3Vic2NyaWJlckNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBwcm90by5fYmF0Y2hlZFN1YnNjcmliZXJGbGFncyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgIHByb3RvLl9iYXRjaGVkU3Vic2NyaWJlcjAgPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uX2JhdGNoZWRTdWJzY3JpYmVyMSA9IG51bGw7XG4gICAgICAgICAgICBwcm90by5fYmF0Y2hlZFN1YnNjcmliZXIyID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLl9iYXRjaGVkU3Vic2NyaWJlcnNSZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLmFkZEJhdGNoZWRTdWJzY3JpYmVyID0gYWRkQmF0Y2hlZFN1YnNjcmliZXI7XG4gICAgICAgICAgICBwcm90by5yZW1vdmVCYXRjaGVkU3Vic2NyaWJlciA9IHJlbW92ZUJhdGNoZWRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgcHJvdG8uaGFzQmF0Y2hlZFN1YnNjcmliZXIgPSBoYXNCYXRjaGVkU3Vic2NyaWJlcjtcbiAgICAgICAgICAgIHByb3RvLmhhc0JhdGNoZWRTdWJzY3JpYmVycyA9IGhhc0JhdGNoZWRTdWJzY3JpYmVycztcbiAgICAgICAgICAgIHByb3RvLmNhbGxCYXRjaGVkU3Vic2NyaWJlcnMgPSBjYWxsQmF0Y2hlZENvbGxlY3Rpb25TdWJzY3JpYmVycztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQmF0Y2hlZFN1YnNjcmliZXIoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5oYXNCYXRjaGVkU3Vic2NyaWJlcihzdWJzY3JpYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJGbGFncyA9IHRoaXMuX2JhdGNoZWRTdWJzY3JpYmVyRmxhZ3M7XG4gICAgICAgIGlmICghKHN1YnNjcmliZXJGbGFncyAmIDEgLyogU3Vic2NyaWJlcjAgKi8pKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcjAgPSBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXJGbGFncyB8PSAxIC8qIFN1YnNjcmliZXIwICovO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3Vic2NyaWJlckZsYWdzICYgMiAvKiBTdWJzY3JpYmVyMSAqLykpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhdGNoZWRTdWJzY3JpYmVyMSA9IHN1YnNjcmliZXI7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlckZsYWdzIHw9IDIgLyogU3Vic2NyaWJlcjEgKi87XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdWJzY3JpYmVyRmxhZ3MgJiA0IC8qIFN1YnNjcmliZXIyICovKSkge1xuICAgICAgICAgICAgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXIyID0gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIHRoaXMuX2JhdGNoZWRTdWJzY3JpYmVyRmxhZ3MgfD0gNCAvKiBTdWJzY3JpYmVyMiAqLztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN1YnNjcmliZXJGbGFncyAmIDggLyogU3Vic2NyaWJlcnNSZXN0ICovKSkge1xuICAgICAgICAgICAgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXJzUmVzdCA9IFtzdWJzY3JpYmVyXTtcbiAgICAgICAgICAgIHRoaXMuX2JhdGNoZWRTdWJzY3JpYmVyRmxhZ3MgfD0gOCAvKiBTdWJzY3JpYmVyc1Jlc3QgKi87XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcnNSZXN0LnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVCYXRjaGVkU3Vic2NyaWJlcihzdWJzY3JpYmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJGbGFncyA9IHRoaXMuX2JhdGNoZWRTdWJzY3JpYmVyRmxhZ3M7XG4gICAgICAgIGlmICgoc3Vic2NyaWJlckZsYWdzICYgMSAvKiBTdWJzY3JpYmVyMCAqLykgJiYgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXIwID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcjAgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXJGbGFncyAmPSB+MSAvKiBTdWJzY3JpYmVyMCAqLztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3Vic2NyaWJlckZsYWdzICYgMiAvKiBTdWJzY3JpYmVyMSAqLykgJiYgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXIxID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcjEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXJGbGFncyAmPSB+MiAvKiBTdWJzY3JpYmVyMSAqLztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3Vic2NyaWJlckZsYWdzICYgNCAvKiBTdWJzY3JpYmVyMiAqLykgJiYgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXIyID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcjIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXJGbGFncyAmPSB+NCAvKiBTdWJzY3JpYmVyMiAqLztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJzY3JpYmVyRmxhZ3MgJiA4IC8qIFN1YnNjcmliZXJzUmVzdCAqLykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcnNSZXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3Vic2NyaWJlcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyc1tpXSA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXJGbGFncyAmPSB+OCAvKiBTdWJzY3JpYmVyc1Jlc3QgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbEJhdGNoZWRDb2xsZWN0aW9uU3Vic2NyaWJlcnMoaW5kZXhNYXApIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcjAgPSB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcjA7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIxID0gdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXIxO1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyMiA9IHRoaXMuX2JhdGNoZWRTdWJzY3JpYmVyMjtcbiAgICAgICAgbGV0IHN1YnNjcmliZXJzID0gdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXJzUmVzdDtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNjcmliZXIwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyMC5oYW5kbGVCYXRjaGVkQ2hhbmdlKGluZGV4TWFwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaWJlcjEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIxLmhhbmRsZUJhdGNoZWRDaGFuZ2UoaW5kZXhNYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJzY3JpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlcjIuaGFuZGxlQmF0Y2hlZENoYW5nZShpbmRleE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc3Vic2NyaWJlcnMgJiYgc3Vic2NyaWJlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmhhbmRsZUJhdGNoZWRDaGFuZ2UoaW5kZXhNYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNCYXRjaGVkU3Vic2NyaWJlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlckZsYWdzICE9PSAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc0JhdGNoZWRTdWJzY3JpYmVyKHN1YnNjcmliZXIpIHtcbiAgICAgICAgLy8gRmxhZ3MgaGVyZSBpcyBqdXN0IGEgcGVyZiB0d2Vha1xuICAgICAgICAvLyBDb21wYXJlZCB0byBub3QgdXNpbmcgZmxhZ3MsIGl0J3MgYSBtb2RlcmF0ZSBzcGVlZC11cCB3aGVuIHRoaXMgY29sbGVjdGlvbiBkb2VzIG5vdCBoYXZlIHRoZSBzdWJzY3JpYmVyO1xuICAgICAgICAvLyBhbmQgbWlub3Igc2xvdy1kb3duIHdoZW4gaXQgZG9lcywgYW5kIHRoZSBmb3JtZXIgaXMgbW9yZSBjb21tb24gdGhhbiB0aGUgbGF0dGVyLlxuICAgICAgICBjb25zdCBzdWJzY3JpYmVyRmxhZ3MgPSB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlckZsYWdzO1xuICAgICAgICBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDEgLyogU3Vic2NyaWJlcjAgKi8pICYmIHRoaXMuX2JhdGNoZWRTdWJzY3JpYmVyMCA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAyIC8qIFN1YnNjcmliZXIxICovKSAmJiB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcjEgPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3Vic2NyaWJlckZsYWdzICYgNCAvKiBTdWJzY3JpYmVyMiAqLykgJiYgdGhpcy5fYmF0Y2hlZFN1YnNjcmliZXIyID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaWJlckZsYWdzICYgOCAvKiBTdWJzY3JpYmVyc1Jlc3QgKi8pIHtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gY2hlY2sgbGVuZ3RoOyBpZiB0aGUgZmxhZyBpcyBzZXQsIHRoZXJlJ3MgYWx3YXlzIGF0IGxlYXN0IG9uZVxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLl9iYXRjaGVkU3Vic2NyaWJlcnNSZXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3Vic2NyaWJlcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyc1tpXSA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSA9PT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0VmFsdWUgOiBuZXdWYWx1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgKGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUZsdXNoIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQmluZCkpICYmXG4gICAgICAgICAgICAgICAgISgoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmRvTm90VXBkYXRlRE9NKSAmJiBET00uaXNOb2RlSW5zdGFuY2UodGhpcy5vYmopKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVDb3JlKG5ld1ZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGbGFncyA9IGZsYWdzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpZmVjeWNsZS5lbnF1ZXVlRmx1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaChmbGFncykge1xuICAgICAgICBpZiAoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmRvTm90VXBkYXRlRE9NKSB7XG4gICAgICAgICAgICBpZiAoRE9NLmlzTm9kZUluc3RhbmNlKHRoaXMub2JqKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlLXF1ZXVlIHRoZSBjaGFuZ2Ugc28gaXQgd2lsbCBzdGlsbCBwcm9wYWdhdGUgb24gZmx1c2ggd2hlbiBpdCdzIGF0dGFjaGVkIGFnYWluXG4gICAgICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUuZW5xdWV1ZUZsdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgLy8gd2UncmUgZG9pbmcgdGhpcyBjaGVjayBiZWNhdXNlIGEgdmFsdWUgY291bGQgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGJlZm9yZSBhIGZsdXNoLCBhbmQgdGhlIGZpbmFsIHZhbHVlIGNvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHRoZSB0YXJnZXQgZG9lc24ndCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgaWYgKHRoaXMub2xkVmFsdWUgIT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUNvcmUoY3VycmVudFZhbHVlLCB0aGlzLmN1cnJlbnRGbGFncyB8IGZsYWdzIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy51cGRhdGVUYXJnZXRJbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLm9sZFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLm9iaiA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSAnJztcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFyZ2V0T2JzZXJ2ZXIoZGVmYXVsdFZhbHVlID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlckNvbGxlY3Rpb24oZXhwb3J0cy5NdXRhdGlvbktpbmQuaW5zdGFuY2UpKHRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBwcm90by4kbmV4dEZsdXNoID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLmN1cnJlbnRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIHByb3RvLm9sZFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgcHJvdG8uZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgcHJvdG8ub2JqID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLnByb3BlcnR5S2V5ID0gJyc7XG4gICAgICAgICAgICBwcm90by5zZXRWYWx1ZSA9IHByb3RvLnNldFZhbHVlIHx8IHNldFZhbHVlO1xuICAgICAgICAgICAgcHJvdG8uZmx1c2ggPSBwcm90by5mbHVzaCB8fCBmbHVzaDtcbiAgICAgICAgICAgIHByb3RvLmRpc3Bvc2UgPSBwcm90by5kaXNwb3NlIHx8IGRpc3Bvc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWh0dHAtc3RyaW5nXG4gICAgY29uc3QgeGxpbmtBdHRyaWJ1dGVOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbiAgICBleHBvcnRzLlhMaW5rQXR0cmlidXRlQWNjZXNzb3IgPSBjbGFzcyBYTGlua0F0dHJpYnV0ZUFjY2Vzc29yIHtcbiAgICAgICAgLy8geGxpbmsgbmFtZXNwYWNlZCBhdHRyaWJ1dGVzIHJlcXVpcmUgZ2V0QXR0cmlidXRlTlMvc2V0QXR0cmlidXRlTlNcbiAgICAgICAgLy8gKGV2ZW4gdGhvdWdoIHRoZSBOUyB2ZXJzaW9uIGRvZXNuJ3Qgd29yayBmb3Igb3RoZXIgbmFtZXNwYWNlc1xuICAgICAgICAvLyBpbiBodG1sNSBkb2N1bWVudHMpXG4gICAgICAgIC8vIFVzaW5nIHZlcnkgSFRNTC1zcGVjaWZpYyBjb2RlIGhlcmUgc2luY2UgdGhpcyBpc24ndCBsaWtlbHkgdG8gZ2V0XG4gICAgICAgIC8vIGNhbGxlZCB1bmxlc3Mgb3BlcmF0aW5nIGFnYWluc3QgYSByZWFsIEhUTUwgZWxlbWVudC5cbiAgICAgICAgY29uc3RydWN0b3IobGlmZWN5Y2xlLCBvYmosIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmxpZmVjeWNsZSA9IGxpZmVjeWNsZTtcbiAgICAgICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iai5nZXRBdHRyaWJ1dGVOUyh4bGlua0F0dHJpYnV0ZU5TLCB0aGlzLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQ29yZShuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vYmouc2V0QXR0cmlidXRlTlMoeGxpbmtBdHRyaWJ1dGVOUywgdGhpcy5hdHRyaWJ1dGVOYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuWExpbmtBdHRyaWJ1dGVBY2Nlc3NvciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0YXJnZXRPYnNlcnZlcignJylcbiAgICBdLCBleHBvcnRzLlhMaW5rQXR0cmlidXRlQWNjZXNzb3IpO1xuICAgIGV4cG9ydHMuWExpbmtBdHRyaWJ1dGVBY2Nlc3Nvci5wcm90b3R5cGUuYXR0cmlidXRlTmFtZSA9ICcnO1xuICAgIGV4cG9ydHMuRGF0YUF0dHJpYnV0ZUFjY2Vzc29yID0gY2xhc3MgRGF0YUF0dHJpYnV0ZUFjY2Vzc29yIHtcbiAgICAgICAgY29uc3RydWN0b3IobGlmZWN5Y2xlLCBvYmosIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICB0aGlzLmxpZmVjeWNsZSA9IGxpZmVjeWNsZTtcbiAgICAgICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIERPTS5nZXRBdHRyaWJ1dGUodGhpcy5vYmosIHRoaXMucHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQ29yZShuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgRE9NLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLm9iaiwgdGhpcy5wcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBET00uc2V0QXR0cmlidXRlKHRoaXMub2JqLCB0aGlzLnByb3BlcnR5S2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuRGF0YUF0dHJpYnV0ZUFjY2Vzc29yID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRhcmdldE9ic2VydmVyKClcbiAgICBdLCBleHBvcnRzLkRhdGFBdHRyaWJ1dGVBY2Nlc3Nvcik7XG4gICAgZXhwb3J0cy5TdHlsZUF0dHJpYnV0ZUFjY2Vzc29yID0gY2xhc3MgU3R5bGVBdHRyaWJ1dGVBY2Nlc3NvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxpZmVjeWNsZSwgb2JqKSB7XG4gICAgICAgICAgICB0aGlzLmxpZmVjeWNsZSA9IGxpZmVjeWNsZTtcbiAgICAgICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlID0gb2JqLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmouc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZnVuY3Rpb24tbmFtZVxuICAgICAgICBfc2V0UHJvcGVydHkoc3R5bGUsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSAnJztcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZS5pbmRleE9mID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLmluZGV4T2YoJyFpbXBvcnRhbnQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9ICdpbXBvcnRhbnQnO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnIWltcG9ydGFudCcsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JqLnN0eWxlLnNldFByb3BlcnR5KHN0eWxlLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQ29yZShuZXdWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5zdHlsZXMgfHwge307XG4gICAgICAgICAgICBsZXQgc3R5bGU7XG4gICAgICAgICAgICBsZXQgdmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoc3R5bGUgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlW3N0eWxlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlLnJlcGxhY2UoLyhbQS1aXSkvZywgbSA9PiBgLSR7bS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ4ID0gL1xccyooW1xcd1xcLV0rKVxccyo6XFxzKigoPzooPzpbXFx3XFwtXStcXChcXHMqKD86XCIoPzpcXFxcXCJ8W15cIl0pKlwifCcoPzpcXFxcJ3xbXiddKSonfFtcXHdcXC1dK1xcKFxccyooPzpeXCIoPzpcXFxcXCJ8W15cIl0pKlwifCcoPzpcXFxcJ3xbXiddKSonfFteXFwpXSopXFwpLD98W15cXCldKilcXCksP3xcIig/OlxcXFxcInxbXlwiXSkqXCJ8Jyg/OlxcXFwnfFteJ10pKid8W147XSopLD9cXHMqKSspOz8vZztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhaXI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgocGFpciA9IHJ4LmV4ZWMobmV3VmFsdWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBwYWlyWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShzdHlsZSwgcGFpclsyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbiArPSAxO1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZXJzaW9uIC09IDE7XG4gICAgICAgICAgICBmb3IgKHN0eWxlIGluIHN0eWxlcykge1xuICAgICAgICAgICAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSB8fCBzdHlsZXNbc3R5bGVdICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9iai5zdHlsZS5yZW1vdmVQcm9wZXJ0eShzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuU3R5bGVBdHRyaWJ1dGVBY2Nlc3NvciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0YXJnZXRPYnNlcnZlcigpXG4gICAgXSwgZXhwb3J0cy5TdHlsZUF0dHJpYnV0ZUFjY2Vzc29yKTtcbiAgICBleHBvcnRzLlN0eWxlQXR0cmlidXRlQWNjZXNzb3IucHJvdG90eXBlLnN0eWxlcyA9IG51bGw7XG4gICAgZXhwb3J0cy5TdHlsZUF0dHJpYnV0ZUFjY2Vzc29yLnByb3RvdHlwZS52ZXJzaW9uID0gMDtcbiAgICBleHBvcnRzLlN0eWxlQXR0cmlidXRlQWNjZXNzb3IucHJvdG90eXBlLnByb3BlcnR5S2V5ID0gJ3N0eWxlJztcbiAgICBleHBvcnRzLkNsYXNzQXR0cmlidXRlQWNjZXNzb3IgPSBjbGFzcyBDbGFzc0F0dHJpYnV0ZUFjY2Vzc29yIHtcbiAgICAgICAgY29uc3RydWN0b3IobGlmZWN5Y2xlLCBvYmopIHtcbiAgICAgICAgICAgIHRoaXMubGlmZWN5Y2xlID0gbGlmZWN5Y2xlO1xuICAgICAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVDb3JlKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lSW5kZXggPSB0aGlzLm5hbWVJbmRleCB8fCB7fTtcbiAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgICAgICAgICAgbGV0IG5hbWVzO1xuICAgICAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGNsYXNzZXMsIHRyYWNraW5nIHRoZSB2ZXJzaW9uIGF0IHdoaWNoIHRoZXkgd2VyZSBhZGRlZC5cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5vYmo7XG4gICAgICAgICAgICAgICAgbmFtZXMgPSBuZXdWYWx1ZS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5hbWVJbmRleFtuYW1lXSA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIERPTS5hZGRDbGFzcyhub2RlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGUgdmFyaWFibGVzLlxuICAgICAgICAgICAgdGhpcy5uYW1lSW5kZXggPSBuYW1lSW5kZXg7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gKz0gMTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNhbGwgdG8gc2V0VmFsdWU/ICBXZSdyZSBkb25lLlxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgY2xhc3NlcyBmcm9tIHByZXZpb3VzIHZlcnNpb24uXG4gICAgICAgICAgICB2ZXJzaW9uIC09IDE7XG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gbmFtZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lSW5kZXguaGFzT3duUHJvcGVydHkobmFtZSkgfHwgbmFtZUluZGV4W25hbWVdICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGhhcyB0aGUgc2lkZS1lZmZlY3QgdGhhdCBjbGFzc2VzIGFscmVhZHkgcHJlc2VudCB3aGljaCBhcmUgYWRkZWQgYWdhaW4sXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZW1vdmVkIGlmIHRoZXkncmUgbm90IHByZXNlbnQgaW4gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgICAgICAgICAgIC8vIEJldHRlciB3b3VsZCBiZSBkbyBoYXZlIHNvbWUgY29uZmlndXJhYmlsaXR5IGZvciB0aGlzIGJlaGF2aW9yLCBhbGxvd2luZyB0aGUgdXNlciB0b1xuICAgICAgICAgICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGluaXRpYWwgY2xhc3NlcyBhbHdheXMgbmVlZCB0byBiZSBrZXB0LCBhbHdheXMgcmVtb3ZlZCwgb3Igc29tZXRoaW5nIGluIGJldHdlZW5cbiAgICAgICAgICAgICAgICBET00ucmVtb3ZlQ2xhc3ModGhpcy5vYmosIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkNsYXNzQXR0cmlidXRlQWNjZXNzb3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIoJycpXG4gICAgXSwgZXhwb3J0cy5DbGFzc0F0dHJpYnV0ZUFjY2Vzc29yKTtcbiAgICBleHBvcnRzLkNsYXNzQXR0cmlidXRlQWNjZXNzb3IucHJvdG90eXBlLmRvTm90Q2FjaGUgPSB0cnVlO1xuICAgIGV4cG9ydHMuQ2xhc3NBdHRyaWJ1dGVBY2Nlc3Nvci5wcm90b3R5cGUudmVyc2lvbiA9IDA7XG4gICAgZXhwb3J0cy5DbGFzc0F0dHJpYnV0ZUFjY2Vzc29yLnByb3RvdHlwZS5uYW1lSW5kZXggPSBudWxsO1xuICAgIGV4cG9ydHMuRWxlbWVudFByb3BlcnR5QWNjZXNzb3IgPSBjbGFzcyBFbGVtZW50UHJvcGVydHlBY2Nlc3NvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxpZmVjeWNsZSwgb2JqLCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUNvcmUodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuRWxlbWVudFByb3BlcnR5QWNjZXNzb3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIoJycpXG4gICAgXSwgZXhwb3J0cy5FbGVtZW50UHJvcGVydHlBY2Nlc3Nvcik7XG4gICAgY2xhc3MgUHJvcGVydHlBY2Nlc3NvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9iaiwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0cy5BdHRyQmluZGluZ0JlaGF2aW9yID0gY2xhc3MgQXR0ckJpbmRpbmdCZWhhdmlvciB7XG4gICAgICAgIGJpbmQoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5nLnRhcmdldE9ic2VydmVyID0gbmV3IGV4cG9ydHMuRGF0YUF0dHJpYnV0ZUFjY2Vzc29yKGJpbmRpbmcubG9jYXRvci5nZXQoSUxpZmVjeWNsZSksIGJpbmRpbmcudGFyZ2V0LCBiaW5kaW5nLnRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcbiAgICAgICAgdW5iaW5kKGZsYWdzLCBzY29wZSwgYmluZGluZykgeyB9XG4gICAgfTtcbiAgICBleHBvcnRzLkF0dHJCaW5kaW5nQmVoYXZpb3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgYmluZGluZ0JlaGF2aW9yKCdhdHRyJylcbiAgICBdLCBleHBvcnRzLkF0dHJCaW5kaW5nQmVoYXZpb3IpO1xuXG4gICAgLypcbiAgICAqIE5vdGU6IHRoZSBvbmVUaW1lIGJpbmRpbmcgbm93IGhhcyBhIG5vbi16ZXJvIHZhbHVlIGZvciAyIHJlYXNvbnM6XG4gICAgKiAgLSBwbGF5cyBuaWNlciB3aXRoIGJpdHdpc2Ugb3BlcmF0aW9ucyAobW9yZSBjb25zaXN0ZW50IGNvZGUsIG1vcmUgZXhwbGljaXQgc2V0dGluZ3MpXG4gICAgKiAgLSBhbGxvd3MgZm9yIHBvdGVudGlhbGx5IGhhdmluZyBzb21ldGhpbmcgbGlrZSBCaW5kaW5nTW9kZS5vbmVUaW1lIHwgQmluZGluZ01vZGUuZnJvbVZpZXcsIHdoZXJlIGFuIGluaXRpYWwgdmFsdWUgaXMgc2V0IG9uY2UgdG8gdGhlIHZpZXcgYnV0IHVwZGF0ZXMgZnJvbSB0aGUgdmlldyBhbHNvIHByb3BhZ2F0ZSBiYWNrIHRvIHRoZSB2aWV3IG1vZGVsXG4gICAgKlxuICAgICogRnVydGhlcm1vcmUsIHRoZSBcImRlZmF1bHRcIiBtb2RlIHdvdWxkIGJlIGZvciBzaW1wbGUgXCIuYmluZFwiIGV4cHJlc3Npb25zIHRvIG1ha2UgaXQgZXhwbGljaXQgZm9yIG91ciBsb2dpYyB0aGF0IHRoZSBkZWZhdWx0IGlzIGJlaW5nIHVzZWQuXG4gICAgKiBUaGlzIGVzc2VudGlhbGx5IGFkZHMgZXh0cmEgaW5mb3JtYXRpb24gd2hpY2ggYmluZGluZyBjb3VsZCB1c2UgdG8gZG8gc21hcnRlciB0aGluZ3MgYW5kIGFsbG93cyBiaW5kaW5nQmVoYXZpb3JzIHRoYXQgYWRkIGEgbW9kZSBpbnN0ZWFkIG9mIHNpbXBseSBvdmVyd3JpdGluZyBpdFxuICAgICovXG4gICAgKGZ1bmN0aW9uIChCaW5kaW5nTW9kZSkge1xuICAgICAgICBCaW5kaW5nTW9kZVtCaW5kaW5nTW9kZVtcIm9uZVRpbWVcIl0gPSAxXSA9IFwib25lVGltZVwiO1xuICAgICAgICBCaW5kaW5nTW9kZVtCaW5kaW5nTW9kZVtcInRvVmlld1wiXSA9IDJdID0gXCJ0b1ZpZXdcIjtcbiAgICAgICAgQmluZGluZ01vZGVbQmluZGluZ01vZGVbXCJmcm9tVmlld1wiXSA9IDRdID0gXCJmcm9tVmlld1wiO1xuICAgICAgICBCaW5kaW5nTW9kZVtCaW5kaW5nTW9kZVtcInR3b1dheVwiXSA9IDZdID0gXCJ0d29XYXlcIjtcbiAgICAgICAgQmluZGluZ01vZGVbQmluZGluZ01vZGVbXCJkZWZhdWx0XCJdID0gOF0gPSBcImRlZmF1bHRcIjtcbiAgICB9KShleHBvcnRzLkJpbmRpbmdNb2RlIHx8IChleHBvcnRzLkJpbmRpbmdNb2RlID0ge30pKTtcblxuICAgIGNvbnN0IHsgb25lVGltZSwgdG9WaWV3LCBmcm9tVmlldywgdHdvV2F5IH0gPSBleHBvcnRzLkJpbmRpbmdNb2RlO1xuICAgIGNsYXNzIEJpbmRpbmdNb2RlQmVoYXZpb3Ige1xuICAgICAgICBjb25zdHJ1Y3Rvcihtb2RlKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB9XG4gICAgICAgIGJpbmQoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5nLm9yaWdpbmFsTW9kZSA9IGJpbmRpbmcubW9kZTtcbiAgICAgICAgICAgIGJpbmRpbmcubW9kZSA9IHRoaXMubW9kZTtcbiAgICAgICAgfVxuICAgICAgICB1bmJpbmQoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5nLm1vZGUgPSBiaW5kaW5nLm9yaWdpbmFsTW9kZTtcbiAgICAgICAgICAgIGJpbmRpbmcub3JpZ2luYWxNb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBvcnRzLk9uZVRpbWVCaW5kaW5nQmVoYXZpb3IgPSBjbGFzcyBPbmVUaW1lQmluZGluZ0JlaGF2aW9yIGV4dGVuZHMgQmluZGluZ01vZGVCZWhhdmlvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIob25lVGltZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuT25lVGltZUJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBiaW5kaW5nQmVoYXZpb3IoJ29uZVRpbWUnKVxuICAgIF0sIGV4cG9ydHMuT25lVGltZUJpbmRpbmdCZWhhdmlvcik7XG4gICAgZXhwb3J0cy5Ub1ZpZXdCaW5kaW5nQmVoYXZpb3IgPSBjbGFzcyBUb1ZpZXdCaW5kaW5nQmVoYXZpb3IgZXh0ZW5kcyBCaW5kaW5nTW9kZUJlaGF2aW9yIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcih0b1ZpZXcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLlRvVmlld0JpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBiaW5kaW5nQmVoYXZpb3IoJ3RvVmlldycpXG4gICAgXSwgZXhwb3J0cy5Ub1ZpZXdCaW5kaW5nQmVoYXZpb3IpO1xuICAgIGV4cG9ydHMuRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3IgPSBjbGFzcyBGcm9tVmlld0JpbmRpbmdCZWhhdmlvciBleHRlbmRzIEJpbmRpbmdNb2RlQmVoYXZpb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKGZyb21WaWV3KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5Gcm9tVmlld0JpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBiaW5kaW5nQmVoYXZpb3IoJ2Zyb21WaWV3JylcbiAgICBdLCBleHBvcnRzLkZyb21WaWV3QmluZGluZ0JlaGF2aW9yKTtcbiAgICBleHBvcnRzLlR3b1dheUJpbmRpbmdCZWhhdmlvciA9IGNsYXNzIFR3b1dheUJpbmRpbmdCZWhhdmlvciBleHRlbmRzIEJpbmRpbmdNb2RlQmVoYXZpb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKHR3b1dheSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuVHdvV2F5QmluZGluZ0JlaGF2aW9yID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGJpbmRpbmdCZWhhdmlvcigndHdvV2F5JylcbiAgICBdLCBleHBvcnRzLlR3b1dheUJpbmRpbmdCZWhhdmlvcik7XG5cbiAgICBjb25zdCBkZWZpbmVQcm9wZXJ0eSA9IFJlZmxlY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgLy8gbm90ZTogd2UncmUgcmV1c2luZyB0aGUgc2FtZSBvYmplY3QgZm9yIHNldHRpbmcgYWxsIGRlc2NyaXB0b3JzLCBqdXN0IGNoYW5naW5nIHNvbWUgcHJvcGVydGllcyBhcyBuZWVkZWRcbiAgICAvLyAgIHRoaXMgd29ya3MsIGJlY2F1c2UgdGhlIHByb3BlcnRpZXMgYXJlIGNvcGllZCBieSBkZWZpbmVQcm9wZXJ0eSAoc28gY2hhbmdpbmcgdGhlbSBhZnRlcndhcmRzIGRvZXNuJ3QgYWZmZWN0IGV4aXN0aW5nIGRlc2NyaXB0b3JzKVxuICAgIC8vIHNlZSBhbHNvOiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5ZGVzY3JpcHRvclxuICAgIGNvbnN0IG9ic2VydmVkUHJvcGVydHlEZXNjcmlwdG9yID0ge1xuICAgICAgICBnZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgc2V0OiB1bmRlZmluZWQsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgeyBvYmosIHByb3BlcnR5S2V5IH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBvYmpbcHJvcGVydHlLZXldO1xuICAgICAgICAgICAgb2JzZXJ2ZWRQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ID0gKCkgPT4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgb2JzZXJ2ZWRQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0ID0gdmFsdWUgPT4geyB0aGlzLnNldFZhbHVlKHZhbHVlLCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnVwZGF0ZVRhcmdldEluc3RhbmNlKTsgfTtcbiAgICAgICAgICAgIGlmICghZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eUtleSwgb2JzZXJ2ZWRQcm9wZXJ0eURlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAga2VybmVsLlJlcG9ydGVyLndyaXRlKDEsIHByb3BlcnR5S2V5LCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZSQxKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV07XG4gICAgICAgIHRoaXMub2JqID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGVydHlPYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJDb2xsZWN0aW9uKGV4cG9ydHMuTXV0YXRpb25LaW5kLmluc3RhbmNlKSh0YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgcHJvdG8ub2JzZXJ2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBwcm90by5vYmogPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8ucHJvcGVydHlLZXkgPSBudWxsO1xuICAgICAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsIGdlbmVyYXRlIHNvbWUgXCJmYWxzZSBwb3NpdGl2ZVwiIGNoYW5nZXMgd2hlbiBzZXR0aW5nIGEgdGFyZ2V0IHVuZGVmaW5lZCBmcm9tIGEgc291cmNlIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGJ1dCB0aG9zZSBhcmVuJ3QgaGFybWZ1bCBiZWNhdXNlIHRoZSBjaGFuZ2VzIHdvbid0IGJlIHByb3BhZ2F0ZWQgdGhyb3VnaCB0byBzdWJzY3JpYmVycyBkdXJpbmcgJGJpbmQgYW55d2F5LlxuICAgICAgICAgICAgLy8gSXQgd2lsbCwgaG93ZXZlciwgc29sdmUgc29tZSBcImZhbHNlIG5lZ2F0aXZlXCIgY2hhbmdlcyB3aGVuIHRoZSBzb3VyY2UgdmFsdWUgaXMgdW5kZWZpbmVkIGJ1dCB0aGUgdGFyZ2V0IHZhbHVlIGlzIG5vdDtcbiAgICAgICAgICAgIC8vIGluIHN1Y2ggY2FzZXMsIHRoaXMuY3VycmVudFZhbHVlIGluIHRoZSBvYnNlcnZlciBiZWluZyB1bmRlZmluZWQgd2lsbCBibG9jayB0aGUgY2hhbmdlIGZyb20gcHJvcGFnYXRpbmcgdG8gdGhlIHRhcmdldC5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IG5vdCB3b3JraW5nIGNvcnJlY3RseSBpbiB2Q3VycmVudCBlaXRoZXIuXG4gICAgICAgICAgICBwcm90by5jdXJyZW50VmFsdWUgPSBTeW1ib2woKTtcbiAgICAgICAgICAgIHByb3RvLnN1YnNjcmliZSA9IHByb3RvLnN1YnNjcmliZSB8fCBzdWJzY3JpYmU7XG4gICAgICAgICAgICBwcm90by51bnN1YnNjcmliZSA9IHByb3RvLnVuc3Vic2NyaWJlIHx8IHByb3RvLnJlbW92ZVN1YnNjcmliZXI7XG4gICAgICAgICAgICBwcm90by5kaXNwb3NlID0gcHJvdG8uZGlzcG9zZSB8fCBkaXNwb3NlJDE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgbm9vcCA9IGtlcm5lbC5QTEFURk9STS5ub29wO1xuICAgIC8vIG5vdGU6IHN0cmluZy5sZW5ndGggaXMgdGhlIG9ubHkgcHJvcGVydHkgb2YgYW55IHByaW1pdGl2ZSB0aGF0IGlzIG5vdCBhIGZ1bmN0aW9uLFxuICAgIC8vIHNvIHdlIGNhbiBoYXJkd2lyZSBpdCB0byB0aGF0IGFuZCBzaW1wbHkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgYW55dGhpbmcgZWxzZVxuICAgIC8vIG5vdGUjMjogYSBtb2RpZmllZCBwcmltaXRpdmUgY29uc3RydWN0b3IgcHJvdG90eXBlIHdvdWxkIG5vdCB3b3JrIChhbmQgcmVhbGx5LCBpdCBzaG91bGRuJ3QuLilcbiAgICBjbGFzcyBQcmltaXRpdmVPYnNlcnZlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9iaiwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuZG9Ob3RDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHN0b3JlIHByb3BlcnR5TmFtZSBiZWNhdXNlIG9ubHkgJ2xlbmd0aCcgY2FuIHJldHVybiBhIHVzZWZ1bCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5S2V5ID09PSAnbGVuZ3RoJykge1xuICAgICAgICAgICAgICAgIC8vIGRlbGliZXJhdGVseSBub3QgY2hlY2tpbmcgZm9yIHR5cGVvZiBzdHJpbmcgYXMgdXNlcnMgcHJvYmFibHkgc3RpbGwgd2FudCB0byBrbm93IHZpYSBhbiBlcnJvciB0aGF0IHRoZWlyIHN0cmluZyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5nZXRTdHJpbmdMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5yZXR1cm5VbmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3RyaW5nTGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5VbmRlZmluZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaW1pdGl2ZU9ic2VydmVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IG5vb3A7XG4gICAgUHJpbWl0aXZlT2JzZXJ2ZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IG5vb3A7XG4gICAgUHJpbWl0aXZlT2JzZXJ2ZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gbm9vcDtcbiAgICBQcmltaXRpdmVPYnNlcnZlci5wcm90b3R5cGUuZGlzcG9zZSA9IG5vb3A7XG4gICAgZXhwb3J0cy5TZXR0ZXJPYnNlcnZlciA9IGNsYXNzIFNldHRlck9ic2VydmVyIHtcbiAgICAgICAgY29uc3RydWN0b3Iob2JqLCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIShmbGFncyAmIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUJpbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN1YnNjcmliZXJzKG5ld1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgc3Vic2NyaWJlKCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdGFyZ2V0IHByb3BlcnR5IGRlc2NyaXB0b3IgaXMgcmVwbGFjZWQgYnkgdGhlc2UgZ2V0dGVyL3NldHRlciBtZXRob2RzLFxuICAgICAgICAgICAgICAgIC8vIHNvIGNhbGxpbmcgb2JqW3Byb3BlcnR5S2V5XSB3aWxsIGFjdHVhbGx5IHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBpZiBzdWJzY3JpYmUoKSB3YXMgbm90IHlldCBjYWxsZWQgKGluZGljYXRlZCBieSAhdGhpcy5vYnNlcnZpbmcpLCB0aGUgdGFyZ2V0IGRlc2NyaXB0b3JcbiAgICAgICAgICAgICAgICAvLyBpcyB1bm1vZGlmaWVkIGFuZCB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgc2V0IHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgaGFwcGVuIGluIG9uZS10aW1lLCB0by12aWV3IGFuZCB0d28td2F5IGJpbmRpbmdzIGR1cmluZyAkYmluZCwgbWVhbmluZyB0aGF0IHRoZSAkYmluZCB3aWxsIG5vdCBhY3R1YWxseSB1cGRhdGUgdGhlIHRhcmdldCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdhc24ndCB2aXNpYmxlIGluIHZDdXJyZW50IGR1ZSB0byBjb25uZWN0LXF1ZXVlIGFsd2F5cyBkb2luZyBhIGRlbGF5ZWQgdXBkYXRlLCBzbyBpbiBtYW55IGNhc2VzIGl0IGRpZG4ndCBtYXR0ZXIgd2hldGhlciAkYmluZCB1cGRhdGVkIHRoZSB0YXJnZXQgb3Igbm90LlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vYnNlcnZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuU2V0dGVyT2JzZXJ2ZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHlPYnNlcnZlcigpXG4gICAgXSwgZXhwb3J0cy5TZXR0ZXJPYnNlcnZlcik7XG4gICAgZXhwb3J0cy5PYnNlcnZlciA9IGNsYXNzIE9ic2VydmVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5zdGFuY2UsIHByb3BlcnR5TmFtZSwgY2FsbGJhY2tOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm9iaiA9IGluc3RhbmNlO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gaW5zdGFuY2VbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja05hbWUgaW4gaW5zdGFuY2VcbiAgICAgICAgICAgICAgICA/IGluc3RhbmNlW2NhbGxiYWNrTmFtZV0uYmluZChpbnN0YW5jZSlcbiAgICAgICAgICAgICAgICA6IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIShmbGFncyAmIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUJpbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IHRoaXMuY2FsbGJhY2sobmV3VmFsdWUsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2VyY2VkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZSA9IGNvZXJjZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdWJzY3JpYmVycyhuZXdWYWx1ZSwgY3VycmVudFZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLk9ic2VydmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5T2JzZXJ2ZXIoKVxuICAgIF0sIGV4cG9ydHMuT2JzZXJ2ZXIpO1xuXG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNsYXNzIEludGVybmFsT2JzZXJ2ZXJzTG9va3VwIHtcbiAgICAgICAgZ2V0T3JDcmVhdGUob2JqLCBrZXkpIHtcbiAgICAgICAgICAgIGxldCBvYnNlcnZlciA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIgPSB0aGlzW2tleV0gPSBuZXcgZXhwb3J0cy5TZXR0ZXJPYnNlcnZlcihvYmosIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgQmluZGluZ0NvbnRleHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihrZXlPck9iaiwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJHN5bnRoZXRpYyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoa2V5T3JPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIGRlZmluZWQgdGhlbiBpdCdzIGp1c3QgYSBwcm9wZXJ0eSBhbmQgYSB2YWx1ZSB0byBpbml0aWFsaXplIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleU9yT2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGVpdGhlciBiZSBzb21lIHJhbmRvbSBvYmplY3Qgb3IgYW5vdGhlciBiaW5kaW5nQ29udGV4dCB0byBjbG9uZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBrZXlPck9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleU9yT2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wXSA9IGtleU9yT2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjcmVhdGUoa2V5T3JPYmosIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdDb250ZXh0KGtleU9yT2JqLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlc2VydmVkLWtleXdvcmRzXG4gICAgICAgIHN0YXRpYyBnZXQoc2NvcGUsIG5hbWUsIGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyNTAgLyogVW5kZWZpbmVkU2NvcGUgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDI1MSAvKiBOdWxsU2NvcGUgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG92ZXJyaWRlQ29udGV4dCA9IHNjb3BlLm92ZXJyaWRlQ29udGV4dDtcbiAgICAgICAgICAgIGlmIChhbmNlc3RvciA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBqdW1wIHVwIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgYW5jZXN0b3IgY29udGV4dHMgKGVnICRwYXJlbnQuJHBhcmVudCByZXF1aXJlcyB0d28ganVtcHMpXG4gICAgICAgICAgICAgICAgd2hpbGUgKGFuY2VzdG9yID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVDb250ZXh0LnBhcmVudE92ZXJyaWRlQ29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbmNlc3Rvci0tO1xuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZUNvbnRleHQgPSBvdmVycmlkZUNvbnRleHQucGFyZW50T3ZlcnJpZGVDb250ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSBpbiBvdmVycmlkZUNvbnRleHQgPyBvdmVycmlkZUNvbnRleHQgOiBvdmVycmlkZUNvbnRleHQuYmluZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmF2ZXJzZSB0aGUgY29udGV4dCBhbmQgaXQncyBhbmNlc3RvcnMsIHNlYXJjaGluZyBmb3IgYSBjb250ZXh0IHRoYXQgaGFzIHRoZSBuYW1lLlxuICAgICAgICAgICAgd2hpbGUgKG92ZXJyaWRlQ29udGV4dCAmJiAhKG5hbWUgaW4gb3ZlcnJpZGVDb250ZXh0KSAmJiAhKG92ZXJyaWRlQ29udGV4dC5iaW5kaW5nQ29udGV4dCAmJiBuYW1lIGluIG92ZXJyaWRlQ29udGV4dC5iaW5kaW5nQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZUNvbnRleHQgPSBvdmVycmlkZUNvbnRleHQucGFyZW50T3ZlcnJpZGVDb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJyaWRlQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGxvY2F0ZWQgYSBjb250ZXh0IHdpdGggdGhlIHByb3BlcnR5LiAgcmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lIGluIG92ZXJyaWRlQ29udGV4dCA/IG92ZXJyaWRlQ29udGV4dCA6IG92ZXJyaWRlQ29udGV4dC5iaW5kaW5nQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBuYW1lIHdhc24ndCBmb3VuZC4gIHJldHVybiB0aGUgcm9vdCBiaW5kaW5nIGNvbnRleHQuXG4gICAgICAgICAgICByZXR1cm4gc2NvcGUuYmluZGluZ0NvbnRleHQgfHwgc2NvcGUub3ZlcnJpZGVDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGdldE9ic2VydmVycygpIHtcbiAgICAgICAgICAgIGxldCBvYnNlcnZlcnMgPSB0aGlzLiRvYnNlcnZlcnM7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRvYnNlcnZlcnMgPSBvYnNlcnZlcnMgPSBuZXcgSW50ZXJuYWxPYnNlcnZlcnNMb29rdXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgU2NvcGUge1xuICAgICAgICBjb25zdHJ1Y3RvcihiaW5kaW5nQ29udGV4dCwgb3ZlcnJpZGVDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdDb250ZXh0ID0gYmluZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCA9IG92ZXJyaWRlQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY3JlYXRlKGJjLCBvYykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY29wZShiYywgb2MgPT09IG51bGwgfHwgb2MgPT09IHVuZGVmaW5lZCA/IE92ZXJyaWRlQ29udGV4dC5jcmVhdGUoYmMsIG9jKSA6IG9jKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbU92ZXJyaWRlKG9jKSB7XG4gICAgICAgICAgICBpZiAob2MgPT09IG51bGwgfHwgb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyNTIgLyogTmlsT3ZlcnJpZGVDb250ZXh0ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NvcGUob2MuYmluZGluZ0NvbnRleHQsIG9jKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbVBhcmVudChwcywgYmMpIHtcbiAgICAgICAgICAgIGlmIChwcyA9PT0gbnVsbCB8fCBwcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDI1MyAvKiBOaWxQYXJlbnRTY29wZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjb3BlKGJjLCBPdmVycmlkZUNvbnRleHQuY3JlYXRlKGJjLCBwcy5vdmVycmlkZUNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBPdmVycmlkZUNvbnRleHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihiaW5kaW5nQ29udGV4dCwgcGFyZW50T3ZlcnJpZGVDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdDb250ZXh0ID0gYmluZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE92ZXJyaWRlQ29udGV4dCA9IHBhcmVudE92ZXJyaWRlQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuJHN5bnRoZXRpYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNyZWF0ZShiYywgcG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE92ZXJyaWRlQ29udGV4dChiYywgcG9jID09PSB1bmRlZmluZWQgPyBudWxsIDogcG9jKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRPYnNlcnZlcnMoKSB7XG4gICAgICAgICAgICBsZXQgb2JzZXJ2ZXJzID0gdGhpcy4kb2JzZXJ2ZXJzO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kb2JzZXJ2ZXJzID0gb2JzZXJ2ZXJzID0gbmV3IEludGVybmFsT2JzZXJ2ZXJzTG9va3VwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgSVNpZ25hbGVyID0ga2VybmVsLkRJLmNyZWF0ZUludGVyZmFjZSgpLndpdGhEZWZhdWx0KHggPT4geC5zaW5nbGV0b24oU2lnbmFsZXIpKTtcbiAgICAvKkBpbnRlcm5hbCovXG4gICAgY2xhc3MgU2lnbmFsZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2hTaWduYWwobmFtZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuc2lnbmFsc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZUNoYW5nZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmxhZ3MgfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnVwZGF0ZVRhcmdldEluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRTaWduYWxMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFscyA9IHRoaXMuc2lnbmFscztcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHNpZ25hbHNbbmFtZV07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzaWduYWxzW25hbWVdID0gbmV3IFNldChbbGlzdGVuZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZVNpZ25hbExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLnNpZ25hbHNbbmFtZV07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZUNvbnZlcnRlcihuYW1lT3JTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBWYWx1ZUNvbnZlcnRlclJlc291cmNlLmRlZmluZShuYW1lT3JTb3VyY2UsIHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IFZhbHVlQ29udmVydGVyUmVzb3VyY2UgPSB7XG4gICAgICAgIG5hbWU6ICd2YWx1ZS1jb252ZXJ0ZXInLFxuICAgICAgICBrZXlGcm9tKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9OiR7bmFtZX1gO1xuICAgICAgICB9LFxuICAgICAgICBpc1R5cGUoVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGUua2luZCA9PT0gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVmaW5lKG5hbWVPclNvdXJjZSwgY3Rvcikge1xuICAgICAgICAgICAgY29uc3QgVHlwZSA9IGN0b3I7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHR5cGVvZiBuYW1lT3JTb3VyY2UgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyB7IG5hbWU6IG5hbWVPclNvdXJjZSB9XG4gICAgICAgICAgICAgICAgOiBuYW1lT3JTb3VyY2U7XG4gICAgICAgICAgICBUeXBlLmtpbmQgPSBWYWx1ZUNvbnZlcnRlclJlc291cmNlO1xuICAgICAgICAgICAgVHlwZS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgVHlwZS5yZWdpc3RlciA9IHJlZ2lzdGVyJDE7XG4gICAgICAgICAgICByZXR1cm4gVHlwZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXIkMShjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyKGtlcm5lbC5SZWdpc3RyYXRpb24uc2luZ2xldG9uKFZhbHVlQ29udmVydGVyUmVzb3VyY2Uua2V5RnJvbSh0aGlzLmRlc2NyaXB0aW9uLm5hbWUpLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29ubmVjdHMoZXhwcikge1xuICAgICAgICByZXR1cm4gKGV4cHIuJGtpbmQgJiAzMiAvKiBDb25uZWN0cyAqLykgPT09IDMyIC8qIENvbm5lY3RzICovO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvYnNlcnZlcyhleHByKSB7XG4gICAgICAgIHJldHVybiAoZXhwci4ka2luZCAmIDY0IC8qIE9ic2VydmVzICovKSA9PT0gNjQgLyogT2JzZXJ2ZXMgKi87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxzRnVuY3Rpb24oZXhwcikge1xuICAgICAgICByZXR1cm4gKGV4cHIuJGtpbmQgJiAxMjggLyogQ2FsbHNGdW5jdGlvbiAqLykgPT09IDEyOCAvKiBDYWxsc0Z1bmN0aW9uICovO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNBbmNlc3RvcihleHByKSB7XG4gICAgICAgIHJldHVybiAoZXhwci4ka2luZCAmIDI1NiAvKiBIYXNBbmNlc3RvciAqLykgPT09IDI1NiAvKiBIYXNBbmNlc3RvciAqLztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBc3NpZ25hYmxlKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIChleHByLiRraW5kICYgODE5MiAvKiBJc0Fzc2lnbmFibGUgKi8pID09PSA4MTkyIC8qIElzQXNzaWduYWJsZSAqLztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMZWZ0SGFuZFNpZGUoZXhwcikge1xuICAgICAgICByZXR1cm4gKGV4cHIuJGtpbmQgJiAxMDI0IC8qIElzTGVmdEhhbmRTaWRlICovKSA9PT0gMTAyNCAvKiBJc0xlZnRIYW5kU2lkZSAqLztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQcmltYXJ5KGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIChleHByLiRraW5kICYgNTEyIC8qIElzUHJpbWFyeSAqLykgPT09IDUxMiAvKiBJc1ByaW1hcnkgKi87XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUmVzb3VyY2UoZXhwcikge1xuICAgICAgICByZXR1cm4gKGV4cHIuJGtpbmQgJiAzMjc2OCAvKiBJc1Jlc291cmNlICovKSA9PT0gMzI3NjggLyogSXNSZXNvdXJjZSAqLztcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzQmluZChleHByKSB7XG4gICAgICAgIHJldHVybiAoZXhwci4ka2luZCAmIDIwNDggLyogSGFzQmluZCAqLykgPT09IDIwNDggLyogSGFzQmluZCAqLztcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVW5iaW5kKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIChleHByLiRraW5kICYgNDA5NiAvKiBIYXNVbmJpbmQgKi8pID09PSA0MDk2IC8qIEhhc1VuYmluZCAqLztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaXRlcmFsKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIChleHByLiRraW5kICYgMTYzODQgLyogSXNMaXRlcmFsICovKSA9PT0gMTYzODQgLyogSXNMaXRlcmFsICovO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVQdXJlTGl0ZXJhbHMoZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zID09PSB1bmRlZmluZWQgfHwgZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHVyZUxpdGVyYWwoZXhwcmVzc2lvbnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1B1cmVMaXRlcmFsKGV4cHIpIHtcbiAgICAgICAgaWYgKGlzTGl0ZXJhbChleHByKSkge1xuICAgICAgICAgICAgc3dpdGNoIChleHByLiRraW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzk1NSAvKiBBcnJheUxpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmVQdXJlTGl0ZXJhbHMoZXhwci5lbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzk1NiAvKiBPYmplY3RMaXRlcmFsICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJlUHVyZUxpdGVyYWxzKGV4cHIudmFsdWVzKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OTU4IC8qIFRlbXBsYXRlICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJlUHVyZUxpdGVyYWxzKGV4cHIuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc5MjUgLyogUHJpbWl0aXZlTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbGFzcyBCaW5kaW5nQmVoYXZpb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihleHByZXNzaW9uLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yS2V5ID0gQmluZGluZ0JlaGF2aW9yUmVzb3VyY2Uua2V5RnJvbSh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uSGFzQmluZCA9IGhhc0JpbmQoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25IYXNVbmJpbmQgPSBoYXNVbmJpbmQoZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKGZsYWdzLCBzY29wZSwgbG9jYXRvciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uYXNzaWduKGZsYWdzLCBzY29wZSwgbG9jYXRvciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGJpbmQoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyNTAgLyogVW5kZWZpbmVkU2NvcGUgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDI1MSAvKiBOdWxsU2NvcGUgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDIwNiAvKiBOb0JpbmRpbmcgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYXRvciA9IGJpbmRpbmcubG9jYXRvcjtcbiAgICAgICAgICAgIGlmICghbG9jYXRvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMDIgLyogTm9Mb2NhdG9yICovLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25IYXNCaW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLmJpbmQoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJlaGF2aW9yS2V5ID0gdGhpcy5iZWhhdmlvcktleTtcbiAgICAgICAgICAgIGNvbnN0IGJlaGF2aW9yID0gbG9jYXRvci5nZXQoYmVoYXZpb3JLZXkpO1xuICAgICAgICAgICAgaWYgKCFiZWhhdmlvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMDMgLyogTm9CZWhhdmlvckZvdW5kICovLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kaW5nW2JlaGF2aW9yS2V5XSAhPT0gdW5kZWZpbmVkICYmIGJpbmRpbmdbYmVoYXZpb3JLZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDIwNCAvKiBCZWhhdmlvckFscmVhZHlBcHBsaWVkICovLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRpbmdbYmVoYXZpb3JLZXldID0gYmVoYXZpb3I7XG4gICAgICAgICAgICBiZWhhdmlvci5iaW5kLmFwcGx5KGJlaGF2aW9yLCBbZmxhZ3MsIHNjb3BlLCBiaW5kaW5nXS5jb25jYXQoZXZhbExpc3QoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCB0aGlzLmFyZ3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5iaW5kKGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgYmVoYXZpb3JLZXkgPSB0aGlzLmJlaGF2aW9yS2V5O1xuICAgICAgICAgICAgYmluZGluZ1tiZWhhdmlvcktleV0udW5iaW5kKGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICBiaW5kaW5nW2JlaGF2aW9yS2V5XSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uSGFzVW5iaW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLnVuYmluZChmbGFncywgc2NvcGUsIGJpbmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmRpbmdCZWhhdmlvcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBWYWx1ZUNvbnZlcnRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb24sIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgICAgIHRoaXMuY29udmVydGVyS2V5ID0gVmFsdWVDb252ZXJ0ZXJSZXNvdXJjZS5rZXlGcm9tKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICBpZiAoIWxvY2F0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMjAyIC8qIE5vTG9jYXRvciAqLywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBsb2NhdG9yLmdldCh0aGlzLmNvbnZlcnRlcktleSk7XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMDUgLyogTm9Db252ZXJ0ZXJGb3VuZCAqLywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3RvVmlldycgaW4gY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBBcnJheShsZW4gKyAxKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0gPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpICsgMV0gPSBhcmdzW2ldLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZXIudG9WaWV3LmFwcGx5KGNvbnZlcnRlciwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb2NhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDIwMiAvKiBOb0xvY2F0b3IgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udmVydGVyID0gbG9jYXRvci5nZXQodGhpcy5jb252ZXJ0ZXJLZXkpO1xuICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMjA1IC8qIE5vQ29udmVydGVyRm91bmQgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdmcm9tVmlldycgaW4gY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0ZXIuZnJvbVZpZXcuYXBwbHkoY29udmVydGVyLCBbdmFsdWVdLmNvbmNhdChldmFsTGlzdChmbGFncywgc2NvcGUsIGxvY2F0b3IsIHRoaXMuYXJncykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uYXNzaWduKGZsYWdzLCBzY29wZSwgbG9jYXRvciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyNTAgLyogVW5kZWZpbmVkU2NvcGUgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDI1MSAvKiBOdWxsU2NvcGUgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDIwNiAvKiBOb0JpbmRpbmcgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYXRvciA9IGJpbmRpbmcubG9jYXRvcjtcbiAgICAgICAgICAgIGlmICghbG9jYXRvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMDIgLyogTm9Mb2NhdG9yICovLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tpXS5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBsb2NhdG9yLmdldCh0aGlzLmNvbnZlcnRlcktleSk7XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMDUgLyogTm9Db252ZXJ0ZXJGb3VuZCAqLywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaWduYWxzID0gY29udmVydGVyLnNpZ25hbHM7XG4gICAgICAgICAgICBpZiAoc2lnbmFscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbmFsZXIgPSBsb2NhdG9yLmdldChJU2lnbmFsZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2lnbmFscy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsZXIuYWRkU2lnbmFsTGlzdGVuZXIoc2lnbmFsc1tpXSwgYmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5iaW5kKGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgbG9jYXRvciA9IGJpbmRpbmcubG9jYXRvcjtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IGxvY2F0b3IuZ2V0KHRoaXMuY29udmVydGVyS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbHMgPSBjb252ZXJ0ZXIuc2lnbmFscztcbiAgICAgICAgICAgIGlmIChzaWduYWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaWduYWxlciA9IGxvY2F0b3IuZ2V0KElTaWduYWxlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzaWduYWxzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzaWduYWxlci5yZW1vdmVTaWduYWxMaXN0ZW5lcihzaWduYWxzW2ldLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYWx1ZUNvbnZlcnRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBBc3NpZ24ge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldC5hc3NpZ24oZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCB0aGlzLnZhbHVlLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKGZsYWdzLCBzY29wZSwgbG9jYXRvciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuYXNzaWduKGZsYWdzLCBzY29wZSwgbG9jYXRvciwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0LmFzc2lnbihmbGFncywgc2NvcGUsIGxvY2F0b3IsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBc3NpZ24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgQ29uZGl0aW9uYWwge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIHllcywgbm8pIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICAgICAgdGhpcy55ZXMgPSB5ZXM7XG4gICAgICAgICAgICB0aGlzLm5vID0gbm87XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gKCEhdGhpcy5jb25kaXRpb24uZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSlcbiAgICAgICAgICAgICAgICA/IHRoaXMueWVzLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcilcbiAgICAgICAgICAgICAgICA6IHRoaXMubm8uZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gdGhpcy5jb25kaXRpb247XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy55ZXMuY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25kaXRpb24uY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMubm8uY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIEFjY2Vzc1RoaXMge1xuICAgICAgICBjb25zdHJ1Y3RvcihhbmNlc3RvciA9IDApIHtcbiAgICAgICAgICAgIHRoaXMuYW5jZXN0b3IgPSBhbmNlc3RvcjtcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIGlmIChzY29wZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDI1MCAvKiBVbmRlZmluZWRTY29wZSAqLywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMjUxIC8qIE51bGxTY29wZSAqLywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2MgPSBzY29wZS5vdmVycmlkZUNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMuYW5jZXN0b3I7XG4gICAgICAgICAgICB3aGlsZSAoaS0tICYmIG9jKSB7XG4gICAgICAgICAgICAgICAgb2MgPSBvYy5wYXJlbnRPdmVycmlkZUNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaSA8IDEgJiYgb2MgPyBvYy5iaW5kaW5nQ29udGV4dCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBY2Nlc3NUaGlzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFjY2Vzc1RoaXMuJHRoaXMgPSBuZXcgQWNjZXNzVGhpcygwKTtcbiAgICBBY2Nlc3NUaGlzLiRwYXJlbnQgPSBuZXcgQWNjZXNzVGhpcygxKTtcbiAgICBjbGFzcyBBY2Nlc3NTY29wZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFuY2VzdG9yID0gMCkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuYW5jZXN0b3IgPSBhbmNlc3RvcjtcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gQmluZGluZ0NvbnRleHQuZ2V0KHNjb3BlLCBuYW1lLCB0aGlzLmFuY2VzdG9yKVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBCaW5kaW5nQ29udGV4dC5nZXQoc2NvcGUsIG5hbWUsIHRoaXMuYW5jZXN0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQgPyAoY29udGV4dFtuYW1lXSA9IHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBCaW5kaW5nQ29udGV4dC5nZXQoc2NvcGUsIG5hbWUsIHRoaXMuYW5jZXN0b3IpO1xuICAgICAgICAgICAgYmluZGluZy5vYnNlcnZlUHJvcGVydHkoY29udGV4dCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QWNjZXNzU2NvcGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgQWNjZXNzTWVtYmVyIHtcbiAgICAgICAgY29uc3RydWN0b3Iob2JqZWN0LCBuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMub2JqZWN0LmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcik7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UgPT09IG51bGwgfHwgaW5zdGFuY2UgPT09IHVuZGVmaW5lZCA/IGluc3RhbmNlIDogaW5zdGFuY2VbdGhpcy5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5vYmplY3QuZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCB8fCB0eXBlb2YgaW5zdGFuY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdC5hc3NpZ24oZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZVt0aGlzLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqZWN0LmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZy5vYnNlcnZlUHJvcGVydHkob2JqLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFjY2Vzc01lbWJlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBBY2Nlc3NLZXllZCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9iamVjdCwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcikge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLm9iamVjdC5ldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsIHx8IGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXkuZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgICAgIC8vIG5vdGU6IGdldEtleWVkIGFuZCBzZXRLZXllZCBhcmUgcmVtb3ZlZCBiZWNhdXNlIHRoZXkgYXJlIGlkZW50aWNhbCB0byB0aGUgZGVmYXVsdCBzcGVjIGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHJ1bnRpbWUgZG9lcyB0aGlzIHRoaXMgZmFzdGVyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLm9iamVjdC5ldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXkuZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqZWN0LmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXkuY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5LmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gb2JzZXJ2ZSB0aGUgcHJvcGVydHkgcmVwcmVzZW50ZWQgYnkgdGhlIGtleSBhcyBsb25nIGFzIGl0J3Mgbm90IGFuIGFycmF5IGluZGV4ZXJcbiAgICAgICAgICAgICAgICAvLyAobm90ZTogc3RyaW5nIGluZGV4ZXJzIGJlaGF2ZSB0aGUgc2FtZSB3YXkgYXMgbnVtZXJpYyBpbmRleGVycyBhcyBsb25nIGFzIHRoZXkgcmVwcmVzZW50IG51bWJlcnMpXG4gICAgICAgICAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShvYmopICYmIGlzTnVtZXJpYyhrZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nLm9ic2VydmVQcm9wZXJ0eShvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFjY2Vzc0tleWVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIENhbGxTY29wZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MsIGFuY2VzdG9yID0gMCkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICB0aGlzLmFuY2VzdG9yID0gYW5jZXN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gZXZhbExpc3QoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IEJpbmRpbmdDb250ZXh0LmdldChzY29wZSwgdGhpcy5uYW1lLCB0aGlzLmFuY2VzdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBnZXRGdW5jdGlvbihmbGFncywgY29udGV4dCwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tpXS5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2FsbFNjb3BlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIENhbGxNZW1iZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMub2JqZWN0LmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcik7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gZXZhbExpc3QoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IGdldEZ1bmN0aW9uKGZsYWdzLCBpbnN0YW5jZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5vYmplY3QuZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIGlmIChnZXRGdW5jdGlvbihmbGFncyAmIH5leHBvcnRzLkxpZmVjeWNsZUZsYWdzLm11c3RFdmFsdWF0ZSwgb2JqLCB0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXS5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhbGxNZW1iZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgQ2FsbEZ1bmN0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IoZnVuYywgYXJncykge1xuICAgICAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5mdW5jLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcik7IC8vIG5vdCBzdXJlIHdoeSB0aGlzIGNhc3QgaXMgbmVlZGVkLi5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGV2YWxMaXN0KGZsYWdzLCBzY29wZSwgbG9jYXRvciwgdGhpcy5hcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MubXVzdEV2YWx1YXRlKSAmJiAoZnVuYyA9PT0gbnVsbCB8fCBmdW5jID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMDcgLyogTm90QUZ1bmN0aW9uICovLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IHRoaXMuZnVuYy5ldmFsdWF0ZShmbGFncywgc2NvcGUsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5mdW5jLmNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0uY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDYWxsRnVuY3Rpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgQmluYXJ5IHtcbiAgICAgICAgY29uc3RydWN0b3Iob3BlcmF0aW9uLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgLy8gd2hhdCB3ZSdyZSBkb2luZyBoZXJlIGlzIGVmZmVjdGl2ZWx5IG1vdmluZyB0aGUgbGFyZ2Ugc3dpdGNoIHN0YXRlbWVudCBmcm9tIGV2YWx1YXRlIHRvIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgY2hlY2sgb25seSBuZWVkcyB0byBiZSBkb25lIG9uY2UsIGFuZCBldmFsdWF0ZSAod2hpY2ggaXMgY2FsbGVkIG1hbnkgdGltZXMpIHdpbGwgaGF2ZSBhIGxvdCBsZXNzXG4gICAgICAgICAgICAvLyB3b3JrIHRvIGRvOyB3ZSBjYW4gZG8gdGhpcyBiZWNhdXNlIHRoZSBvcGVyYXRpb24gY2FuJ3QgY2hhbmdlIGFmdGVyIGl0J3MgcGFyc2VkXG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRlID0gdGhpc1tvcGVyYXRpb25dO1xuICAgICAgICB9XG4gICAgICAgIGV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcikge1xuICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDIwOCAvKiBVbmtub3duT3BlcmF0b3IgKi8sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0LmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmxlZnQuY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uID09PSAnJiYnICYmICFsZWZ0IHx8IHRoaXMub3BlcmF0aW9uID09PSAnfHwnICYmIGxlZnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJpZ2h0LmNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBbJyYmJ10oZiwgcywgbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSAmJiB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGwpO1xuICAgICAgICB9XG4gICAgICAgIFsnfHwnXShmLCBzLCBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGwpIHx8IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWyc9PSddKGYsIHMsIGwpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0cmlwbGUtZXF1YWxzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGwpID09IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWyc9PT0nXShmLCBzLCBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGwpID09PSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGwpO1xuICAgICAgICB9XG4gICAgICAgIFsnIT0nXShmLCBzLCBsKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFsc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSAhPSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGwpO1xuICAgICAgICB9XG4gICAgICAgIFsnIT09J10oZiwgcywgbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSAhPT0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBsKTtcbiAgICAgICAgfVxuICAgICAgICBbJ2luc3RhbmNlb2YnXShmLCBzLCBsKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJpZ2h0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSBpbnN0YW5jZW9mIHJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFsnaW4nXShmLCBzLCBsKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgICAgICBpZiAocmlnaHQgIT09IG51bGwgJiYgdHlwZW9mIHJpZ2h0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgbCkgaW4gcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZTogYXV0b0NvbnZlcnRBZGQgKGFuZCB0aGUgbnVsbCBjaGVjaykgaXMgcmVtb3ZlZCBiZWNhdXNlIHRoZSBkZWZhdWx0IHNwZWMgYmVoYXZpb3IgaXMgYWxyZWFkeSBsYXJnZWx5IHNpbWlsYXJcbiAgICAgICAgLy8gYW5kIHdoZXJlIGl0IGlzbid0LCB5b3Uga2luZCBvZiB3YW50IGl0IHRvIGJlaGF2ZSBsaWtlIHRoZSBzcGVjIGFueXdheSAoZS5nLiByZXR1cm4gTmFOIHdoZW4gYWRkaW5nIGEgbnVtYmVyIHRvIHVuZGVmaW5lZClcbiAgICAgICAgLy8gdGhpcyBtYWtlcyBidWdzIGluIHVzZXIgY29kZSBlYXNpZXIgdG8gdHJhY2sgZG93biBmb3IgZW5kIHVzZXJzXG4gICAgICAgIC8vIGFsc28sIHNraXBwaW5nIHRoZXNlIGNoZWNrcyBhbmQgbGVhdmluZyBpdCB0byB0aGUgcnVudGltZSBpcyBhIG5pY2UgbGl0dGxlIHBlcmYgYm9vc3QgYW5kIHNpbXBsaWZpZXMgb3VyIGNvZGVcbiAgICAgICAgWycrJ10oZiwgcywgbCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSArIHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWyctJ10oZiwgcywgbCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSAtIHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWycqJ10oZiwgcywgbCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSAqIHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWycvJ10oZiwgcywgbCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSAvIHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWyclJ10oZiwgcywgbCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSAlIHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWyc8J10oZiwgcywgbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSA8IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWyc+J10oZiwgcywgbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSA+IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWyc8PSddKGYsIHMsIGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgbCkgPD0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBsKTtcbiAgICAgICAgfVxuICAgICAgICBbJz49J10oZiwgcywgbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBsKSA+PSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptZW1iZXItb3JkZXJpbmdcbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIFVuYXJ5IHtcbiAgICAgICAgY29uc3RydWN0b3Iob3BlcmF0aW9uLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgICAvLyBzZWUgQmluYXJ5ICh3ZSdyZSBkb2luZyB0aGUgc2FtZSB0aGluZyBoZXJlKVxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZSA9IHRoaXNbb3BlcmF0aW9uXTtcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMDggLyogVW5rbm93bk9wZXJhdG9yICovLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLmNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBbJ3ZvaWQnXShmLCBzLCBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoZiwgcywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgWyd0eXBlb2YnXShmLCBzLCBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBsKTtcbiAgICAgICAgfVxuICAgICAgICBbJyEnXShmLCBzLCBsKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBsKTtcbiAgICAgICAgfVxuICAgICAgICBbJy0nXShmLCBzLCBsKSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBsKTtcbiAgICAgICAgfVxuICAgICAgICBbJysnXShmLCBzLCBsKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWVtYmVyLW9yZGVyaW5nXG4gICAgICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFVuYXJ5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIFByaW1pdGl2ZUxpdGVyYWwge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJpbWl0aXZlTGl0ZXJhbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQcmltaXRpdmVMaXRlcmFsLiR1bmRlZmluZWQgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbCh1bmRlZmluZWQpO1xuICAgIFByaW1pdGl2ZUxpdGVyYWwuJG51bGwgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbChudWxsKTtcbiAgICBQcmltaXRpdmVMaXRlcmFsLiR0cnVlID0gbmV3IFByaW1pdGl2ZUxpdGVyYWwodHJ1ZSk7XG4gICAgUHJpbWl0aXZlTGl0ZXJhbC4kZmFsc2UgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbChmYWxzZSk7XG4gICAgUHJpbWl0aXZlTGl0ZXJhbC4kZW1wdHkgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbCgnJyk7XG4gICAgY2xhc3MgSHRtbExpdGVyYWwge1xuICAgICAgICBjb25zdHJ1Y3RvcihwYXJ0cykge1xuICAgICAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICB9XG4gICAgICAgIGV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcikge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnBhcnRzO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudHNbaV0uZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5wYXJ0cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0c1tpXS5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SHRtbExpdGVyYWwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgQXJyYXlMaXRlcmFsIHtcbiAgICAgICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZWxlbWVudHNbaV0uZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1tpXS5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXlMaXRlcmFsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFycmF5TGl0ZXJhbC4kZW1wdHkgPSBuZXcgQXJyYXlMaXRlcmFsKGtlcm5lbC5QTEFURk9STS5lbXB0eUFycmF5KTtcbiAgICBjbGFzcyBPYmplY3RMaXRlcmFsIHtcbiAgICAgICAgY29uc3RydWN0b3Ioa2V5cywgdmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHt9O1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cztcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5c1tpXV0gPSB2YWx1ZXNbaV0uZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cztcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldLmNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRPYmplY3RMaXRlcmFsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdExpdGVyYWwuJGVtcHR5ID0gbmV3IE9iamVjdExpdGVyYWwoa2VybmVsLlBMQVRGT1JNLmVtcHR5QXJyYXksIGtlcm5lbC5QTEFURk9STS5lbXB0eUFycmF5KTtcbiAgICBjbGFzcyBUZW1wbGF0ZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvb2tlZCwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY29va2VkID0gY29va2VkO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zIHx8IGtlcm5lbC5QTEFURk9STS5lbXB0eUFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcikge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSB0aGlzLmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgY29uc3QgY29va2VkID0gdGhpcy5jb29rZWQ7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gY29va2VkWzBdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZXhwcmVzc2lvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBleHByZXNzaW9uc1tpXS5ldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjb29rZWRbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSB0aGlzLmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZXhwcmVzc2lvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zW2ldLmNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGVtcGxhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGVtcGxhdGUuJGVtcHR5ID0gbmV3IFRlbXBsYXRlKFsnJ10pO1xuICAgIGNsYXNzIFRhZ2dlZFRlbXBsYXRlIHtcbiAgICAgICAgY29uc3RydWN0b3IoY29va2VkLCByYXcsIGZ1bmMsIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNvb2tlZCA9IGNvb2tlZDtcbiAgICAgICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgICAgICBjb29rZWQucmF3ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zIHx8IGtlcm5lbC5QTEFURk9STS5lbXB0eUFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcikge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSB0aGlzLmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IEFycmF5KGxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsZW47IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGV4cHJlc3Npb25zW2ldLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5mdW5jLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcik7IC8vIG5vdCBzdXJlIHdoeSB0aGlzIGNhc3QgaXMgbmVlZGVkLi5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMDcgLyogTm90QUZ1bmN0aW9uICovLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIFt0aGlzLmNvb2tlZF0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSB0aGlzLmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZXhwcmVzc2lvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zW2ldLmNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnVuYy5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGFnZ2VkVGVtcGxhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgQXJyYXlCaW5kaW5nUGF0dGVybiB7XG4gICAgICAgIC8vIFdlJ2xsIGVpdGhlciBoYXZlIGVsZW1lbnRzLCBvciBrZXlzK3ZhbHVlcywgYnV0IG5ldmVyIGFsbCAzXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgIGFzc2lnbihmbGFncywgc2NvcGUsIGxvY2F0b3IsIG9iaikge1xuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXlCaW5kaW5nUGF0dGVybih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBPYmplY3RCaW5kaW5nUGF0dGVybiB7XG4gICAgICAgIC8vIFdlJ2xsIGVpdGhlciBoYXZlIGVsZW1lbnRzLCBvciBrZXlzK3ZhbHVlcywgYnV0IG5ldmVyIGFsbCAzXG4gICAgICAgIGNvbnN0cnVjdG9yKGtleXMsIHZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgZXZhbHVhdGUoZmxhZ3MsIHNjb3BlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICBhc3NpZ24oZmxhZ3MsIHNjb3BlLCBsb2NhdG9yLCBvYmopIHtcbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE9iamVjdEJpbmRpbmdQYXR0ZXJuKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIEJpbmRpbmdJZGVudGlmaWVyIHtcbiAgICAgICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5kaW5nSWRlbnRpZmllcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0b1N0cmluZ1RhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0aW9uLXN0YXRlbWVudHNcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3ItaW4tYW5kLWZvci1vZi1zdGF0ZW1lbnRzXG4gICAgY2xhc3MgRm9yT2ZTdGF0ZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihkZWNsYXJhdGlvbiwgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhYmxlLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gQ291bnRGb3JPZlN0YXRlbWVudFt0b1N0cmluZ1RhZy5jYWxsKHJlc3VsdCldKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICBpdGVyYXRlKHJlc3VsdCwgZnVuYykge1xuICAgICAgICAgICAgSXRlcmF0ZUZvck9mU3RhdGVtZW50W3RvU3RyaW5nVGFnLmNhbGwocmVzdWx0KV0ocmVzdWx0LCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbi5jb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZyk7XG4gICAgICAgICAgICB0aGlzLml0ZXJhYmxlLmNvbm5lY3QoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGb3JPZlN0YXRlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgICogTm90ZTogdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBmYXIgc2ltcGxlciB0aGFuIHRoZSBvbmUgaW4gdkN1cnJlbnQgYW5kIG1pZ2h0IGJlIG1pc3NpbmcgaW1wb3J0YW50IHN0dWZmIChub3Qgc3VyZSB5ZXQpXG4gICAgKiBzbyB3aGlsZSB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGlkZW50aWNhbCB0byBUZW1wbGF0ZSBhbmQgd2UgY291bGQgcmV1c2UgdGhhdCBvbmUsIHdlIGRvbid0IHdhbnQgdG8gbG9jayBvdXRzZWx2ZXMgaW4gdG8gcG90ZW50aWFsbHkgdGhlIHdyb25nIGFic3RyYWN0aW9uXG4gICAgKiBidXQgdGhpcyBjbGFzcyBtaWdodCBiZSBhIGNhbmRpZGF0ZSBmb3IgcmVtb3ZhbCBpZiBpdCB0dXJucyBvdXQgaXQgZG9lcyBwcm92aWRlIGFsbCB3ZSBuZWVkXG4gICAgKi9cbiAgICBjbGFzcyBJbnRlcnBvbGF0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IocGFydHMsIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmlzTXVsdGkgPSBleHByZXNzaW9ucy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgdGhpcy5maXJzdEV4cHJlc3Npb24gPSBleHByZXNzaW9uc1swXTtcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IHRoaXMuZXhwcmVzc2lvbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnBhcnRzO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBleHByZXNzaW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBleHByZXNzaW9uc1tpXS5ldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnBhcnRzO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c1swXSArIHRoaXMuZmlyc3RFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgbG9jYXRvcikgKyBwYXJ0c1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0KGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludGVycG9sYXRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAqIE5vdGU6IGZvciBhIHByb3BlcnR5IHRoYXQgaXMgYWx3YXlzIHRoZSBzYW1lLCBkaXJlY3RseSBhc3NpZ25pbmcgaXQgdG8gdGhlIHByb3RvdHlwZSBpcyBtb3JlIGVmZmljaWVudCBDUFUgd2lzZVxuICAgICogKGdldHMgYXNzaWduZWQgb25jZSwgaW5zdGVhZCBvZiBwZXIgY29uc3RydWN0b3IgY2FsbCkgYXMgd2VsbCBhcyBtZW1vcnkgd2lzZSAoc3RvcmVkIG9uY2UsIGluc3RlYWQgb2YgcGVyIGluc3RhbmNlKVxuICAgICpcbiAgICAqIFRoaXMgZ2l2ZXMgdXMgYSBjaGVhcCB3YXkgdG8gYWRkIHNvbWUgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIEFTVCBmb3IgdGhlIHJ1bnRpbWUgdG8gZG8gdGhpbmdzIG1vcmUgZWZmaWNpZW50bHkuXG4gICAgKi9cbiAgICBCaW5kaW5nQmVoYXZpb3IucHJvdG90eXBlLiRraW5kID0gMzg5NjIgLyogQmluZGluZ0JlaGF2aW9yICovO1xuICAgIFZhbHVlQ29udmVydGVyLnByb3RvdHlwZS4ka2luZCA9IDM2OTEzIC8qIFZhbHVlQ29udmVydGVyICovO1xuICAgIEFzc2lnbi5wcm90b3R5cGUuJGtpbmQgPSA4MjA4IC8qIEFzc2lnbiAqLztcbiAgICBDb25kaXRpb25hbC5wcm90b3R5cGUuJGtpbmQgPSA2MyAvKiBDb25kaXRpb25hbCAqLztcbiAgICBBY2Nlc3NUaGlzLnByb3RvdHlwZS4ka2luZCA9IDE3OTMgLyogQWNjZXNzVGhpcyAqLztcbiAgICBBY2Nlc3NTY29wZS5wcm90b3R5cGUuJGtpbmQgPSAxMDA4MiAvKiBBY2Nlc3NTY29wZSAqLztcbiAgICBBY2Nlc3NNZW1iZXIucHJvdG90eXBlLiRraW5kID0gOTMyMyAvKiBBY2Nlc3NNZW1iZXIgKi87XG4gICAgQWNjZXNzS2V5ZWQucHJvdG90eXBlLiRraW5kID0gOTMyNCAvKiBBY2Nlc3NLZXllZCAqLztcbiAgICBDYWxsU2NvcGUucHJvdG90eXBlLiRraW5kID0gMTQ0OCAvKiBDYWxsU2NvcGUgKi87XG4gICAgQ2FsbE1lbWJlci5wcm90b3R5cGUuJGtpbmQgPSAxMTYxIC8qIENhbGxNZW1iZXIgKi87XG4gICAgQ2FsbEZ1bmN0aW9uLnByb3RvdHlwZS4ka2luZCA9IDExNjIgLyogQ2FsbEZ1bmN0aW9uICovO1xuICAgIEJpbmFyeS5wcm90b3R5cGUuJGtpbmQgPSA0NiAvKiBCaW5hcnkgKi87XG4gICAgVW5hcnkucHJvdG90eXBlLiRraW5kID0gMzkgLyogVW5hcnkgKi87XG4gICAgUHJpbWl0aXZlTGl0ZXJhbC5wcm90b3R5cGUuJGtpbmQgPSAxNzkyNSAvKiBQcmltaXRpdmVMaXRlcmFsICovO1xuICAgIEh0bWxMaXRlcmFsLnByb3RvdHlwZS4ka2luZCA9IDUxIC8qIEh0bWxMaXRlcmFsICovO1xuICAgIEFycmF5TGl0ZXJhbC5wcm90b3R5cGUuJGtpbmQgPSAxNzk1NSAvKiBBcnJheUxpdGVyYWwgKi87XG4gICAgT2JqZWN0TGl0ZXJhbC5wcm90b3R5cGUuJGtpbmQgPSAxNzk1NiAvKiBPYmplY3RMaXRlcmFsICovO1xuICAgIFRlbXBsYXRlLnByb3RvdHlwZS4ka2luZCA9IDE3OTU4IC8qIFRlbXBsYXRlICovO1xuICAgIFRhZ2dlZFRlbXBsYXRlLnByb3RvdHlwZS4ka2luZCA9IDExOTcgLyogVGFnZ2VkVGVtcGxhdGUgKi87XG4gICAgQXJyYXlCaW5kaW5nUGF0dGVybi5wcm90b3R5cGUuJGtpbmQgPSA2NTU1NiAvKiBBcnJheUJpbmRpbmdQYXR0ZXJuICovO1xuICAgIE9iamVjdEJpbmRpbmdQYXR0ZXJuLnByb3RvdHlwZS4ka2luZCA9IDY1NTU3IC8qIE9iamVjdEJpbmRpbmdQYXR0ZXJuICovO1xuICAgIEJpbmRpbmdJZGVudGlmaWVyLnByb3RvdHlwZS4ka2luZCA9IDY1NTU4IC8qIEJpbmRpbmdJZGVudGlmaWVyICovO1xuICAgIEZvck9mU3RhdGVtZW50LnByb3RvdHlwZS4ka2luZCA9IDU1IC8qIEZvck9mU3RhdGVtZW50ICovO1xuICAgIEludGVycG9sYXRpb24ucHJvdG90eXBlLiRraW5kID0gMjQgLyogSW50ZXJwb2xhdGlvbiAqLztcbiAgICAvLy8gRXZhbHVhdGUgdGhlIFtsaXN0XSBpbiBjb250ZXh0IG9mIHRoZSBbc2NvcGVdLlxuICAgIGZ1bmN0aW9uIGV2YWxMaXN0KGZsYWdzLCBzY29wZSwgbG9jYXRvciwgbGlzdCkge1xuICAgICAgICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQXJyYXkobGVuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gbGlzdFtpXS5ldmFsdWF0ZShmbGFncywgc2NvcGUsIGxvY2F0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEZ1bmN0aW9uKGZsYWdzLCBvYmosIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvYmpbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLm11c3RFdmFsdWF0ZSkgJiYgKGZ1bmMgPT09IG51bGwgfHwgZnVuYyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDIwNyAvKiBOb3RBRnVuY3Rpb24gKi8sIG9iaiwgbmFtZSwgZnVuYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyh2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZVR5cGUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh2YWx1ZVR5cGUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoYXIgPCAweDMwIC8qMCovIHx8IGNoYXIgPiAweDM5IC8qOSovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgY29uc3QgSXRlcmF0ZUZvck9mU3RhdGVtZW50ID0ge1xuICAgICAgICBbJ1tvYmplY3QgQXJyYXldJ10ocmVzdWx0LCBmdW5jKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSByZXN1bHQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGZ1bmMocmVzdWx0LCBpLCByZXN1bHRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbJ1tvYmplY3QgTWFwXSddKHJlc3VsdCwgZnVuYykge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gQXJyYXkocmVzdWx0LnNpemUpO1xuICAgICAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVzdWx0LmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGFyclsrK2ldID0gZW50cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJdGVyYXRlRm9yT2ZTdGF0ZW1lbnRbJ1tvYmplY3QgQXJyYXldJ10oYXJyLCBmdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgWydbb2JqZWN0IFNldF0nXShyZXN1bHQsIGZ1bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IEFycmF5KHJlc3VsdC5zaXplKTtcbiAgICAgICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZXN1bHQua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgYXJyWysraV0gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJdGVyYXRlRm9yT2ZTdGF0ZW1lbnRbJ1tvYmplY3QgQXJyYXldJ10oYXJyLCBmdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgWydbb2JqZWN0IE51bWJlcl0nXShyZXN1bHQsIGZ1bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IEFycmF5KHJlc3VsdCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEl0ZXJhdGVGb3JPZlN0YXRlbWVudFsnW29iamVjdCBBcnJheV0nXShhcnIsIGZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBbJ1tvYmplY3QgTnVsbF0nXShyZXN1bHQsIGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgWydbb2JqZWN0IFVuZGVmaW5lZF0nXShyZXN1bHQsIGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNvbnN0IENvdW50Rm9yT2ZTdGF0ZW1lbnQgPSB7XG4gICAgICAgIFsnW29iamVjdCBBcnJheV0nXShyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5sZW5ndGg7IH0sXG4gICAgICAgIFsnW29iamVjdCBNYXBdJ10ocmVzdWx0KSB7IHJldHVybiByZXN1bHQuc2l6ZTsgfSxcbiAgICAgICAgWydbb2JqZWN0IFNldF0nXShyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5zaXplOyB9LFxuICAgICAgICBbJ1tvYmplY3QgTnVtYmVyXSddKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0OyB9LFxuICAgICAgICBbJ1tvYmplY3QgTnVsbF0nXShyZXN1bHQpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgIFsnW29iamVjdCBVbmRlZmluZWRdJ10ocmVzdWx0KSB7IHJldHVybiAwOyB9XG4gICAgfTtcbiAgICAvLyBHaXZlIGVhY2ggQVNUIGNsYXNzIGEgbm9vcCBmb3IgZWFjaCBpbnRlcmZhY2UgbWV0aG9kIGlmIGFuZCBvbmx5IGlmIGl0J3Mgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgIC8vIFRoaXMgYWNjb21wbGlzaGVzIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gICAxKSBubyBydW50aW1lIGVycm9yIGR1ZSB0byBiYWQgQVNUIHN0cnVjdHVyZSAoaXQncyB0aGUgcGFyc2VyJ3Mgam9iIHRvIGd1YXJkIGFnYWluc3QgdGhhdClcbiAgICAvLyAgIDIpIG5vIHJ1bnRpbWUgZXJyb3IgZHVlIHRvIGEgYmFkIGJpbmRpbmcgc3VjaCBhcyB0d28td2F5IG9uIGEgbGl0ZXJhbCAobm8gbmVlZCwgc2luY2UgaXQgZG9lc24ndCB0aHJlYXRlbiB0aGUgaW50ZWdyaXR5IG9mIHRoZSBhcHAncyBzdGF0ZSlcbiAgICAvLyAgIDMpIHNob3VsZCB3ZSBkZWNpZGUgc29tZXRoaW5nIGVsc2UsIHdlIGNhbiBlYXNpbHkgY2hhbmdlIHRoZSBnbG9iYWwgYmVoYXZpb3Igb2YgMSkgYW5kIDIpIGJ5IHNpbXBseSBhc3NpZ25pbmcgYSBkaWZmZXJlbnQgbWV0aG9kIGhlcmUgKGVpdGhlciBpbiB0aGUgc291cmNlIG9yIHZpYSBBT1QpXG4gICAgY29uc3QgYXN0ID0gW0FjY2Vzc1RoaXMsIEFjY2Vzc1Njb3BlLCBBcnJheUxpdGVyYWwsIE9iamVjdExpdGVyYWwsIFByaW1pdGl2ZUxpdGVyYWwsIFRlbXBsYXRlLCBVbmFyeSwgQ2FsbEZ1bmN0aW9uLCBDYWxsTWVtYmVyLCBDYWxsU2NvcGUsIEFjY2Vzc01lbWJlciwgQWNjZXNzS2V5ZWQsIFRhZ2dlZFRlbXBsYXRlLCBCaW5hcnksIENvbmRpdGlvbmFsLCBBc3NpZ24sIEZvck9mU3RhdGVtZW50XTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhc3QubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb25zdCBwcm90byA9IGFzdFtpXS5wcm90b3R5cGU7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgcHJvdG8uYXNzaWduID0gcHJvdG8uYXNzaWduIHx8IGtlcm5lbC5QTEFURk9STS5ub29wO1xuICAgICAgICBwcm90by5jb25uZWN0ID0gcHJvdG8uY29ubmVjdCB8fCBrZXJuZWwuUExBVEZPUk0ubm9vcDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBhZGQgY29ubmVjdC1xdWV1ZSAob3Igc29tZXRoaW5nIHNpbWlsYXIpIGJhY2sgaW4gd2hlbiBldmVyeXRoaW5nIGVsc2UgaXMgd29ya2luZywgdG8gaW1wcm92ZSBzdGFydHVwIHRpbWVcbiAgICBjb25zdCBzbG90TmFtZXMgPSBbXTtcbiAgICBjb25zdCB2ZXJzaW9uU2xvdE5hbWVzID0gW107XG4gICAgbGV0IGxhc3RTbG90ID0gLTE7XG4gICAgZnVuY3Rpb24gZW5zdXJlRW5vdWdoU2xvdE5hbWVzKGN1cnJlbnRTbG90KSB7XG4gICAgICAgIGlmIChjdXJyZW50U2xvdCA9PT0gbGFzdFNsb3QpIHtcbiAgICAgICAgICAgIGxhc3RTbG90ICs9IDU7XG4gICAgICAgICAgICBjb25zdCBpaSA9IHNsb3ROYW1lcy5sZW5ndGggPSB2ZXJzaW9uU2xvdE5hbWVzLmxlbmd0aCA9IGxhc3RTbG90ICsgMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjdXJyZW50U2xvdCArIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2xvdE5hbWVzW2ldID0gYF9vYnNlcnZlciR7aX1gO1xuICAgICAgICAgICAgICAgIHZlcnNpb25TbG90TmFtZXNbaV0gPSBgX29ic2VydmVyVmVyc2lvbiR7aX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuc3VyZUVub3VnaFNsb3ROYW1lcygtMSk7XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uIGFkZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIG9ic2VydmVyLlxuICAgICAgICBjb25zdCBvYnNlcnZlclNsb3RzID0gdGhpcy5vYnNlcnZlclNsb3RzID09PSB1bmRlZmluZWQgPyAwIDogdGhpcy5vYnNlcnZlclNsb3RzO1xuICAgICAgICBsZXQgaSA9IG9ic2VydmVyU2xvdHM7XG4gICAgICAgIHdoaWxlIChpLS0gJiYgdGhpc1tzbG90TmFtZXNbaV1dICE9PSBvYnNlcnZlcilcbiAgICAgICAgICAgIDtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBhbHJlYWR5IG9ic2VydmluZywgcHV0IHRoZSBvYnNlcnZlciBpbiBhbiBvcGVuIHNsb3QgYW5kIHN1YnNjcmliZS5cbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzW3Nsb3ROYW1lc1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW3Nsb3ROYW1lc1tpXV0gPSBvYnNlcnZlcjtcbiAgICAgICAgICAgIG9ic2VydmVyLnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgc2xvdCBjb3VudC5cbiAgICAgICAgICAgIGlmIChpID09PSBvYnNlcnZlclNsb3RzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlclNsb3RzID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSBcInZlcnNpb25cIiB3aGVuIHRoZSBvYnNlcnZlciB3YXMgdXNlZC5cbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbdmVyc2lvblNsb3ROYW1lc1tpXV0gPSB0aGlzLnZlcnNpb247XG4gICAgICAgIGVuc3VyZUVub3VnaFNsb3ROYW1lcyhpKTtcbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uIG9ic2VydmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJMb2NhdG9yLmdldE9ic2VydmVyKG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgLyogTm90ZTogd2UgbmVlZCB0byBjYXN0IGhlcmUgYmVjYXVzZSB3ZSBjYW4gaW5kZWVkIGdldCBhbiBhY2Nlc3NvciBpbnN0ZWFkIG9mIGFuIG9ic2VydmVyLFxuICAgICAgICAgKiAgaW4gd2hpY2ggY2FzZSB0aGUgY2FsbCB0byBvYnNlcnZlci5zdWJzY3JpYmUgd2lsbCB0aHJvdy4gSXQncyBub3QgdmVyeSBjbGVhbiBhbmQgd2UgY2FuIHNvbHZlIHRoaXMgaW4gMiB3YXlzOlxuICAgICAgICAgKiAgMS4gRmFpbCBlYXJsaWVyOiBvbmx5IGxldCB0aGUgbG9jYXRvciByZXNvbHZlIG9ic2VydmVycyBmcm9tIC5nZXRPYnNlcnZlciwgYW5kIHRocm93IGlmIG5vIGJyYW5jaGVzIGFyZSBsZWZ0IChlLmcuIGl0IHdvdWxkIG90aGVyd2lzZSByZXR1cm4gYW4gYWNjZXNzb3IpXG4gICAgICAgICAqICAyLiBGYWlsIHNpbGVudGx5ICh3aXRob3V0IHRocm93aW5nKTogZ2l2ZSBhbGwgYWNjZXNzb3JzIGEgbm8tb3Agc3Vic2NyaWJlIG1ldGhvZFxuICAgICAgICAgKlxuICAgICAgICAgKiBXZSdsbCBwcm9iYWJseSB3YW50IHRvIGltcGxlbWVudCBzb21lIGdsb2JhbCBjb25maWd1cmF0aW9uIChsaWtlIGEgXCJzdHJpY3RcIiB0b2dnbGUpIHNvIHVzZXJzIGNhbiBwaWNrIGJldHdlZW4gZW5mb3JjZWQgY29ycmVjdG5lc3MgdnMuIGVhc2Utb2YtdXNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uIHVub2JzZXJ2ZShhbGwpIHtcbiAgICAgICAgY29uc3Qgc2xvdHMgPSB0aGlzLm9ic2VydmVyU2xvdHM7XG4gICAgICAgIGxldCBzbG90TmFtZTtcbiAgICAgICAgbGV0IG9ic2VydmVyO1xuICAgICAgICBpZiAoYWxsID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzbG90TmFtZSA9IHNsb3ROYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlciA9IHRoaXNbc2xvdE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCAmJiBvYnNlcnZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc2xvdE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdHM7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW3ZlcnNpb25TbG90TmFtZXNbaV1dICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gc2xvdE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlciA9IHRoaXNbc2xvdE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwgJiYgb2JzZXJ2ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tzbG90TmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdGFibGVEZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnb2JzZXJ2ZVByb3BlcnR5JykpXG4gICAgICAgICAgICBwcm90by5vYnNlcnZlUHJvcGVydHkgPSBvYnNlcnZlUHJvcGVydHk7XG4gICAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ3Vub2JzZXJ2ZScpKVxuICAgICAgICAgICAgcHJvdG8udW5vYnNlcnZlID0gdW5vYnNlcnZlO1xuICAgICAgICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdhZGRPYnNlcnZlcicpKVxuICAgICAgICAgICAgcHJvdG8uYWRkT2JzZXJ2ZXIgPSBhZGRPYnNlcnZlcjtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdGFibGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGNvbm5lY3RhYmxlRGVjb3JhdG9yIDogY29ubmVjdGFibGVEZWNvcmF0b3IodGFyZ2V0KTtcbiAgICB9XG5cbiAgICAvLyBCaW5kaW5nTW9kZSBpcyBub3QgYSBjb25zdCBlbnVtIChhbmQgdGhlcmVmb3JlIG5vdCBpbmxpbmVkKSwgc28gYXNzaWduaW5nIHRoZW0gdG8gYSB2YXJpYWJsZSB0byBzYXZlIGEgbWVtYmVyIGFjY2Vzc29yIGlzIGEgbWlub3IgcGVyZiB0d2Vha1xuICAgIGNvbnN0IHsgb25lVGltZTogb25lVGltZSQxLCB0b1ZpZXc6IHRvVmlldyQxLCBmcm9tVmlldzogZnJvbVZpZXckMSB9ID0gZXhwb3J0cy5CaW5kaW5nTW9kZTtcbiAgICAvLyBwcmUtY29tYmluaW5nIGZsYWdzIGZvciBiaXR3aXNlIGNoZWNrcyBpcyBhIG1pbm9yIHBlcmYgdHdlYWtcbiAgICBjb25zdCB0b1ZpZXdPck9uZVRpbWUgPSB0b1ZpZXckMSB8IG9uZVRpbWUkMTtcbiAgICBleHBvcnRzLkJpbmRpbmcgPSBjbGFzcyBCaW5kaW5nIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCB0YXJnZXRQcm9wZXJ0eSwgbW9kZSwgb2JzZXJ2ZXJMb2NhdG9yLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFByb3BlcnR5ID0gdGFyZ2V0UHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICAgICAgdGhpcy4kbmV4dENvbm5lY3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kbmV4dFBhdGNoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJG5leHRCaW5kID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHByZXZCaW5kID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlID0gMCAvKiBub25lICovO1xuICAgICAgICAgICAgdGhpcy4kc2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kbGlmZWN5Y2xlID0gbG9jYXRvci5nZXQoSUxpZmVjeWNsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlVGFyZ2V0KHZhbHVlLCBmbGFncykge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zZXRWYWx1ZSh2YWx1ZSwgZmxhZ3MgfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnVwZGF0ZVRhcmdldEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVTb3VyY2UodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24uYXNzaWduKGZsYWdzIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy51cGRhdGVTb3VyY2VFeHByZXNzaW9uLCB0aGlzLiRzY29wZSwgdGhpcy5sb2NhdG9yLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0ICRzY29wZSA9IHRoaXMuJHNjb3BlO1xuICAgICAgICAgICAgY29uc3QgbG9jYXRvciA9IHRoaXMubG9jYXRvcjtcbiAgICAgICAgICAgIGlmIChmbGFncyAmIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MudXBkYXRlVGFyZ2V0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRPYnNlcnZlciA9IHRoaXMudGFyZ2V0T2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gdGFyZ2V0T2JzZXJ2ZXIuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgb25seSBvYnNlcnZhYmxlIGlzIGFuIEFjY2Vzc1Njb3BlIHRoZW4gd2UgY2FuIGFzc3VtZSB0aGUgcGFzc2VkLWluIG5ld1ZhbHVlIGlzIHRoZSBjb3JyZWN0IGFuZCBsYXRlc3QgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlRXhwcmVzc2lvbi4ka2luZCAhPT0gMTAwODIgLyogQWNjZXNzU2NvcGUgKi8gfHwgdGhpcy5vYnNlcnZlclNsb3RzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZUV4cHJlc3Npb24uZXZhbHVhdGUoZmxhZ3MsICRzY29wZSwgbG9jYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldChuZXdWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKG1vZGUgJiBvbmVUaW1lJDEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLmNvbm5lY3QoZmxhZ3MsICRzY29wZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5vYnNlcnZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzICYgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy51cGRhdGVTb3VyY2VFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBzb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCAkc2NvcGUsIGxvY2F0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU291cmNlKG5ld1ZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxNSwgZXhwb3J0cy5MaWZlY3ljbGVGbGFnc1tmbGFnc10pO1xuICAgICAgICB9XG4gICAgICAgICRiaW5kKGZsYWdzLCBzY29wZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJHVuYmluZChmbGFncyB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUJpbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGlzQmluZGluZyBmbGFnXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSAxIC8qIGlzQmluZGluZyAqLztcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICBsZXQgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChoYXNCaW5kKHNvdXJjZUV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi5iaW5kKGZsYWdzLCBzY29wZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlO1xuICAgICAgICAgICAgbGV0IHRhcmdldE9ic2VydmVyID0gdGhpcy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAmIGZyb21WaWV3JDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIgPSB0aGlzLnRhcmdldE9ic2VydmVyID0gdGhpcy5vYnNlcnZlckxvY2F0b3IuZ2V0T2JzZXJ2ZXIodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIgPSB0aGlzLnRhcmdldE9ic2VydmVyID0gdGhpcy5vYnNlcnZlckxvY2F0b3IuZ2V0QWNjZXNzb3IodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRPYnNlcnZlci5iaW5kKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIuYmluZChmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkdXJpbmcgYmluZCwgYmluZGluZyBiZWhhdmlvciBtaWdodCBoYXZlIGNoYW5nZWQgc291cmNlRXhwcmVzc2lvblxuICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChtb2RlICYgdG9WaWV3T3JPbmVUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgc2NvcGUsIHRoaXMubG9jYXRvciksIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlICYgdG9WaWV3JDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRsaWZlY3ljbGUuZW5xdWV1ZUNvbm5lY3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZSAmIGZyb21WaWV3JDEpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRPYnNlcnZlci5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgaXNCb3VuZCBmbGFnIGFuZCByZW1vdmUgaXNCaW5kaW5nIGZsYWdcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlIHw9IDIgLyogaXNCb3VuZCAqLztcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlICY9IH4xIC8qIGlzQmluZGluZyAqLztcbiAgICAgICAgfVxuICAgICAgICAkdW5iaW5kKGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLiRzdGF0ZSAmIDIgLyogaXNCb3VuZCAqLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgaXNVbmJpbmRpbmcgZmxhZ1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgfD0gNjQgLyogaXNVbmJpbmRpbmcgKi87XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGhhc1VuYmluZChzb3VyY2VFeHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24udW5iaW5kKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRzY29wZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRPYnNlcnZlciA9IHRoaXMudGFyZ2V0T2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAodGFyZ2V0T2JzZXJ2ZXIudW5iaW5kKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIudW5iaW5kKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRPYnNlcnZlci51bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bm9ic2VydmUodHJ1ZSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgaXNCb3VuZCBhbmQgaXNVbmJpbmRpbmcgZmxhZ3NcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlICY9IH4oMiAvKiBpc0JvdW5kICovIHwgNjQgLyogaXNVbmJpbmRpbmcgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3QoZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDIgLyogaXNCb3VuZCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbi5jb25uZWN0KGZsYWdzIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5tdXN0RXZhbHVhdGUsIHRoaXMuJHNjb3BlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaChmbGFncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQodGhpcy5zb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5tdXN0RXZhbHVhdGUsIHRoaXMuJHNjb3BlLCB0aGlzLmxvY2F0b3IpLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuQmluZGluZyA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb25uZWN0YWJsZSgpXG4gICAgXSwgZXhwb3J0cy5CaW5kaW5nKTtcblxuICAgIGNvbnN0IHVuc2V0ID0ge307XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlQ2FsbFNvdXJjZShldmVudCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZGVib3VuY2VTdGF0ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRJZCk7XG4gICAgICAgIHN0YXRlLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kZWJvdW5jZWRNZXRob2QoZXZlbnQpLCBzdGF0ZS5kZWxheSk7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZUNhbGwobmV3VmFsdWUsIG9sZFZhbHVlLCBmbGFncykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZGVib3VuY2VTdGF0ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRJZCk7XG4gICAgICAgIGlmICghKGZsYWdzICYgc3RhdGUuY2FsbENvbnRleHRUb0RlYm91bmNlKSkge1xuICAgICAgICAgICAgc3RhdGUub2xkVmFsdWUgPSB1bnNldDtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkTWV0aG9kKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5vbGRWYWx1ZSA9PT0gdW5zZXQpIHtcbiAgICAgICAgICAgIHN0YXRlLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUudGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdiA9IHN0YXRlLm9sZFZhbHVlO1xuICAgICAgICAgICAgc3RhdGUub2xkVmFsdWUgPSB1bnNldDtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkTWV0aG9kKG5ld1ZhbHVlLCBvdiwgZmxhZ3MpO1xuICAgICAgICB9LCBzdGF0ZS5kZWxheSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWV3JDIgPSBleHBvcnRzLkJpbmRpbmdNb2RlLmZyb21WaWV3O1xuICAgIGV4cG9ydHMuRGVib3VuY2VCaW5kaW5nQmVoYXZpb3IgPSBjbGFzcyBEZWJvdW5jZUJpbmRpbmdCZWhhdmlvciB7XG4gICAgICAgIGJpbmQoZmxhZ3MsIHNjb3BlLCBiaW5kaW5nLCBkZWxheSA9IDIwMCkge1xuICAgICAgICAgICAgbGV0IG1ldGhvZFRvRGVib3VuY2U7XG4gICAgICAgICAgICBsZXQgY2FsbENvbnRleHRUb0RlYm91bmNlO1xuICAgICAgICAgICAgbGV0IGRlYm91bmNlcjtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nIGluc3RhbmNlb2YgZXhwb3J0cy5CaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVG9EZWJvdW5jZSA9ICdoYW5kbGVDaGFuZ2UnO1xuICAgICAgICAgICAgICAgIGRlYm91bmNlciA9IGRlYm91bmNlQ2FsbDtcbiAgICAgICAgICAgICAgICBjYWxsQ29udGV4dFRvRGVib3VuY2UgPSBiaW5kaW5nLm1vZGUgJiBmcm9tVmlldyQyID8gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy51cGRhdGVTb3VyY2VFeHByZXNzaW9uIDogZXhwb3J0cy5MaWZlY3ljbGVGbGFncy51cGRhdGVUYXJnZXRJbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFRvRGVib3VuY2UgPSAnY2FsbFNvdXJjZSc7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VyID0gZGVib3VuY2VDYWxsU291cmNlO1xuICAgICAgICAgICAgICAgIGNhbGxDb250ZXh0VG9EZWJvdW5jZSA9IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MudXBkYXRlVGFyZ2V0SW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGFzaCB0aGUgb3JpZ2luYWwgbWV0aG9kIGFuZCBpdCdzIG5hbWUuXG4gICAgICAgICAgICAvLyBub3RlOiBhIGdlbmVyaWMgbmFtZSBsaWtlIFwib3JpZ2luYWxNZXRob2RcIiBpcyBub3QgdXNlZCB0byBhdm9pZCBjb2xsaXNpb25zXG4gICAgICAgICAgICAvLyB3aXRoIG90aGVyIGJpbmRpbmcgYmVoYXZpb3IgdHlwZXMuXG4gICAgICAgICAgICBiaW5kaW5nLmRlYm91bmNlZE1ldGhvZCA9IGJpbmRpbmdbbWV0aG9kVG9EZWJvdW5jZV07XG4gICAgICAgICAgICBiaW5kaW5nLmRlYm91bmNlZE1ldGhvZC5vcmlnaW5hbE5hbWUgPSBtZXRob2RUb0RlYm91bmNlO1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgb3JpZ2luYWwgbWV0aG9kIHdpdGggdGhlIGRlYm91bmNpbmcgdmVyc2lvbi5cbiAgICAgICAgICAgIGJpbmRpbmdbbWV0aG9kVG9EZWJvdW5jZV0gPSBkZWJvdW5jZXI7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGRlYm91bmNlIHN0YXRlLlxuICAgICAgICAgICAgYmluZGluZy5kZWJvdW5jZVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIGNhbGxDb250ZXh0VG9EZWJvdW5jZSxcbiAgICAgICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQ6IDAsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IHVuc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHVuYmluZChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBiaW5kaW5nLlxuICAgICAgICAgICAgY29uc3QgbWV0aG9kVG9SZXN0b3JlID0gYmluZGluZy5kZWJvdW5jZWRNZXRob2Qub3JpZ2luYWxOYW1lO1xuICAgICAgICAgICAgYmluZGluZ1ttZXRob2RUb1Jlc3RvcmVdID0gYmluZGluZy5kZWJvdW5jZWRNZXRob2Q7XG4gICAgICAgICAgICBiaW5kaW5nLmRlYm91bmNlZE1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoYmluZGluZy5kZWJvdW5jZVN0YXRlLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICBiaW5kaW5nLmRlYm91bmNlU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkRlYm91bmNlQmluZGluZ0JlaGF2aW9yID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGJpbmRpbmdCZWhhdmlvcignZGVib3VuY2UnKVxuICAgIF0sIGV4cG9ydHMuRGVib3VuY2VCaW5kaW5nQmVoYXZpb3IpO1xuXG4gICAgY29uc3QgU0NSSVBUX1JFR0VYID0gLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2k7XG4gICAgY29uc3QgSVNhbml0aXplciA9IGtlcm5lbC5ESS5jcmVhdGVJbnRlcmZhY2UoKVxuICAgICAgICAud2l0aERlZmF1bHQoeCA9PiB4LnNpbmdsZXRvbihjbGFzcyB7XG4gICAgICAgIHNhbml0aXplKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZShTQ1JJUFRfUkVHRVgsICcnKTtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICAvKipcbiAgICAgKiBTaW1wbGUgaHRtbCBzYW5pdGl6YXRpb24gY29udmVydGVyIHRvIHByZXNlcnZlIHdoaXRlbGlzdGVkIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIG9uIGEgYm91bmQgcHJvcGVydHkgY29udGFpbmluZyBodG1sLlxuICAgICAqL1xuICAgIGV4cG9ydHMuU2FuaXRpemVWYWx1ZUNvbnZlcnRlciA9IGNsYXNzIFNhbml0aXplVmFsdWVDb252ZXJ0ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihzYW5pdGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2FuaXRpemVyID0gc2FuaXRpemVyO1xuICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZXIgPSBzYW5pdGl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2Nlc3MgdGhlIHByb3ZpZGVkIG1hcmt1cCB0aGF0IGZsb3dzIHRvIHRoZSB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0gdW50cnVzdGVkTWFya3VwIFRoZSB1bnRydXN0ZWQgbWFya3VwIHRvIGJlIHNhbml0aXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRvVmlldyh1bnRydXN0ZWRNYXJrdXApIHtcbiAgICAgICAgICAgIGlmICh1bnRydXN0ZWRNYXJrdXAgPT09IG51bGwgfHwgdW50cnVzdGVkTWFya3VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhbml0aXplci5zYW5pdGl6ZSh1bnRydXN0ZWRNYXJrdXApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLlNhbml0aXplVmFsdWVDb252ZXJ0ZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdmFsdWVDb252ZXJ0ZXIoJ3Nhbml0aXplJyksXG4gICAgICAgIGtlcm5lbC5pbmplY3QoSVNhbml0aXplcilcbiAgICBdLCBleHBvcnRzLlNhbml0aXplVmFsdWVDb252ZXJ0ZXIpO1xuXG4gICAgLy9Ob3RlOiBwYXRoIGFuZCBkZWVwUGF0aCBhcmUgZGVzaWduZWQgdG8gaGFuZGxlIHYwIGFuZCB2MSBzaGFkb3cgZG9tIHNwZWNzIHJlc3BlY3RpdmVseVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiBmaW5kT3JpZ2luYWxFdmVudFRhcmdldChldmVudCkge1xuICAgICAgICByZXR1cm4gKGV2ZW50LmNvbXBvc2VkUGF0aCAmJiBldmVudC5jb21wb3NlZFBhdGgoKVswXSkgfHwgKGV2ZW50LmRlZXBQYXRoICYmIGV2ZW50LmRlZXBQYXRoKClbMF0pIHx8IChldmVudC5wYXRoICYmIGV2ZW50LnBhdGhbMF0pIHx8IGV2ZW50LnRhcmdldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICB0aGlzLnN0YW5kYXJkU3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQ2FwdHVyZWRFdmVudChldmVudCkge1xuICAgICAgICBldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGZpbmRPcmlnaW5hbEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZENhbGxiYWNrcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRHVyaW5nIGNhcHR1cmluZyBwaGFzZSwgZXZlbnQgJ2J1YmJsZXMnIGRvd24gZnJvbSBwYXJlbnQuIE5lZWRzIHRvIHJlb3JkZXIgY2FsbGJhY2sgZnJvbSByb290IGRvd24gdG8gdGFyZ2V0XG4gICAgICAgICAqL1xuICAgICAgICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNhcHR1cmVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0YXJnZXQuY2FwdHVyZWRDYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24gIT09IHN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RhbmRhcmRTdG9wUHJvcGFnYXRpb24gPSBldmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gb3JkZXJlZENhbGxiYWNrcy5sZW5ndGggLSAxOyBpID49IDAgJiYgIWV2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBvcmRlcmVkQ2FsbGJhY2sgPSBvcmRlcmVkQ2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKCdoYW5kbGVFdmVudCcgaW4gb3JkZXJlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb3JkZXJlZENhbGxiYWNrLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9yZGVyZWRDYWxsYmFjayhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRGVsZWdhdGVkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGxldCB0YXJnZXQgPSBmaW5kT3JpZ2luYWxFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgIWV2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5kZWxlZ2F0ZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRhcmdldC5kZWxlZ2F0ZWRDYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24gIT09IHN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RhbmRhcmRTdG9wUHJvcGFnYXRpb24gPSBldmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdoYW5kbGVFdmVudCcgaW4gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIExpc3RlbmVyVHJhY2tlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlID0gY2FwdHVyZTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGluY3JlbWVudCgpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgRE9NLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUsIHRoaXMubGlzdGVuZXIsIG51bGwsIHRoaXMuY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjcmVtZW50KCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy5saXN0ZW5lciwgbnVsbCwgdGhpcy5jYXB0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgZGlzcG9zZSgpIHBhdHRlcm4gZm9yIGBkZWxlZ2F0ZWAgJiBgY2FwdHVyZWAgY29tbWFuZHNcbiAgICAgKi9cbiAgICBjbGFzcyBEZWxlZ2F0ZU9yQ2FwdHVyZVN1YnNjcmlwdGlvbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGVudHJ5LCBsb29rdXAsIHRhcmdldEV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5lbnRyeSA9IGVudHJ5O1xuICAgICAgICAgICAgdGhpcy5sb29rdXAgPSBsb29rdXA7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEV2ZW50ID0gdGFyZ2V0RXZlbnQ7XG4gICAgICAgICAgICBsb29rdXBbdGFyZ2V0RXZlbnRdID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXMuZW50cnkuZGVjcmVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmxvb2t1cFt0aGlzLnRhcmdldEV2ZW50XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGRpc3Bvc2UoKSBwYXR0ZXJuIGZvciBhZGRFdmVudExpc3RlbmVyIGZvciBgdHJpZ2dlcmBcbiAgICAgKi9cbiAgICBjbGFzcyBUcmlnZ2VyU3Vic2NyaXB0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IodGFyZ2V0LCB0YXJnZXRFdmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFdmVudCA9IHRhcmdldEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgRE9NLmFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0RXZlbnQsIGNhbGxiYWNrLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICBET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLnRhcmdldEV2ZW50LCB0aGlzLmNhbGxiYWNrLCB0aGlzLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKGZ1bmN0aW9uIChEZWxlZ2F0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgRGVsZWdhdGlvblN0cmF0ZWd5W0RlbGVnYXRpb25TdHJhdGVneVtcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xuICAgICAgICBEZWxlZ2F0aW9uU3RyYXRlZ3lbRGVsZWdhdGlvblN0cmF0ZWd5W1wiY2FwdHVyaW5nXCJdID0gMV0gPSBcImNhcHR1cmluZ1wiO1xuICAgICAgICBEZWxlZ2F0aW9uU3RyYXRlZ3lbRGVsZWdhdGlvblN0cmF0ZWd5W1wiYnViYmxpbmdcIl0gPSAyXSA9IFwiYnViYmxpbmdcIjtcbiAgICB9KShleHBvcnRzLkRlbGVnYXRpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5EZWxlZ2F0aW9uU3RyYXRlZ3kgPSB7fSkpO1xuICAgIGNsYXNzIEV2ZW50U3Vic2NyaWJlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlKG5vZGUsIGNhbGxiYWNrT3JMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gY2FsbGJhY2tPckxpc3RlbmVyO1xuICAgICAgICAgICAgY29uc3QgYWRkID0gRE9NLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLmV2ZW50cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGV2ZW50cy5sZW5ndGg7IGlpID4gaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgYWRkKGV2ZW50c1tpXSwgY2FsbGJhY2tPckxpc3RlbmVyLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkaXNwb3NlKCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tPckxpc3RlbmVyID0gdGhpcy5oYW5kbGVyO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgICAgICAgICBjb25zdCByZW1vdmUgPSBET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGV2ZW50cy5sZW5ndGg7IGlpID4gaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKGV2ZW50c1tpXSwgY2FsbGJhY2tPckxpc3RlbmVyLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBJRXZlbnRNYW5hZ2VyID0ga2VybmVsLkRJLmNyZWF0ZUludGVyZmFjZSgpXG4gICAgICAgIC53aXRoRGVmYXVsdCh4ID0+IHguc2luZ2xldG9uKEV2ZW50TWFuYWdlcikpO1xuICAgIC8qQGludGVybmFsKi9cbiAgICBjbGFzcyBFdmVudE1hbmFnZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudEhhbmRsZXJMb29rdXAgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVkSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZWRIYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckVsZW1lbnRDb25maWd1cmF0aW9uKHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnSU5QVVQnLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFsnY2hhbmdlJywgJ2lucHV0J10sXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IFsnY2hhbmdlJywgJ2lucHV0J10sXG4gICAgICAgICAgICAgICAgICAgIGZpbGVzOiBbJ2NoYW5nZScsICdpbnB1dCddXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRWxlbWVudENvbmZpZ3VyYXRpb24oe1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdURVhUQVJFQScsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWydjaGFuZ2UnLCAnaW5wdXQnXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckVsZW1lbnRDb25maWd1cmF0aW9uKHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnU0VMRUNUJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbJ2NoYW5nZSddXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRWxlbWVudENvbmZpZ3VyYXRpb24oe1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdjb250ZW50IGVkaXRhYmxlJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbJ2NoYW5nZScsICdpbnB1dCcsICdibHVyJywgJ2tleXVwJywgJ3Bhc3RlJ11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJFbGVtZW50Q29uZmlndXJhdGlvbih7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3Njcm9sbGFibGUgZWxlbWVudCcsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IFsnc2Nyb2xsJ10sXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQ6IFsnc2Nyb2xsJ11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlckVsZW1lbnRDb25maWd1cmF0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGNvbmZpZy5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5lbGVtZW50SGFuZGxlckxvb2t1cFtjb25maWcudGFnTmFtZV0gPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRFbGVtZW50SGFuZGxlcih0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRhcmdldFsndGFnTmFtZSddO1xuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5lbGVtZW50SGFuZGxlckxvb2t1cDtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2t1cFt0YWdOYW1lXSAmJiBsb29rdXBbdGFnTmFtZV1bcHJvcGVydHlOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U3Vic2NyaWJlcihsb29rdXBbdGFnTmFtZV1bcHJvcGVydHlOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICd0ZXh0Q29udGVudCcgfHwgcHJvcGVydHlOYW1lID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U3Vic2NyaWJlcihsb29rdXBbJ2NvbnRlbnQgZWRpdGFibGUnXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdzY3JvbGxUb3AnIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3Njcm9sbExlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTdWJzY3JpYmVyKGxvb2t1cFsnc2Nyb2xsYWJsZSBlbGVtZW50J11bcHJvcGVydHlOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXQsIHRhcmdldEV2ZW50LCBjYWxsYmFja09yTGlzdGVuZXIsIHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBsZXQgZGVsZWdhdGVkSGFuZGxlcnM7XG4gICAgICAgICAgICBsZXQgY2FwdHVyZWRIYW5kbGVycztcbiAgICAgICAgICAgIGxldCBoYW5kbGVyRW50cnk7XG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kgPT09IGV4cG9ydHMuRGVsZWdhdGlvblN0cmF0ZWd5LmJ1YmJsaW5nKSB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGVkSGFuZGxlcnMgPSB0aGlzLmRlbGVnYXRlZEhhbmRsZXJzO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJFbnRyeSA9IGRlbGVnYXRlZEhhbmRsZXJzW3RhcmdldEV2ZW50XSB8fCAoZGVsZWdhdGVkSGFuZGxlcnNbdGFyZ2V0RXZlbnRdID0gbmV3IExpc3RlbmVyVHJhY2tlcih0YXJnZXRFdmVudCwgaGFuZGxlRGVsZWdhdGVkRXZlbnQsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlckVudHJ5LmluY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGVnYXRlZENhbGxiYWNrcyA9IHRhcmdldC5kZWxlZ2F0ZWRDYWxsYmFja3MgfHwgKHRhcmdldC5kZWxlZ2F0ZWRDYWxsYmFja3MgPSB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWxlZ2F0ZU9yQ2FwdHVyZVN1YnNjcmlwdGlvbihoYW5kbGVyRW50cnksIGRlbGVnYXRlZENhbGxiYWNrcywgdGFyZ2V0RXZlbnQsIGNhbGxiYWNrT3JMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kgPT09IGV4cG9ydHMuRGVsZWdhdGlvblN0cmF0ZWd5LmNhcHR1cmluZykge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVkSGFuZGxlcnMgPSB0aGlzLmNhcHR1cmVkSGFuZGxlcnM7XG4gICAgICAgICAgICAgICAgaGFuZGxlckVudHJ5ID0gY2FwdHVyZWRIYW5kbGVyc1t0YXJnZXRFdmVudF0gfHwgKGNhcHR1cmVkSGFuZGxlcnNbdGFyZ2V0RXZlbnRdID0gbmV3IExpc3RlbmVyVHJhY2tlcih0YXJnZXRFdmVudCwgaGFuZGxlQ2FwdHVyZWRFdmVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJFbnRyeS5pbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlZENhbGxiYWNrcyA9IHRhcmdldC5jYXB0dXJlZENhbGxiYWNrcyB8fCAodGFyZ2V0LmNhcHR1cmVkQ2FsbGJhY2tzID0ge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVsZWdhdGVPckNhcHR1cmVTdWJzY3JpcHRpb24oaGFuZGxlckVudHJ5LCBjYXB0dXJlZENhbGxiYWNrcywgdGFyZ2V0RXZlbnQsIGNhbGxiYWNrT3JMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyaWdnZXJTdWJzY3JpcHRpb24odGFyZ2V0LCB0YXJnZXRFdmVudCwgY2FsbGJhY2tPckxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiBoYW5kbGVTZWxmRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZmluZE9yaWdpbmFsRXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGZFdmVudENhbGxTb3VyY2UoZXZlbnQpO1xuICAgIH1cbiAgICBleHBvcnRzLlNlbGZCaW5kaW5nQmVoYXZpb3IgPSBjbGFzcyBTZWxmQmluZGluZ0JlaGF2aW9yIHtcbiAgICAgICAgYmluZChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGlmICghYmluZGluZy5jYWxsU291cmNlIHx8ICFiaW5kaW5nLnRhcmdldEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZGluZy5zZWxmRXZlbnRDYWxsU291cmNlID0gYmluZGluZy5jYWxsU291cmNlO1xuICAgICAgICAgICAgYmluZGluZy5jYWxsU291cmNlID0gaGFuZGxlU2VsZkV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIHVuYmluZChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGJpbmRpbmcuY2FsbFNvdXJjZSA9IGJpbmRpbmcuc2VsZkV2ZW50Q2FsbFNvdXJjZTtcbiAgICAgICAgICAgIGJpbmRpbmcuc2VsZkV2ZW50Q2FsbFNvdXJjZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuU2VsZkJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBiaW5kaW5nQmVoYXZpb3IoJ3NlbGYnKVxuICAgIF0sIGV4cG9ydHMuU2VsZkJpbmRpbmdCZWhhdmlvcik7XG5cbiAgICBleHBvcnRzLlNpZ25hbEJpbmRpbmdCZWhhdmlvciA9IGNsYXNzIFNpZ25hbEJpbmRpbmdCZWhhdmlvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHNpZ25hbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbGVyID0gc2lnbmFsZXI7XG4gICAgICAgIH1cbiAgICAgICAgYmluZChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGlmICghYmluZGluZy51cGRhdGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsZXIuYWRkU2lnbmFsTGlzdGVuZXIobmFtZSwgYmluZGluZyk7XG4gICAgICAgICAgICAgICAgYmluZGluZy5zaWduYWwgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBuYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsZXIuYWRkU2lnbmFsTGlzdGVuZXIobmFtZSwgYmluZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmcuc2lnbmFsID0gbmFtZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVuYmluZChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBiaW5kaW5nLnNpZ25hbDtcbiAgICAgICAgICAgIGJpbmRpbmcuc2lnbmFsID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGxldCBpID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYWxlci5yZW1vdmVTaWduYWxMaXN0ZW5lcihuYW1lc1tpXSwgYmluZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWxlci5yZW1vdmVTaWduYWxMaXN0ZW5lcihuYW1lLCBiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5TaWduYWxCaW5kaW5nQmVoYXZpb3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgYmluZGluZ0JlaGF2aW9yKCdzaWduYWwnKSxcbiAgICAgICAga2VybmVsLmluamVjdChJU2lnbmFsZXIpXG4gICAgXSwgZXhwb3J0cy5TaWduYWxCaW5kaW5nQmVoYXZpb3IpO1xuXG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKG5ld1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy50aHJvdHRsZVN0YXRlO1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gK25ldyBEYXRlKCkgLSBzdGF0ZS5sYXN0O1xuICAgICAgICBpZiAoZWxhcHNlZCA+PSBzdGF0ZS5kZWxheSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICBzdGF0ZS50aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUubGFzdCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWRNZXRob2QobmV3VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm5ld1ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGlmIChzdGF0ZS50aW1lb3V0SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUubGFzdCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkTWV0aG9kKHN0YXRlLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0sIHN0YXRlLmRlbGF5IC0gZWxhcHNlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5UaHJvdHRsZUJpbmRpbmdCZWhhdmlvciA9IGNsYXNzIFRocm90dGxlQmluZGluZ0JlaGF2aW9yIHtcbiAgICAgICAgYmluZChmbGFncywgc2NvcGUsIGJpbmRpbmcsIGRlbGF5ID0gMjAwKSB7XG4gICAgICAgICAgICBsZXQgbWV0aG9kVG9UaHJvdHRsZTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nIGluc3RhbmNlb2YgZXhwb3J0cy5CaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcubW9kZSA9PT0gZXhwb3J0cy5CaW5kaW5nTW9kZS50d29XYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVG9UaHJvdHRsZSA9ICd1cGRhdGVTb3VyY2UnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVG9UaHJvdHRsZSA9ICd1cGRhdGVUYXJnZXQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFRvVGhyb3R0bGUgPSAnY2FsbFNvdXJjZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGFzaCB0aGUgb3JpZ2luYWwgbWV0aG9kIGFuZCBpdCdzIG5hbWUuXG4gICAgICAgICAgICAvLyBub3RlOiBhIGdlbmVyaWMgbmFtZSBsaWtlIFwib3JpZ2luYWxNZXRob2RcIiBpcyBub3QgdXNlZCB0byBhdm9pZCBjb2xsaXNpb25zXG4gICAgICAgICAgICAvLyB3aXRoIG90aGVyIGJpbmRpbmcgYmVoYXZpb3IgdHlwZXMuXG4gICAgICAgICAgICBiaW5kaW5nLnRocm90dGxlZE1ldGhvZCA9IGJpbmRpbmdbbWV0aG9kVG9UaHJvdHRsZV07XG4gICAgICAgICAgICBiaW5kaW5nLnRocm90dGxlZE1ldGhvZC5vcmlnaW5hbE5hbWUgPSBtZXRob2RUb1Rocm90dGxlO1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgb3JpZ2luYWwgbWV0aG9kIHdpdGggdGhlIHRocm90dGxpbmcgdmVyc2lvbi5cbiAgICAgICAgICAgIGJpbmRpbmdbbWV0aG9kVG9UaHJvdHRsZV0gPSB0aHJvdHRsZTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdGhyb3R0bGUgc3RhdGUuXG4gICAgICAgICAgICBiaW5kaW5nLnRocm90dGxlU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgICAgICAgICAgIGxhc3Q6IDAsXG4gICAgICAgICAgICAgICAgdGltZW91dElkOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHVuYmluZChmbGFncywgc2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBiaW5kaW5nLlxuICAgICAgICAgICAgY29uc3QgbWV0aG9kVG9SZXN0b3JlID0gYmluZGluZy50aHJvdHRsZWRNZXRob2Qub3JpZ2luYWxOYW1lO1xuICAgICAgICAgICAgYmluZGluZ1ttZXRob2RUb1Jlc3RvcmVdID0gYmluZGluZy50aHJvdHRsZWRNZXRob2Q7XG4gICAgICAgICAgICBiaW5kaW5nLnRocm90dGxlZE1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoYmluZGluZy50aHJvdHRsZVN0YXRlLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICBiaW5kaW5nLnRocm90dGxlU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLlRocm90dGxlQmluZGluZ0JlaGF2aW9yID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGJpbmRpbmdCZWhhdmlvcigndGhyb3R0bGUnKVxuICAgIF0sIGV4cG9ydHMuVGhyb3R0bGVCaW5kaW5nQmVoYXZpb3IpO1xuXG4gICAgZnVuY3Rpb24gZmx1c2gkMSgpIHtcbiAgICAgICAgdGhpcy5jYWxsQmF0Y2hlZFN1YnNjcmliZXJzKHRoaXMuaW5kZXhNYXApO1xuICAgICAgICB0aGlzLnJlc2V0SW5kZXhNYXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZSQyKCkge1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24uJG9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmluZGV4TWFwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRJbmRleE1hcEluZGV4ZWQoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gKHRoaXMuaW5kZXhNYXAgPSBBcnJheShsZW4pKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zID0gW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SW5kZXhNYXBLZXllZCgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5jb2xsZWN0aW9uLnNpemU7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gKHRoaXMuaW5kZXhNYXAgPSBBcnJheShsZW4pKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zID0gW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExlbmd0aE9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGhPYnNlcnZlciB8fCAodGhpcy5sZW5ndGhPYnNlcnZlciA9IG5ldyBleHBvcnRzLkNvbGxlY3Rpb25MZW5ndGhPYnNlcnZlcih0aGlzLCB0aGlzLmxlbmd0aFByb3BlcnR5TmFtZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2xsZWN0aW9uT2JzZXJ2ZXIoa2luZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlckNvbGxlY3Rpb24oZXhwb3J0cy5NdXRhdGlvbktpbmQuY29sbGVjdGlvbikodGFyZ2V0KTtcbiAgICAgICAgICAgIGJhdGNoZWRTdWJzY3JpYmVyQ29sbGVjdGlvbigpKHRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBwcm90by4kbmV4dEZsdXNoID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLmNvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uaW5kZXhNYXAgPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgcHJvdG8ubGVuZ3RoUHJvcGVydHlOYW1lID0ga2luZCAmIDggLyogaW5kZXhlZCAqLyA/ICdsZW5ndGgnIDogJ3NpemUnO1xuICAgICAgICAgICAgcHJvdG8uY29sbGVjdGlvbktpbmQgPSBraW5kO1xuICAgICAgICAgICAgcHJvdG8ucmVzZXRJbmRleE1hcCA9IGtpbmQgJiA4IC8qIGluZGV4ZWQgKi8gPyByZXNldEluZGV4TWFwSW5kZXhlZCA6IHJlc2V0SW5kZXhNYXBLZXllZDtcbiAgICAgICAgICAgIHByb3RvLmZsdXNoID0gZmx1c2gkMTtcbiAgICAgICAgICAgIHByb3RvLmRpc3Bvc2UgPSBkaXNwb3NlJDI7XG4gICAgICAgICAgICBwcm90by5nZXRMZW5ndGhPYnNlcnZlciA9IGdldExlbmd0aE9ic2VydmVyO1xuICAgICAgICAgICAgcHJvdG8uc3Vic2NyaWJlID0gcHJvdG8uc3Vic2NyaWJlIHx8IHByb3RvLmFkZFN1YnNjcmliZXI7XG4gICAgICAgICAgICBwcm90by51bnN1YnNjcmliZSA9IHByb3RvLnVuc3Vic2NyaWJlIHx8IHByb3RvLnJlbW92ZVN1YnNjcmliZXI7XG4gICAgICAgICAgICBwcm90by5zdWJzY3JpYmVCYXRjaGVkID0gcHJvdG8uc3Vic2NyaWJlQmF0Y2hlZCB8fCBwcm90by5hZGRCYXRjaGVkU3Vic2NyaWJlcjtcbiAgICAgICAgICAgIHByb3RvLnVuc3Vic2NyaWJlQmF0Y2hlZCA9IHByb3RvLnVuc3Vic2NyaWJlQmF0Y2hlZCB8fCBwcm90by5yZW1vdmVCYXRjaGVkU3Vic2NyaWJlcjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXhwb3J0cy5Db2xsZWN0aW9uTGVuZ3RoT2JzZXJ2ZXIgPSBjbGFzcyBDb2xsZWN0aW9uTGVuZ3RoT2JzZXJ2ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihvYmosIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gb2JqW3Byb3BlcnR5S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUNvcmUobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuQ29sbGVjdGlvbkxlbmd0aE9ic2VydmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRhcmdldE9ic2VydmVyKClcbiAgICBdLCBleHBvcnRzLkNvbGxlY3Rpb25MZW5ndGhPYnNlcnZlcik7XG5cbiAgICBjb25zdCBwcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgICBjb25zdCBuYXRpdmVQdXNoID0gcHJvdG8ucHVzaDsgLy8gVE9ETzogcHJvYmFibHkgd2FudCB0byBtYWtlIHRoZXNlIGludGVybmFsIGFnYWluXG4gICAgY29uc3QgbmF0aXZlVW5zaGlmdCA9IHByb3RvLnVuc2hpZnQ7XG4gICAgY29uc3QgbmF0aXZlUG9wID0gcHJvdG8ucG9wO1xuICAgIGNvbnN0IG5hdGl2ZVNoaWZ0ID0gcHJvdG8uc2hpZnQ7XG4gICAgY29uc3QgbmF0aXZlU3BsaWNlID0gcHJvdG8uc3BsaWNlO1xuICAgIGNvbnN0IG5hdGl2ZVJldmVyc2UgPSBwcm90by5yZXZlcnNlO1xuICAgIGNvbnN0IG5hdGl2ZVNvcnQgPSBwcm90by5zb3J0O1xuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5wdXNoXG4gICAgZnVuY3Rpb24gb2JzZXJ2ZVB1c2goKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLiRvYnNlcnZlcjtcbiAgICAgICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggPSBvLmluZGV4TWFwLmxlbmd0aCA9IGxlbiArIGFyZ0NvdW50O1xuICAgICAgICBsZXQgaSA9IGxlbjtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpc1tpXSA9IGFyZ3VtZW50c1tpIC0gbGVuXTtcbiAgICAgICAgICAgIG8uaW5kZXhNYXBbaV0gPSAtMjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBvLmNhbGxTdWJzY3JpYmVycygncHVzaCcsIGFyZ3VtZW50cywgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5pc0NvbGxlY3Rpb25NdXRhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnVuc2hpZnRcbiAgICBmdW5jdGlvbiBvYnNlcnZlVW5zaGlmdCgpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuJG9ic2VydmVyO1xuICAgICAgICBpZiAobyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlVW5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaW5zZXJ0cyA9IG5ldyBBcnJheShhcmdDb3VudCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBhcmdDb3VudCkge1xuICAgICAgICAgICAgaW5zZXJ0c1tpKytdID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgbmF0aXZlVW5zaGlmdC5hcHBseShvLmluZGV4TWFwLCBpbnNlcnRzKTtcbiAgICAgICAgY29uc3QgbGVuID0gbmF0aXZlVW5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBvLmNhbGxTdWJzY3JpYmVycygndW5zaGlmdCcsIGFyZ3VtZW50cywgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5pc0NvbGxlY3Rpb25NdXRhdGlvbik7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5wb3BcbiAgICBmdW5jdGlvbiBvYnNlcnZlUG9wKCkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVQb3AuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleE1hcCA9IG8uaW5kZXhNYXA7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuYXRpdmVQb3AuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gb25seSBtYXJrIGluZGljZXMgYXMgZGVsZXRlZCBpZiB0aGV5IGFjdHVhbGx5IGV4aXN0ZWQgaW4gdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhNYXAubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4TWFwW2luZGV4XSA+IC0xKSB7XG4gICAgICAgICAgICBuYXRpdmVQdXNoLmNhbGwoaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBuYXRpdmVQb3AuY2FsbChpbmRleE1hcCk7XG4gICAgICAgIG8uY2FsbFN1YnNjcmliZXJzKCdwb3AnLCBhcmd1bWVudHMsIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuaXNDb2xsZWN0aW9uTXV0YXRpb24pO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNoaWZ0XG4gICAgZnVuY3Rpb24gb2JzZXJ2ZVNoaWZ0KCkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVTaGlmdC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gby5pbmRleE1hcDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG5hdGl2ZVNoaWZ0LmNhbGwodGhpcyk7XG4gICAgICAgIC8vIG9ubHkgbWFyayBpbmRpY2VzIGFzIGRlbGV0ZWQgaWYgdGhleSBhY3R1YWxseSBleGlzdGVkIGluIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgICAgICBpZiAoaW5kZXhNYXBbMF0gPiAtMSkge1xuICAgICAgICAgICAgbmF0aXZlUHVzaC5jYWxsKGluZGV4TWFwLmRlbGV0ZWRJdGVtcywgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbmF0aXZlU2hpZnQuY2FsbChpbmRleE1hcCk7XG4gICAgICAgIG8uY2FsbFN1YnNjcmliZXJzKCdzaGlmdCcsIGFyZ3VtZW50cywgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5pc0NvbGxlY3Rpb25NdXRhdGlvbik7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXG4gICAgZnVuY3Rpb24gb2JzZXJ2ZVNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuJG9ic2VydmVyO1xuICAgICAgICBpZiAobyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlU3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBvLmluZGV4TWFwO1xuICAgICAgICBpZiAoZGVsZXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IGlzTmFOKHN0YXJ0KSA/IDAgOiBzdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHRvID0gaSArIGRlbGV0ZUNvdW50O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0bykge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE1hcFtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVB1c2guY2FsbChpbmRleE1hcC5kZWxldGVkSXRlbXMsIHRoaXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnQ291bnQgPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQ291bnQgPSBhcmdDb3VudCAtIDI7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRzID0gbmV3IEFycmF5KGl0ZW1Db3VudCk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGl0ZW1Db3VudCkge1xuICAgICAgICAgICAgICAgIGluc2VydHNbaSsrXSA9IC0yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF0aXZlU3BsaWNlLmNhbGwoaW5kZXhNYXAsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaW5zZXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAgIG5hdGl2ZVNwbGljZS5jYWxsKGluZGV4TWFwLCBzdGFydCwgZGVsZXRlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBuYXRpdmVTcGxpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgby5jYWxsU3Vic2NyaWJlcnMoJ3NwbGljZScsIGFyZ3VtZW50cywgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5pc0NvbGxlY3Rpb25NdXRhdGlvbik7XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH1cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmV2ZXJzZVxuICAgIGZ1bmN0aW9uIG9ic2VydmVSZXZlcnNlKCkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSZXZlcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IChsZW4gLyAyKSB8IDA7XG4gICAgICAgIGxldCBsb3dlciA9IDA7XG4gICAgICAgIHdoaWxlIChsb3dlciAhPT0gbWlkZGxlKSB7XG4gICAgICAgICAgICBjb25zdCB1cHBlciA9IGxlbiAtIGxvd2VyIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyVmFsdWUgPSB0aGlzW2xvd2VyXTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VySW5kZXggPSBvLmluZGV4TWFwW2xvd2VyXTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyVmFsdWUgPSB0aGlzW3VwcGVyXTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVySW5kZXggPSBvLmluZGV4TWFwW3VwcGVyXTtcbiAgICAgICAgICAgIHRoaXNbbG93ZXJdID0gdXBwZXJWYWx1ZTtcbiAgICAgICAgICAgIG8uaW5kZXhNYXBbbG93ZXJdID0gdXBwZXJJbmRleDtcbiAgICAgICAgICAgIHRoaXNbdXBwZXJdID0gbG93ZXJWYWx1ZTtcbiAgICAgICAgICAgIG8uaW5kZXhNYXBbdXBwZXJdID0gbG93ZXJJbmRleDtcbiAgICAgICAgICAgIGxvd2VyKys7XG4gICAgICAgIH1cbiAgICAgICAgby5jYWxsU3Vic2NyaWJlcnMoJ3JldmVyc2UnLCBhcmd1bWVudHMsIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuaXNDb2xsZWN0aW9uTXV0YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi9tYXN0ZXIvc3JjL2pzL2FycmF5LmpzXG4gICAgZnVuY3Rpb24gb2JzZXJ2ZVNvcnQoY29tcGFyZUZuKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLiRvYnNlcnZlcjtcbiAgICAgICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVNvcnQuY2FsbCh0aGlzLCBjb21wYXJlRm4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcXVpY2tTb3J0KHRoaXMsIG8uaW5kZXhNYXAsIDAsIGxlbiwgcHJlU29ydENvbXBhcmUpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVGbiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBjb21wYXJlRm4gIT09ICdmdW5jdGlvbicgLypzcGVjIHNheXMgdGhyb3cgYSBUeXBlRXJyb3IsIHNob3VsZCB3ZSBkbyB0aGF0IHRvbz8qLykge1xuICAgICAgICAgICAgY29tcGFyZUZuID0gc29ydENvbXBhcmU7XG4gICAgICAgIH1cbiAgICAgICAgcXVpY2tTb3J0KHRoaXMsIG8uaW5kZXhNYXAsIDAsIGksIGNvbXBhcmVGbik7XG4gICAgICAgIG8uY2FsbFN1YnNjcmliZXJzKCdzb3J0JywgYXJndW1lbnRzLCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmlzQ29sbGVjdGlvbk11dGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNvcnRjb21wYXJlXG4gICAgZnVuY3Rpb24gc29ydENvbXBhcmUoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IHggPT09IG51bGwgPyAnbnVsbCcgOiB4LnRvU3RyaW5nKCk7XG4gICAgICAgIHkgPSB5ID09PSBudWxsID8gJ251bGwnIDogeS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4geCA8IHkgPyAtMSA6IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZVNvcnRDb21wYXJlKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGFyciwgaW5kZXhNYXAsIGZyb21JbmRleCwgdG9JbmRleCwgY29tcGFyZUZuKSB7XG4gICAgICAgIGxldCB2ZWxlbWVudCwgaWVsZW1lbnQsIHZ0bXAsIGl0bXAsIG9yZGVyO1xuICAgICAgICBsZXQgaSwgajtcbiAgICAgICAgZm9yIChpID0gZnJvbUluZGV4ICsgMTsgaSA8IHRvSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdmVsZW1lbnQgPSBhcnJbaV07XG4gICAgICAgICAgICBpZWxlbWVudCA9IGluZGV4TWFwW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gZnJvbUluZGV4OyBqLS0pIHtcbiAgICAgICAgICAgICAgICB2dG1wID0gYXJyW2pdO1xuICAgICAgICAgICAgICAgIGl0bXAgPSBpbmRleE1hcFtqXTtcbiAgICAgICAgICAgICAgICBvcmRlciA9IGNvbXBhcmVGbih2dG1wLCB2ZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnJbaiArIDFdID0gdnRtcDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXBbaiArIDFdID0gaXRtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycltqICsgMV0gPSB2ZWxlbWVudDtcbiAgICAgICAgICAgIGluZGV4TWFwW2ogKyAxXSA9IGllbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1aWNrU29ydChhcnIsIGluZGV4TWFwLCBmcm9tSW5kZXgsIHRvSW5kZXgsIGNvbXBhcmVGbikge1xuICAgICAgICBsZXQgdGhpcmRJbmRleCA9IDAsIGkgPSAwO1xuICAgICAgICBsZXQgdjAsIHYxLCB2MjtcbiAgICAgICAgbGV0IGkwLCBpMSwgaTI7XG4gICAgICAgIGxldCBjMDEsIGMwMiwgYzEyO1xuICAgICAgICBsZXQgdnRtcCwgaXRtcDtcbiAgICAgICAgbGV0IHZwaXZvdCwgaXBpdm90LCBsb3dFbmQsIGhpZ2hTdGFydDtcbiAgICAgICAgbGV0IHZlbGVtZW50LCBpZWxlbWVudCwgb3JkZXIsIHZ0b3BFbGVtZW50O1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodG9JbmRleCAtIGZyb21JbmRleCA8PSAxMCkge1xuICAgICAgICAgICAgICAgIGluc2VydGlvblNvcnQoYXJyLCBpbmRleE1hcCwgZnJvbUluZGV4LCB0b0luZGV4LCBjb21wYXJlRm4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXJkSW5kZXggPSBmcm9tSW5kZXggKyAoKHRvSW5kZXggLSBmcm9tSW5kZXgpID4+IDEpO1xuICAgICAgICAgICAgdjAgPSBhcnJbZnJvbUluZGV4XTtcbiAgICAgICAgICAgIGkwID0gaW5kZXhNYXBbZnJvbUluZGV4XTtcbiAgICAgICAgICAgIHYxID0gYXJyW3RvSW5kZXggLSAxXTtcbiAgICAgICAgICAgIGkxID0gaW5kZXhNYXBbdG9JbmRleCAtIDFdO1xuICAgICAgICAgICAgdjIgPSBhcnJbdGhpcmRJbmRleF07XG4gICAgICAgICAgICBpMiA9IGluZGV4TWFwW3RoaXJkSW5kZXhdO1xuICAgICAgICAgICAgYzAxID0gY29tcGFyZUZuKHYwLCB2MSk7XG4gICAgICAgICAgICBpZiAoYzAxID4gMCkge1xuICAgICAgICAgICAgICAgIHZ0bXAgPSB2MDtcbiAgICAgICAgICAgICAgICBpdG1wID0gaTA7XG4gICAgICAgICAgICAgICAgdjAgPSB2MTtcbiAgICAgICAgICAgICAgICBpMCA9IGkxO1xuICAgICAgICAgICAgICAgIHYxID0gdnRtcDtcbiAgICAgICAgICAgICAgICBpMSA9IGl0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjMDIgPSBjb21wYXJlRm4odjAsIHYyKTtcbiAgICAgICAgICAgIGlmIChjMDIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZ0bXAgPSB2MDtcbiAgICAgICAgICAgICAgICBpdG1wID0gaTA7XG4gICAgICAgICAgICAgICAgdjAgPSB2MjtcbiAgICAgICAgICAgICAgICBpMCA9IGkyO1xuICAgICAgICAgICAgICAgIHYyID0gdjE7XG4gICAgICAgICAgICAgICAgaTIgPSBpMTtcbiAgICAgICAgICAgICAgICB2MSA9IHZ0bXA7XG4gICAgICAgICAgICAgICAgaTEgPSBpdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYzEyID0gY29tcGFyZUZuKHYxLCB2Mik7XG4gICAgICAgICAgICAgICAgaWYgKGMxMiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdnRtcCA9IHYxO1xuICAgICAgICAgICAgICAgICAgICBpdG1wID0gaTE7XG4gICAgICAgICAgICAgICAgICAgIHYxID0gdjI7XG4gICAgICAgICAgICAgICAgICAgIGkxID0gaTI7XG4gICAgICAgICAgICAgICAgICAgIHYyID0gdnRtcDtcbiAgICAgICAgICAgICAgICAgICAgaTIgPSBpdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycltmcm9tSW5kZXhdID0gdjA7XG4gICAgICAgICAgICBpbmRleE1hcFtmcm9tSW5kZXhdID0gaTA7XG4gICAgICAgICAgICBhcnJbdG9JbmRleCAtIDFdID0gdjI7XG4gICAgICAgICAgICBpbmRleE1hcFt0b0luZGV4IC0gMV0gPSBpMjtcbiAgICAgICAgICAgIHZwaXZvdCA9IHYxO1xuICAgICAgICAgICAgaXBpdm90ID0gaTE7XG4gICAgICAgICAgICBsb3dFbmQgPSBmcm9tSW5kZXggKyAxO1xuICAgICAgICAgICAgaGlnaFN0YXJ0ID0gdG9JbmRleCAtIDE7XG4gICAgICAgICAgICBhcnJbdGhpcmRJbmRleF0gPSBhcnJbbG93RW5kXTtcbiAgICAgICAgICAgIGluZGV4TWFwW3RoaXJkSW5kZXhdID0gaW5kZXhNYXBbbG93RW5kXTtcbiAgICAgICAgICAgIGFycltsb3dFbmRdID0gdnBpdm90O1xuICAgICAgICAgICAgaW5kZXhNYXBbbG93RW5kXSA9IGlwaXZvdDtcbiAgICAgICAgICAgIHBhcnRpdGlvbjogZm9yIChpID0gbG93RW5kICsgMTsgaSA8IGhpZ2hTdGFydDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVsZW1lbnQgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgaWVsZW1lbnQgPSBpbmRleE1hcFtpXTtcbiAgICAgICAgICAgICAgICBvcmRlciA9IGNvbXBhcmVGbih2ZWxlbWVudCwgdnBpdm90KTtcbiAgICAgICAgICAgICAgICBpZiAob3JkZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycltpXSA9IGFycltsb3dFbmRdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcFtpXSA9IGluZGV4TWFwW2xvd0VuZF07XG4gICAgICAgICAgICAgICAgICAgIGFycltsb3dFbmRdID0gdmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwW2xvd0VuZF0gPSBpZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbG93RW5kKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yZGVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoU3RhcnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0cmlwbGUtZXF1YWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaFN0YXJ0ID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBwYXJ0aXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2dG9wRWxlbWVudCA9IGFycltoaWdoU3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSBjb21wYXJlRm4odnRvcEVsZW1lbnQsIHZwaXZvdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKG9yZGVyID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIGFycltpXSA9IGFycltoaWdoU3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcFtpXSA9IGluZGV4TWFwW2hpZ2hTdGFydF07XG4gICAgICAgICAgICAgICAgICAgIGFycltoaWdoU3RhcnRdID0gdmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwW2hpZ2hTdGFydF0gPSBpZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVsZW1lbnQgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZWxlbWVudCA9IGluZGV4TWFwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldID0gYXJyW2xvd0VuZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleE1hcFtpXSA9IGluZGV4TWFwW2xvd0VuZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbbG93RW5kXSA9IHZlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXBbbG93RW5kXSA9IGllbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93RW5kKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9JbmRleCAtIGhpZ2hTdGFydCA8IGxvd0VuZCAtIGZyb21JbmRleCkge1xuICAgICAgICAgICAgICAgIHF1aWNrU29ydChhcnIsIGluZGV4TWFwLCBoaWdoU3RhcnQsIHRvSW5kZXgsIGNvbXBhcmVGbik7XG4gICAgICAgICAgICAgICAgdG9JbmRleCA9IGxvd0VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1aWNrU29ydChhcnIsIGluZGV4TWFwLCBmcm9tSW5kZXgsIGxvd0VuZCwgY29tcGFyZUZuKTtcbiAgICAgICAgICAgICAgICBmcm9tSW5kZXggPSBoaWdoU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvYnNlcnZlIG9mIFtvYnNlcnZlUHVzaCwgb2JzZXJ2ZVVuc2hpZnQsIG9ic2VydmVQb3AsIG9ic2VydmVTaGlmdCwgb2JzZXJ2ZVNwbGljZSwgb2JzZXJ2ZVJldmVyc2UsIG9ic2VydmVTb3J0XSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JzZXJ2ZSwgJ29ic2VydmluZycsIHsgdmFsdWU6IHRydWUsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuYWJsZUFycmF5T2JzZXJ2YXRpb24oKSB7XG4gICAgICAgIGlmIChwcm90by5wdXNoWydvYnNlcnZpbmcnXSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvLnB1c2ggPSBvYnNlcnZlUHVzaDtcbiAgICAgICAgaWYgKHByb3RvLnVuc2hpZnRbJ29ic2VydmluZyddICE9PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8udW5zaGlmdCA9IG9ic2VydmVVbnNoaWZ0O1xuICAgICAgICBpZiAocHJvdG8ucG9wWydvYnNlcnZpbmcnXSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvLnBvcCA9IG9ic2VydmVQb3A7XG4gICAgICAgIGlmIChwcm90by5zaGlmdFsnb2JzZXJ2aW5nJ10gIT09IHRydWUpXG4gICAgICAgICAgICBwcm90by5zaGlmdCA9IG9ic2VydmVTaGlmdDtcbiAgICAgICAgaWYgKHByb3RvLnNwbGljZVsnb2JzZXJ2aW5nJ10gIT09IHRydWUpXG4gICAgICAgICAgICBwcm90by5zcGxpY2UgPSBvYnNlcnZlU3BsaWNlO1xuICAgICAgICBpZiAocHJvdG8ucmV2ZXJzZVsnb2JzZXJ2aW5nJ10gIT09IHRydWUpXG4gICAgICAgICAgICBwcm90by5yZXZlcnNlID0gb2JzZXJ2ZVJldmVyc2U7XG4gICAgICAgIGlmIChwcm90by5zb3J0WydvYnNlcnZpbmcnXSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvLnNvcnQgPSBvYnNlcnZlU29ydDtcbiAgICB9XG4gICAgZW5hYmxlQXJyYXlPYnNlcnZhdGlvbigpO1xuICAgIGZ1bmN0aW9uIGRpc2FibGVBcnJheU9ic2VydmF0aW9uKCkge1xuICAgICAgICBpZiAocHJvdG8ucHVzaFsnb2JzZXJ2aW5nJ10gPT09IHRydWUpXG4gICAgICAgICAgICBwcm90by5wdXNoID0gbmF0aXZlUHVzaDtcbiAgICAgICAgaWYgKHByb3RvLnVuc2hpZnRbJ29ic2VydmluZyddID09PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8udW5zaGlmdCA9IG5hdGl2ZVVuc2hpZnQ7XG4gICAgICAgIGlmIChwcm90by5wb3BbJ29ic2VydmluZyddID09PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8ucG9wID0gbmF0aXZlUG9wO1xuICAgICAgICBpZiAocHJvdG8uc2hpZnRbJ29ic2VydmluZyddID09PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8uc2hpZnQgPSBuYXRpdmVTaGlmdDtcbiAgICAgICAgaWYgKHByb3RvLnNwbGljZVsnb2JzZXJ2aW5nJ10gPT09IHRydWUpXG4gICAgICAgICAgICBwcm90by5zcGxpY2UgPSBuYXRpdmVTcGxpY2U7XG4gICAgICAgIGlmIChwcm90by5yZXZlcnNlWydvYnNlcnZpbmcnXSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvLnJldmVyc2UgPSBuYXRpdmVSZXZlcnNlO1xuICAgICAgICBpZiAocHJvdG8uc29ydFsnb2JzZXJ2aW5nJ10gPT09IHRydWUpXG4gICAgICAgICAgICBwcm90by5zb3J0ID0gbmF0aXZlU29ydDtcbiAgICB9XG4gICAgZXhwb3J0cy5BcnJheU9ic2VydmVyID0gY2xhc3MgQXJyYXlPYnNlcnZlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxpZmVjeWNsZSwgYXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMubGlmZWN5Y2xlID0gbGlmZWN5Y2xlO1xuICAgICAgICAgICAgYXJyYXkuJG9ic2VydmVyID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGFycmF5O1xuICAgICAgICAgICAgdGhpcy5yZXNldEluZGV4TWFwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuQXJyYXlPYnNlcnZlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb2xsZWN0aW9uT2JzZXJ2ZXIoOSAvKiBhcnJheSAqLylcbiAgICBdLCBleHBvcnRzLkFycmF5T2JzZXJ2ZXIpO1xuICAgIGZ1bmN0aW9uIGdldEFycmF5T2JzZXJ2ZXIobGlmZWN5Y2xlLCBhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXkuJG9ic2VydmVyIHx8IG5ldyBleHBvcnRzLkFycmF5T2JzZXJ2ZXIobGlmZWN5Y2xlLCBhcnJheSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZWQoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICh0YXJnZXQuY29tcHV0ZWQgfHwgKHRhcmdldC5jb21wdXRlZCA9IHt9KSlba2V5XSA9IGNvbmZpZztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgbm9Qcm94eSA9ICEodHlwZW9mIFByb3h5ICE9PSB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGNvbXB1dGVkT3ZlcnJpZGVEZWZhdWx0cyA9IHsgc3RhdGljOiBmYWxzZSwgdm9sYXRpbGU6IGZhbHNlIH07XG4gICAgLyogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRPYnNlcnZlcihvYnNlcnZlckxvY2F0b3IsIGRpcnR5Q2hlY2tlciwgbGlmZWN5Y2xlLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tcmVzZXJ2ZWQta2V5d29yZHNcbiAgICBpbnN0YW5jZSwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXJ0eUNoZWNrZXIuY3JlYXRlUHJvcGVydHkoaW5zdGFuY2UsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZXMgPSBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5jb21wdXRlZFxuICAgICAgICAgICAgICAgID8gaW5zdGFuY2UuY29uc3RydWN0b3IuY29tcHV0ZWRbcHJvcGVydHlOYW1lXSB8fCBjb21wdXRlZE92ZXJyaWRlRGVmYXVsdHNcbiAgICAgICAgICAgICAgICA6IGNvbXB1dGVkT3ZlcnJpZGVEZWZhdWx0cztcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMudm9sYXRpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vUHJveHlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGlydHlDaGVja2VyLmNyZWF0ZVByb3BlcnR5KGluc3RhbmNlLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBleHBvcnRzLkdldHRlck9ic2VydmVyKG92ZXJyaWRlcywgaW5zdGFuY2UsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgb2JzZXJ2ZXJMb2NhdG9yLCBsaWZlY3ljbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuQ3VzdG9tU2V0dGVyT2JzZXJ2ZXIoaW5zdGFuY2UsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgbGlmZWN5Y2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub1Byb3h5XG4gICAgICAgICAgICAgICAgPyBkaXJ0eUNoZWNrZXIuY3JlYXRlUHJvcGVydHkoaW5zdGFuY2UsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICA6IG5ldyBleHBvcnRzLkdldHRlck9ic2VydmVyKG92ZXJyaWRlcywgaW5zdGFuY2UsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgb2JzZXJ2ZXJMb2NhdG9yLCBsaWZlY3ljbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxOCwgcHJvcGVydHlOYW1lKTtcbiAgICB9XG4gICAgLy8gVXNlZCB3aGVuIHRoZSBnZXR0ZXIgaXMgZGVwZW5kZW50IHNvbGVseSBvbiBjaGFuZ2VzIHRoYXQgaGFwcGVuIHdpdGhpbiB0aGUgc2V0dGVyLlxuICAgIGV4cG9ydHMuQ3VzdG9tU2V0dGVyT2JzZXJ2ZXIgPSBjbGFzcyBDdXN0b21TZXR0ZXJPYnNlcnZlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9iaiwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IsIGxpZmVjeWNsZSkge1xuICAgICAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgICAgICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLiRuZXh0Rmx1c2ggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaChmbGFncykge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLm9sZFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2FsbFN1YnNjcmliZXJzKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgZmxhZ3MgfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnVwZGF0ZVRhcmdldEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9ic2VydmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udmVydFByb3BlcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZFN1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpYmVyKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnZlcnRQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRlciA9IHRoaXMuZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV07XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub2JqLCB0aGlzLnByb3BlcnR5S2V5LCB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyLmNhbGwodGhhdC5vYmosIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUucXVldWVGbHVzaCh0aGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5DdXN0b21TZXR0ZXJPYnNlcnZlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBzdWJzY3JpYmVyQ29sbGVjdGlvbihleHBvcnRzLk11dGF0aW9uS2luZC5pbnN0YW5jZSlcbiAgICBdLCBleHBvcnRzLkN1c3RvbVNldHRlck9ic2VydmVyKTtcbiAgICBleHBvcnRzLkN1c3RvbVNldHRlck9ic2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0ga2VybmVsLlBMQVRGT1JNLm5vb3A7XG4gICAgLy8gVXNlZCB3aGVuIHRoZXJlIGlzIG5vIHNldHRlciwgYW5kIHRoZSBnZXR0ZXIgaXMgZGVwZW5kZW50IG9uIG90aGVyIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdDtcbiAgICAvLyBVc2VkIHdoZW4gdGhlcmUgaXMgYSBzZXR0ZXIgYnV0IHRoZSB2YWx1ZSBvZiB0aGUgZ2V0dGVyIGNhbiBjaGFuZ2UgYmFzZWQgb24gcHJvcGVydGllcyBzZXQgb3V0c2lkZSBvZiB0aGUgc2V0dGVyLlxuICAgIC8qQGludGVybmFsKi9cbiAgICBleHBvcnRzLkdldHRlck9ic2VydmVyID0gY2xhc3MgR2V0dGVyT2JzZXJ2ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihvdmVycmlkZXMsIG9iaiwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IsIG9ic2VydmVyTG9jYXRvciwgbGlmZWN5Y2xlKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgICAgICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICAgICAgdGhpcy5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgR2V0dGVyQ29udHJvbGxlcihvdmVycmlkZXMsIG9iaiwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IsIHRoaXMsIG9ic2VydmVyTG9jYXRvciwgbGlmZWN5Y2xlKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5XG4gICAgICAgIHNldFZhbHVlKG5ld1ZhbHVlKSB7IH1cbiAgICAgICAgZmx1c2goZmxhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5jb250cm9sbGVyLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmNvbnRyb2xsZXIuZ2V0VmFsdWVBbmRDb2xsZWN0RGVwZW5kZW5jaWVzKCk7XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsU3Vic2NyaWJlcnMobmV3VmFsdWUsIG9sZFZhbHVlLCBmbGFncyB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MudXBkYXRlVGFyZ2V0SW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFN1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIub25TdWJzY3JpYmVyQWRkZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIub25TdWJzY3JpYmVyUmVtb3ZlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkdldHRlck9ic2VydmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHN1YnNjcmliZXJDb2xsZWN0aW9uKGV4cG9ydHMuTXV0YXRpb25LaW5kLmluc3RhbmNlKVxuICAgIF0sIGV4cG9ydHMuR2V0dGVyT2JzZXJ2ZXIpO1xuICAgIGV4cG9ydHMuR2V0dGVyT2JzZXJ2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBrZXJuZWwuUExBVEZPUk0ubm9vcDtcbiAgICAvKkBpbnRlcm5hbCovXG4gICAgY2xhc3MgR2V0dGVyQ29udHJvbGxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG92ZXJyaWRlcywgaW5zdGFuY2UsIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvciwgb3duZXIsIG9ic2VydmVyTG9jYXRvciwgbGlmZWN5Y2xlKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICAgICAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLmlzQ29sbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlckNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLCBjcmVhdGVHZXR0ZXJUcmFwcyhvYnNlcnZlckxvY2F0b3IsIHRoaXMpKTtcbiAgICAgICAgICAgIGNvbnN0IGdldHRlciA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICAgICAgY29uc3QgY3RybCA9IHRoaXM7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwuc3Vic2NyaWJlckNvdW50IDwgMSB8fCBjdHJsLmlzQ29sbGVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC52YWx1ZSA9IGdldHRlci5hcHBseShwcm94eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0cmwudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGVwZW5kZW5jeShzdWJzY3JpYmFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5pbmNsdWRlcyhzdWJzY3JpYmFibGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMucHVzaChzdWJzY3JpYmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIG9uU3Vic2NyaWJlckFkZGVkKCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyQ291bnQrKztcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZXJDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdldFZhbHVlQW5kQ29sbGVjdERlcGVuZGVuY2llcyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZUFuZENvbGxlY3REZXBlbmRlbmNpZXMocmVxdWlyZUNvbGxlY3QgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0RlcGVuZGVuY2llcyA9ICF0aGlzLm92ZXJyaWRlcy5zdGF0aWMgfHwgcmVxdWlyZUNvbGxlY3Q7XG4gICAgICAgICAgICBpZiAoZHluYW1pY0RlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVBbGxEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnN0YW5jZVt0aGlzLnByb3BlcnR5TmFtZV07IC8vIHRyaWdnZXJzIG9ic2VydmVyIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIGlmIChkeW5hbWljRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKHggPT4geyB4LnN1YnNjcmliZSh0aGlzKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvblN1YnNjcmliZXJSZW1vdmVkKCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyQ291bnQtLTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZXJDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVBbGxEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgICAgICB0aGlzLmxpZmVjeWNsZS5lbnF1ZXVlRmx1c2godGhpcy5vd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgdW5zdWJzY3JpYmVBbGxEZXBlbmRlbmNpZXMoKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKHggPT4geyB4LnVuc3Vic2NyaWJlKHRoaXMpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlR2V0dGVyVHJhcHMob2JzZXJ2ZXJMb2NhdG9yLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChpbnN0YW5jZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnN0YW5jZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICckb2JzZXJ2ZXJzJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgIWNvbnRyb2xsZXIuaXNDb2xsZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZml4IHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFkZERlcGVuZGVuY3kob2JzZXJ2ZXJMb2NhdG9yLmdldEFycmF5T2JzZXJ2ZXIoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWRkRGVwZW5kZW5jeShvYnNlcnZlckxvY2F0b3IuZ2V0QXJyYXlPYnNlcnZlcihpbnN0YW5jZSkuZ2V0TGVuZ3RoT2JzZXJ2ZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hZGREZXBlbmRlbmN5KG9ic2VydmVyTG9jYXRvci5nZXRNYXBPYnNlcnZlcihpbnN0YW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnc2l6ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWRkRGVwZW5kZW5jeShvYnNlcnZlckxvY2F0b3IuZ2V0TWFwT2JzZXJ2ZXIoaW5zdGFuY2UpLmdldExlbmd0aE9ic2VydmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWRkRGVwZW5kZW5jeShvYnNlcnZlckxvY2F0b3IuZ2V0U2V0T2JzZXJ2ZXIoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NpemUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXJMb2NhdG9yLmdldFNldE9ic2VydmVyKGluc3RhbmNlKS5nZXRMZW5ndGhPYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFkZERlcGVuZGVuY3kob2JzZXJ2ZXJMb2NhdG9yLmdldE9ic2VydmVyKGluc3RhbmNlLCBrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5T3JWYWx1ZShvYnNlcnZlckxvY2F0b3IsIGNvbnRyb2xsZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJveHlPclZhbHVlKG9ic2VydmVyTG9jYXRvciwgY29udHJvbGxlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgY3JlYXRlR2V0dGVyVHJhcHMob2JzZXJ2ZXJMb2NhdG9yLCBjb250cm9sbGVyKSk7XG4gICAgfVxuXG4gICAgY29uc3QgSURpcnR5Q2hlY2tlciA9IGtlcm5lbC5ESS5jcmVhdGVJbnRlcmZhY2UoKVxuICAgICAgICAud2l0aERlZmF1bHQoeCA9PiB4LnNpbmdsZXRvbihEaXJ0eUNoZWNrZXIpKTtcbiAgICAvKkBpbnRlcm5hbCovXG4gICAgY2xhc3MgRGlydHlDaGVja2VyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZWQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEZWxheSA9IDEyMDtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkRpcnR5Q2hlY2tQcm9wZXJ0eSh0aGlzLCBvYmosIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrZWQgPSB0aGlzLnRyYWNrZWQ7XG4gICAgICAgICAgICB0cmFja2VkLnB1c2gocHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKHRyYWNrZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZURpcnR5Q2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICAgICAgY29uc3QgdHJhY2tlZCA9IHRoaXMudHJhY2tlZDtcbiAgICAgICAgICAgIHRyYWNrZWQuc3BsaWNlKHRyYWNrZWQuaW5kZXhPZihwcm9wZXJ0eSksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlRGlydHlDaGVjaygpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmNoZWNrKCk7IH0sIHRoaXMuY2hlY2tEZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja2VkID0gdGhpcy50cmFja2VkO1xuICAgICAgICAgICAgbGV0IGkgPSB0cmFja2VkLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdHJhY2tlZFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RpcnR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5mbHVzaChleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21GbHVzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNrZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZURpcnR5Q2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZXhwb3J0cy5EaXJ0eUNoZWNrUHJvcGVydHkgPSBjbGFzcyBEaXJ0eUNoZWNrUHJvcGVydHkge1xuICAgICAgICBjb25zdHJ1Y3RvcihkaXJ0eUNoZWNrZXIsIG9iaiwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHlDaGVja2VyID0gZGlydHlDaGVja2VyO1xuICAgICAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgaXNEaXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZFZhbHVlICE9PSB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaChmbGFncykge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLm9sZFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxTdWJzY3JpYmVycyhuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy51cGRhdGVUYXJnZXRJbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLm9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpYmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5Q2hlY2tlci5hZGRQcm9wZXJ0eSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW1vdmVTdWJzY3JpYmVyKHN1YnNjcmliZXIpICYmICF0aGlzLmhhc1N1YnNjcmliZXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5Q2hlY2tlci5yZW1vdmVQcm9wZXJ0eSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5EaXJ0eUNoZWNrUHJvcGVydHkgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHlPYnNlcnZlcigpXG4gICAgXSwgZXhwb3J0cy5EaXJ0eUNoZWNrUHJvcGVydHkpO1xuXG4gICAgY29uc3QgaW5wdXRWYWx1ZURlZmF1bHRzID0ge1xuICAgICAgICBbJ2J1dHRvbiddOiAnJyxcbiAgICAgICAgWydjaGVja2JveCddOiAnb24nLFxuICAgICAgICBbJ2NvbG9yJ106ICcjMDAwMDAwJyxcbiAgICAgICAgWydkYXRlJ106ICcnLFxuICAgICAgICBbJ2RhdGV0aW1lLWxvY2FsJ106ICcnLFxuICAgICAgICBbJ2VtYWlsJ106ICcnLFxuICAgICAgICBbJ2ZpbGUnXTogJycsXG4gICAgICAgIFsnaGlkZGVuJ106ICcnLFxuICAgICAgICBbJ2ltYWdlJ106ICcnLFxuICAgICAgICBbJ21vbnRoJ106ICcnLFxuICAgICAgICBbJ251bWJlciddOiAnJyxcbiAgICAgICAgWydwYXNzd29yZCddOiAnJyxcbiAgICAgICAgWydyYWRpbyddOiAnb24nLFxuICAgICAgICBbJ3JhbmdlJ106ICc1MCcsXG4gICAgICAgIFsncmVzZXQnXTogJycsXG4gICAgICAgIFsnc2VhcmNoJ106ICcnLFxuICAgICAgICBbJ3N1Ym1pdCddOiAnJyxcbiAgICAgICAgWyd0ZWwnXTogJycsXG4gICAgICAgIFsndGV4dCddOiAnJyxcbiAgICAgICAgWyd0aW1lJ106ICcnLFxuICAgICAgICBbJ3VybCddOiAnJyxcbiAgICAgICAgWyd3ZWVrJ106ICcnXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVFdmVudEZsYWdzID0gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tRE9NRXZlbnQgfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnVwZGF0ZVNvdXJjZUV4cHJlc3Npb247XG4gICAgZXhwb3J0cy5WYWx1ZUF0dHJpYnV0ZU9ic2VydmVyID0gY2xhc3MgVmFsdWVBdHRyaWJ1dGVPYnNlcnZlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxpZmVjeWNsZSwgb2JqLCBwcm9wZXJ0eUtleSwgaGFuZGxlcikge1xuICAgICAgICAgICAgLy8gbm90ZTogaW5wdXQuZmlsZXMgY2FuIGJlIGFzc2lnbmVkIGFuZCB0aGlzIHdhcyBmaXhlZCBpbiBGaXJlZm94IDU3OlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM4NDAzMFxuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgICAvLyBpbnB1dC52YWx1ZSAoZm9yIHR5cGU9J2ZpbGUnKSBob3dldmVyLCBjYW4gb25seSBiZSBhc3NpZ25lZCBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gb2JqWyd0eXBlJ107XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBpbnB1dFZhbHVlRGVmYXVsdHNbbm9kZVR5cGUgfHwgJ3RleHQnXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoID0gdGhpcy5mbHVzaEZpbGVDaGFuZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9sZFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWUgPSBvYmpbcHJvcGVydHlLZXldO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQ29yZShuZXdWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21CaW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsU3Vic2NyaWJlcnModGhpcy5jdXJyZW50VmFsdWUsIHRoaXMub2xkVmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVFdmVudCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5vbGRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdWJzY3JpYmVycyhuZXdWYWx1ZSwgb2xkVmFsdWUsIGhhbmRsZUV2ZW50RmxhZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmliZXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZFZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlci5zdWJzY3JpYmUodGhpcy5vYmosIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRTdWJzY3JpYmVyKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIHVuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZVN1YnNjcmliZXIoc3Vic2NyaWJlcikgJiYgIXRoaXMuaGFzU3Vic2NyaWJlcnMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmx1c2hGaWxlQ2hhbmdlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMub2xkVmFsdWUgIT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVDb3JlKGN1cnJlbnRWYWx1ZSwgdGhpcy5jdXJyZW50RmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9sZFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLlZhbHVlQXR0cmlidXRlT2JzZXJ2ZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIoJycpXG4gICAgXSwgZXhwb3J0cy5WYWx1ZUF0dHJpYnV0ZU9ic2VydmVyKTtcbiAgICBleHBvcnRzLlZhbHVlQXR0cmlidXRlT2JzZXJ2ZXIucHJvdG90eXBlLnByb3BlcnR5S2V5ID0gJyc7XG4gICAgZXhwb3J0cy5WYWx1ZUF0dHJpYnV0ZU9ic2VydmVyLnByb3RvdHlwZS5oYW5kbGVyID0gbnVsbDtcbiAgICBjb25zdCBkZWZhdWx0SGFuZGxlQmF0Y2hlZENoYW5nZUZsYWdzID0gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tRmx1c2ggfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnVwZGF0ZVRhcmdldEluc3RhbmNlO1xuICAgIGV4cG9ydHMuQ2hlY2tlZE9ic2VydmVyID0gY2xhc3MgQ2hlY2tlZE9ic2VydmVyIHtcbiAgICAgICAgY29uc3RydWN0b3IobGlmZWN5Y2xlLCBvYmosIGhhbmRsZXIsIG9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUNvcmUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsdWVPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVPYnNlcnZlciA9IHRoaXMub2JqWyckb2JzZXJ2ZXJzJ10gJiYgKHRoaXMub2JqWyckb2JzZXJ2ZXJzJ10ubW9kZWwgfHwgdGhpcy5vYmpbJyRvYnNlcnZlcnMnXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXIudW5zdWJzY3JpYmVCYXRjaGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXlPYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vYmoudHlwZSA9PT0gJ2NoZWNrYm94JyAmJiBBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXlPYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJMb2NhdG9yLmdldEFycmF5T2JzZXJ2ZXIobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXlPYnNlcnZlci5zdWJzY3JpYmVCYXRjaGVkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zeW5jaHJvbml6ZUVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGVCYXRjaGVkQ29sbGVjdGlvbkNoYW5nZSAodG9kbzogcmVuYW1lIHRvIG1ha2UgdGhpcyBleHBsaWNpdD8pXG4gICAgICAgIGhhbmRsZUJhdGNoZWRDaGFuZ2UoKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNocm9uaXplRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoZGVmYXVsdEhhbmRsZUJhdGNoZWRDaGFuZ2VGbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlUHJvcGVydHlDaGFuZ2UgKHRvZG86IHJlbmFtZSBub3JtYWwgc3Vic2NyaWJlIG1ldGhvZHMgaW4gdGFyZ2V0IG9ic2VydmVycyB0byBiYXRjaGVkLCBzaW5jZSB0aGF0J3Mgd2hhdCB0aGV5IHJlYWxseSBhcmUpXG4gICAgICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY2hyb25pemVFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgc3luY2hyb25pemVFbGVtZW50KCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLm9iajtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGVsZW1lbnQuaGFzT3duUHJvcGVydHkoJ21vZGVsJykgPyBlbGVtZW50Wydtb2RlbCddIDogZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGlzUmFkaW8gPSBlbGVtZW50LnR5cGUgPT09ICdyYWRpbyc7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gZWxlbWVudFsnbWF0Y2hlciddIHx8ICgoYSwgYikgPT4gYSA9PT0gYik7XG4gICAgICAgICAgICBpZiAoaXNSYWRpbykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9ICEhbWF0Y2hlcih2YWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jaGVja2VkID0gdmFsdWUuZmluZEluZGV4KGl0ZW0gPT4gISFtYXRjaGVyKGl0ZW0sIGVsZW1lbnRWYWx1ZSkpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vdGlmeShmbGFncykge1xuICAgICAgICAgICAgaWYgKGZsYWdzICYgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQmluZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsU3Vic2NyaWJlcnModGhpcy5jdXJyZW50VmFsdWUsIHRoaXMub2xkVmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVFdmVudCgpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMub2JqO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZWxlbWVudC5oYXNPd25Qcm9wZXJ0eSgnbW9kZWwnKSA/IGVsZW1lbnRbJ21vZGVsJ10gOiBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IGVsZW1lbnRbJ21hdGNoZXInXSB8fCBkZWZhdWx0TWF0Y2hlcjtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB2YWx1ZS5maW5kSW5kZXgoaXRlbSA9PiAhIW1hdGNoZXIoaXRlbSwgZWxlbWVudFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoZWNrZWQgJiYgaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWVsZW1lbnQuY2hlY2tlZCAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBleGlzdGluZyB2YWx1ZSBpcyBhcnJheSwgZG8gbm90IGludm9rZSBjYWxsYmFjayBhcyBvbmx5IHRoZSBhcnJheSBlbGVtZW50IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbGVtZW50LmNoZWNrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShoYW5kbGVFdmVudEZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmliZXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXIuc3Vic2NyaWJlKHRoaXMub2JqLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW1vdmVTdWJzY3JpYmVyKHN1YnNjcmliZXIpICYmICF0aGlzLmhhc1N1YnNjcmliZXJzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVuYmluZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXIudW5zdWJzY3JpYmVCYXRjaGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXlPYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkNoZWNrZWRPYnNlcnZlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0YXJnZXRPYnNlcnZlcigpXG4gICAgXSwgZXhwb3J0cy5DaGVja2VkT2JzZXJ2ZXIpO1xuICAgIGV4cG9ydHMuQ2hlY2tlZE9ic2VydmVyLnByb3RvdHlwZS5oYW5kbGVyID0gbnVsbDtcbiAgICBleHBvcnRzLkNoZWNrZWRPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZXJMb2NhdG9yID0gbnVsbDtcbiAgICBjb25zdCBjaGlsZE9ic2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0TWF0Y2hlcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH1cbiAgICBleHBvcnRzLlNlbGVjdFZhbHVlT2JzZXJ2ZXIgPSBjbGFzcyBTZWxlY3RWYWx1ZU9ic2VydmVyIHtcbiAgICAgICAgY29uc3RydWN0b3IobGlmZWN5Y2xlLCBvYmosIGhhbmRsZXIsIG9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUNvcmUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkgJiYgbmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9iai5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBudWxsIG9yIEFycmF5IGluc3RhbmNlcyBjYW4gYmUgYm91bmQgdG8gYSBtdWx0aS1zZWxlY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheU9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheU9ic2VydmVyLnVuc3Vic2NyaWJlQmF0Y2hlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyTG9jYXRvci5nZXRBcnJheU9ic2VydmVyKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXIuc3Vic2NyaWJlQmF0Y2hlZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3luY2hyb25pemVPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIGFycmF5IG11dGF0ZWQgKGl0ZW1zIHNvcnRlZC9hZGRlZC9yZW1vdmVkLCBldGMpXG4gICAgICAgIGhhbmRsZUJhdGNoZWRDaGFuZ2UoaW5kZXhNYXApIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsIHNldFZhbHVlIGxvZ2ljIGFuZCBjYW4gZGlyZWN0bHkgY2FsbCBzeW5jaHJvbml6ZU9wdGlvbnMgaGVyZSxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGNoYW5nZSBhbHJlYWR5IHdhaXRlZCBvbmUgdGljayAoYmF0Y2hlZCkgYW5kIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gY2FsbGluZyBub3RpZnkgd2hlbiB0aGUgaW5zdGFuY2UgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgdGhpcy5zeW5jaHJvbml6ZU9wdGlvbnMoaW5kZXhNYXApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIGEgZGlmZmVyZW50IHZhbHVlIHdhcyBhc3NpZ25lZFxuICAgICAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21CaW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLm9sZFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbGxTdWJzY3JpYmVycyhuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVFdmVudCgpIHtcbiAgICAgICAgICAgIC8vIFwiZnJvbS12aWV3XCIgY2hhbmdlcyBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIG5vdywgc28gaW1tZWRpYXRlbHkgc3luYyB0aGUgdmFsdWUgYW5kIG5vdGlmeSBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkTm90aWZ5ID0gdGhpcy5zeW5jaHJvbml6ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoaGFuZGxlRXZlbnRGbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY2hyb25pemVPcHRpb25zKGluZGV4TWFwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLm9iajtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXIgPSBvYmoubWF0Y2hlciB8fCBkZWZhdWx0TWF0Y2hlcjtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBvYmoub3B0aW9ucztcbiAgICAgICAgICAgIGxldCBpID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSgnbW9kZWwnKSA/IG9wdGlvbi5tb2RlbCA6IG9wdGlvbi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBjdXJyZW50VmFsdWUuZmluZEluZGV4KGl0ZW0gPT4gISFtYXRjaGVyKG9wdGlvblZhbHVlLCBpdGVtKSkgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gISFtYXRjaGVyKG9wdGlvblZhbHVlLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5bmNocm9uaXplVmFsdWUoKSB7XG4gICAgICAgICAgICAvLyBTcGVjIGZvciBzeW5jaHJvbml6aW5nIHZhbHVlIGZyb20gYFNlbGVjdE9ic2VydmVyYCB0byBgPHNlbGVjdC8+YFxuICAgICAgICAgICAgLy8gV2hlbiBzeW5jaHJvbml6aW5nIHZhbHVlIHRvIG9ic2VydmVkIDxzZWxlY3QvPiBlbGVtZW50LCBkbyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgICAgICAgICAgLy8gQS4gSWYgYDxzZWxlY3QvPmAgaXMgbXVsdGlwbGVcbiAgICAgICAgICAgIC8vICAgIDEuIENoZWNrIGlmIGN1cnJlbnQgdmFsdWUsIGNhbGxlZCBgY3VycmVudFZhbHVlYCBpcyBhbiBhcnJheVxuICAgICAgICAgICAgLy8gICAgICBhLiBJZiBub3QgYW4gYXJyYXksIHJldHVybiB0cnVlIHRvIHNpZ25hbCB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgLy8gICAgICBiLiBJZiBpcyBhbiBhcnJheTpcbiAgICAgICAgICAgIC8vICAgICAgICBpLiBnYXRoZXIgYWxsIGN1cnJlbnQgc2VsZWN0ZWQgPG9wdGlvbi8+LCBpbiB0byBhcnJheSBjYWxsZWQgYHZhbHVlc2BcbiAgICAgICAgICAgIC8vICAgICAgICBpaS4gbG9vcCB0aHJvdWdoIHRoZSBgY3VycmVudFZhbHVlYCBhcnJheSBhbmQgcmVtb3ZlIGl0ZW1zIHRoYXQgYXJlIG5vbG9uZ2VyIHNlbGVjdGVkIGJhc2VkIG9uIG1hdGNoZXJcbiAgICAgICAgICAgIC8vICAgICAgICBpaWkuIGxvb3AgdGhyb3VnaCB0aGUgYHZhbHVlc2AgYXJyYXkgYW5kIGFkZCBpdGVtcyB0aGF0IGFyZSBzZWxlY3RlZCBiYXNlZCBvbiBtYXRjaGVyXG4gICAgICAgICAgICAvLyAgICAgICAgaXYuIFJldHVybiBmYWxzZSB0byBzaWduYWwgdmFsdWUgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgIC8vIEIuIElmIHRoZSBzZWxlY3QgaXMgc2luZ2xlXG4gICAgICAgICAgICAvLyAgICAxLiBMZXQgYHZhbHVlYCBlcXVhbCB0aGUgZmlyc3Qgc2VsZWN0ZWQgb3B0aW9uLCBpZiBubyBvcHRpb24gc2VsZWN0ZWQsIHRoZW4gYHZhbHVlYCBpcyBgbnVsbGBcbiAgICAgICAgICAgIC8vICAgIDIuIGFzc2lnbiBgdGhpcy5jdXJyZW50VmFsdWVgIHRvIGB0aGlzLm9sZFZhbHVlYFxuICAgICAgICAgICAgLy8gICAgMy4gYXNzaWduIGB2YWx1ZWAgdG8gYHRoaXMuY3VycmVudFZhbHVlYFxuICAgICAgICAgICAgLy8gICAgNC4gcmV0dXJuIGB0cnVlYCB0byBzaWduYWwgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG9iai5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGlmIChvYmoubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBLlxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEuMS5hXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBLjEuYlxuICAgICAgICAgICAgICAgIC8vIG11bHRpIHNlbGVjdFxuICAgICAgICAgICAgICAgIGxldCBvcHRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IG9iai5tYXRjaGVyIHx8IGRlZmF1bHRNYXRjaGVyO1xuICAgICAgICAgICAgICAgIC8vIEEuMS5iLmlcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChvcHRpb24uaGFzT3duUHJvcGVydHkoJ21vZGVsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbi5tb2RlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEuMS5iLmlpXG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBjdXJyZW50VmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZG86IHJlbW92ZSBhcnJvdyBmblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmZpbmRJbmRleChiID0+ICEhbWF0Y2hlcihhLCBiKSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEuMS5iLmlpaVxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBUb2RvOiByZW1vdmUgYXJyb3cgZm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZS5maW5kSW5kZXgoYiA9PiAhIW1hdGNoZXIoYSwgYikpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBLjEuYi5pdlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEIuIHNpbmdsZSBzZWxlY3RcbiAgICAgICAgICAgIC8vIEIuMVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0aW9uLmhhc093blByb3BlcnR5KCdtb2RlbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbi5tb2RlbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCLjJcbiAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIC8vIEIuM1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIEIuNFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpYmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnN1YnNjcmliZSh0aGlzLm9iaiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZFN1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlU3Vic2NyaWJlcihzdWJzY3JpYmVyKSAmJiAhdGhpcy5oYXNTdWJzY3JpYmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiaW5kKCkge1xuICAgICAgICAgICAgdGhpcy5ub2RlT2JzZXJ2ZXIgPSBET00uY3JlYXRlTm9kZU9ic2VydmVyKHRoaXMub2JqLCB0aGlzLmhhbmRsZU5vZGVDaGFuZ2UuYmluZCh0aGlzKSwgY2hpbGRPYnNlcnZlck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHVuYmluZCgpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXIudW5zdWJzY3JpYmVCYXRjaGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXlPYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlTm9kZUNoYW5nZSgpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY2hyb25pemVPcHRpb25zKCk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGROb3RpZnkgPSB0aGlzLnN5bmNocm9uaXplVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShoYW5kbGVFdmVudEZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5TZWxlY3RWYWx1ZU9ic2VydmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRhcmdldE9ic2VydmVyKClcbiAgICBdLCBleHBvcnRzLlNlbGVjdFZhbHVlT2JzZXJ2ZXIpO1xuICAgIGV4cG9ydHMuU2VsZWN0VmFsdWVPYnNlcnZlci5wcm90b3R5cGUuaGFuZGxlciA9IG51bGw7XG4gICAgZXhwb3J0cy5TZWxlY3RWYWx1ZU9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlckxvY2F0b3IgPSBudWxsO1xuXG4gICAgY29uc3QgcHJvdG8kMSA9IE1hcC5wcm90b3R5cGU7XG4gICAgY29uc3QgbmF0aXZlU2V0ID0gcHJvdG8kMS5zZXQ7IC8vIFRPRE86IHByb2JhYmx5IHdhbnQgdG8gbWFrZSB0aGVzZSBpbnRlcm5hbCBhZ2FpblxuICAgIGNvbnN0IG5hdGl2ZUNsZWFyID0gcHJvdG8kMS5jbGVhcjtcbiAgICBjb25zdCBuYXRpdmVEZWxldGUgPSBwcm90byQxLmRlbGV0ZTtcbiAgICAvLyBub3RlOiB3ZSBjYW4ndCByZWFsbHkgZG8gbXVjaCB3aXRoIE1hcCBkdWUgdG8gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlIG5vdCBiZWluZyBhY2Nlc3NpYmxlIHNvIHdlJ3JlIGp1c3QgdXNpbmcgdGhlIG5hdGl2ZSBjYWxsc1xuICAgIC8vIGZvcnR1bmF0ZWx5LCBtYXAvZGVsZXRlL2NsZWFyIGFyZSBlYXN5IHRvIHJlY29uc3RydWN0IGZvciB0aGUgaW5kZXhNYXBcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLm1hcFxuICAgIGZ1bmN0aW9uIG9ic2VydmVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgICAgICBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKG5ld1NpemUgPT09IG9sZFNpemUpIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnlbMV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmluZGV4TWFwW2ldID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG8uaW5kZXhNYXBbb2xkU2l6ZV0gPSAtMjtcbiAgICAgICAgby5jYWxsU3Vic2NyaWJlcnMoJ3NldCcsIGFyZ3VtZW50cywgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5pc0NvbGxlY3Rpb25NdXRhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmNsZWFyXG4gICAgZnVuY3Rpb24gb2JzZXJ2ZUNsZWFyKCkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVDbGVhci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBvLmluZGV4TWFwO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE1hcFtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVB1c2guY2FsbChpbmRleE1hcC5kZWxldGVkSXRlbXMsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF0aXZlQ2xlYXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGluZGV4TWFwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBvLmNhbGxTdWJzY3JpYmVycygnY2xlYXInLCBhcmd1bWVudHMsIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuaXNDb2xsZWN0aW9uTXV0YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZGVsZXRlXG4gICAgZnVuY3Rpb24gb2JzZXJ2ZURlbGV0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVEZWxldGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gby5pbmRleE1hcDtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE1hcFtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVB1c2guY2FsbChpbmRleE1hcC5kZWxldGVkSXRlbXMsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmF0aXZlU3BsaWNlLmNhbGwoaW5kZXhNYXAsIGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVEZWxldGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgby5jYWxsU3Vic2NyaWJlcnMoJ2RlbGV0ZScsIGFyZ3VtZW50cywgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5pc0NvbGxlY3Rpb25NdXRhdGlvbik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvYnNlcnZlIG9mIFtvYnNlcnZlU2V0LCBvYnNlcnZlQ2xlYXIsIG9ic2VydmVEZWxldGVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYnNlcnZlLCAnb2JzZXJ2aW5nJywgeyB2YWx1ZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5hYmxlTWFwT2JzZXJ2YXRpb24oKSB7XG4gICAgICAgIGlmIChwcm90byQxLnNldFsnb2JzZXJ2aW5nJ10gIT09IHRydWUpXG4gICAgICAgICAgICBwcm90byQxLnNldCA9IG9ic2VydmVTZXQ7XG4gICAgICAgIGlmIChwcm90byQxLmNsZWFyWydvYnNlcnZpbmcnXSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvJDEuY2xlYXIgPSBvYnNlcnZlQ2xlYXI7XG4gICAgICAgIGlmIChwcm90byQxLmRlbGV0ZVsnb2JzZXJ2aW5nJ10gIT09IHRydWUpXG4gICAgICAgICAgICBwcm90byQxLmRlbGV0ZSA9IG9ic2VydmVEZWxldGU7XG4gICAgfVxuICAgIGVuYWJsZU1hcE9ic2VydmF0aW9uKCk7XG4gICAgZnVuY3Rpb24gZGlzYWJsZU1hcE9ic2VydmF0aW9uKCkge1xuICAgICAgICBpZiAocHJvdG8kMS5zZXRbJ29ic2VydmluZyddID09PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8kMS5zZXQgPSBuYXRpdmVTZXQ7XG4gICAgICAgIGlmIChwcm90byQxLmNsZWFyWydvYnNlcnZpbmcnXSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvJDEuY2xlYXIgPSBuYXRpdmVDbGVhcjtcbiAgICAgICAgaWYgKHByb3RvJDEuZGVsZXRlWydvYnNlcnZpbmcnXSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvJDEuZGVsZXRlID0gbmF0aXZlRGVsZXRlO1xuICAgIH1cbiAgICBleHBvcnRzLk1hcE9ic2VydmVyID0gY2xhc3MgTWFwT2JzZXJ2ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihsaWZlY3ljbGUsIG1hcCkge1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICBtYXAuJG9ic2VydmVyID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IG1hcDtcbiAgICAgICAgICAgIHRoaXMucmVzZXRJbmRleE1hcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLk1hcE9ic2VydmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbGxlY3Rpb25PYnNlcnZlcig2IC8qIG1hcCAqLylcbiAgICBdLCBleHBvcnRzLk1hcE9ic2VydmVyKTtcbiAgICBmdW5jdGlvbiBnZXRNYXBPYnNlcnZlcihsaWZlY3ljbGUsIG1hcCkge1xuICAgICAgICByZXR1cm4gbWFwLiRvYnNlcnZlciB8fCBuZXcgZXhwb3J0cy5NYXBPYnNlcnZlcihsaWZlY3ljbGUsIG1hcCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG8kMiA9IFNldC5wcm90b3R5cGU7XG4gICAgY29uc3QgbmF0aXZlQWRkID0gcHJvdG8kMi5hZGQ7IC8vIFRPRE86IHByb2JhYmx5IHdhbnQgdG8gbWFrZSB0aGVzZSBpbnRlcm5hbCBhZ2FpblxuICAgIGNvbnN0IG5hdGl2ZUNsZWFyJDEgPSBwcm90byQyLmNsZWFyO1xuICAgIGNvbnN0IG5hdGl2ZURlbGV0ZSQxID0gcHJvdG8kMi5kZWxldGU7XG4gICAgLy8gbm90ZTogd2UgY2FuJ3QgcmVhbGx5IGRvIG11Y2ggd2l0aCBTZXQgZHVlIHRvIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSBub3QgYmVpbmcgYWNjZXNzaWJsZSBzbyB3ZSdyZSBqdXN0IHVzaW5nIHRoZSBuYXRpdmUgY2FsbHNcbiAgICAvLyBmb3J0dW5hdGVseSwgYWRkL2RlbGV0ZS9jbGVhciBhcmUgZWFzeSB0byByZWNvbnN0cnVjdCBmb3IgdGhlIGluZGV4TWFwXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5hZGRcbiAgICBmdW5jdGlvbiBvYnNlcnZlQWRkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLiRvYnNlcnZlcjtcbiAgICAgICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUFkZC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgICAgICBuYXRpdmVBZGQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmIChuZXdTaXplID09PSBvbGRTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvLmluZGV4TWFwW29sZFNpemVdID0gLTI7XG4gICAgICAgIG8uY2FsbFN1YnNjcmliZXJzKCdhZGQnLCBhcmd1bWVudHMsIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuaXNDb2xsZWN0aW9uTXV0YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5jbGVhclxuICAgIGZ1bmN0aW9uIG9ic2VydmVDbGVhciQxKCkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVDbGVhciQxLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleE1hcCA9IG8uaW5kZXhNYXA7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwW2ldID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlUHVzaC5jYWxsKGluZGV4TWFwLmRlbGV0ZWRJdGVtcywgZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXRpdmVDbGVhciQxLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpbmRleE1hcC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgby5jYWxsU3Vic2NyaWJlcnMoJ2NsZWFyJywgYXJndW1lbnRzLCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmlzQ29sbGVjdGlvbk11dGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgIGZ1bmN0aW9uIG9ic2VydmVEZWxldGUkMSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy4kb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVEZWxldGUkMS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBvLmluZGV4TWFwO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwW2ldID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlUHVzaC5jYWxsKGluZGV4TWFwLmRlbGV0ZWRJdGVtcywgZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYXRpdmVTcGxpY2UuY2FsbChpbmRleE1hcCwgaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZURlbGV0ZSQxLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIG8uY2FsbFN1YnNjcmliZXJzKCdkZWxldGUnLCBhcmd1bWVudHMsIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuaXNDb2xsZWN0aW9uTXV0YXRpb24pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZSBvZiBbb2JzZXJ2ZUFkZCwgb2JzZXJ2ZUNsZWFyJDEsIG9ic2VydmVEZWxldGUkMV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9ic2VydmUsICdvYnNlcnZpbmcnLCB7IHZhbHVlOiB0cnVlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmFibGVTZXRPYnNlcnZhdGlvbigpIHtcbiAgICAgICAgaWYgKHByb3RvJDIuYWRkWydvYnNlcnZpbmcnXSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvJDIuYWRkID0gb2JzZXJ2ZUFkZDtcbiAgICAgICAgaWYgKHByb3RvJDIuY2xlYXJbJ29ic2VydmluZyddICE9PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8kMi5jbGVhciA9IG9ic2VydmVDbGVhciQxO1xuICAgICAgICBpZiAocHJvdG8kMi5kZWxldGVbJ29ic2VydmluZyddICE9PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8kMi5kZWxldGUgPSBvYnNlcnZlRGVsZXRlJDE7XG4gICAgfVxuICAgIGVuYWJsZVNldE9ic2VydmF0aW9uKCk7XG4gICAgZnVuY3Rpb24gZGlzYWJsZVNldE9ic2VydmF0aW9uKCkge1xuICAgICAgICBpZiAocHJvdG8kMi5hZGRbJ29ic2VydmluZyddID09PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8kMi5hZGQgPSBuYXRpdmVBZGQ7XG4gICAgICAgIGlmIChwcm90byQyLmNsZWFyWydvYnNlcnZpbmcnXSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHByb3RvJDIuY2xlYXIgPSBuYXRpdmVDbGVhciQxO1xuICAgICAgICBpZiAocHJvdG8kMi5kZWxldGVbJ29ic2VydmluZyddID09PSB0cnVlKVxuICAgICAgICAgICAgcHJvdG8kMi5kZWxldGUgPSBuYXRpdmVEZWxldGUkMTtcbiAgICB9XG4gICAgZXhwb3J0cy5TZXRPYnNlcnZlciA9IGNsYXNzIFNldE9ic2VydmVyIHtcbiAgICAgICAgY29uc3RydWN0b3IobGlmZWN5Y2xlLCBvYnNlcnZlZFNldCkge1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICBvYnNlcnZlZFNldC4kb2JzZXJ2ZXIgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gb2JzZXJ2ZWRTZXQ7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SW5kZXhNYXAoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5TZXRPYnNlcnZlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb2xsZWN0aW9uT2JzZXJ2ZXIoNyAvKiBzZXQgKi8pXG4gICAgXSwgZXhwb3J0cy5TZXRPYnNlcnZlcik7XG4gICAgZnVuY3Rpb24gZ2V0U2V0T2JzZXJ2ZXIobGlmZWN5Y2xlLCBvYnNlcnZlZFNldCkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZWRTZXQuJG9ic2VydmVyIHx8IG5ldyBleHBvcnRzLlNldE9ic2VydmVyKGxpZmVjeWNsZSwgb2JzZXJ2ZWRTZXQpO1xuICAgIH1cblxuICAgIGNvbnN0IElTVkdBbmFseXplciA9IGtlcm5lbC5ESS5jcmVhdGVJbnRlcmZhY2UoKVxuICAgICAgICAud2l0aERlZmF1bHQoeCA9PiB4LnNpbmdsZXRvbihjbGFzcyB7XG4gICAgICAgIGlzU3RhbmRhcmRTdmdBdHRyaWJ1dGUobm9kZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgY29uc3QgdG9TdHJpbmdUYWckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgY29uc3QgSU9ic2VydmVyTG9jYXRvciA9IGtlcm5lbC5ESS5jcmVhdGVJbnRlcmZhY2UoKVxuICAgICAgICAud2l0aERlZmF1bHQoeCA9PiB4LnNpbmdsZXRvbihleHBvcnRzLk9ic2VydmVyTG9jYXRvcikpO1xuICAgIGZ1bmN0aW9uIGdldFByb3BlcnR5RGVzY3JpcHRvcihzdWJqZWN0LCBuYW1lKSB7XG4gICAgICAgIGxldCBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3ViamVjdCwgbmFtZSk7XG4gICAgICAgIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzdWJqZWN0KTtcbiAgICAgICAgd2hpbGUgKHBkID09PSB1bmRlZmluZWQgJiYgcHJvdG8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbmFtZSk7XG4gICAgICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBkO1xuICAgIH1cbiAgICBleHBvcnRzLk9ic2VydmVyTG9jYXRvciA9IFxuICAgIC8qQGludGVybmFsKi9cbiAgICBjbGFzcyBPYnNlcnZlckxvY2F0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihsaWZlY3ljbGUsIGV2ZW50TWFuYWdlciwgZGlydHlDaGVja2VyLCBzdmdBbmFseXplcikge1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgICAgIHRoaXMuZGlydHlDaGVja2VyID0gZGlydHlDaGVja2VyO1xuICAgICAgICAgICAgdGhpcy5zdmdBbmFseXplciA9IHN2Z0FuYWx5emVyO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGdldE9ic2VydmVyKG9iaiwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICBpZiAob2JqLiRzeW50aGV0aWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLmdldE9ic2VydmVycygpLmdldE9yQ3JlYXRlKG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvYnNlcnZlcnNMb29rdXAgPSBvYmouJG9ic2VydmVycztcbiAgICAgICAgICAgIGxldCBvYnNlcnZlcjtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlcnNMb29rdXAgJiYgcHJvcGVydHlOYW1lIGluIG9ic2VydmVyc0xvb2t1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlcnNMb29rdXBbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ic2VydmVyID0gdGhpcy5jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGlmICghb2JzZXJ2ZXIuZG9Ob3RDYWNoZSkge1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlcnNMb29rdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcnNMb29rdXAgPSB0aGlzLmdldE9yQ3JlYXRlT2JzZXJ2ZXJzTG9va3VwKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9ic2VydmVyc0xvb2t1cFtwcm9wZXJ0eU5hbWVdID0gb2JzZXJ2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQWRhcHRlcihhZGFwdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXJzLnB1c2goYWRhcHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QWNjZXNzb3Iob2JqLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChET00uaXNOb2RlSW5zdGFuY2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBvYmpbJ3RhZ05hbWUnXTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoZWNrIGNvbWVzIGZpcnN0IGZvciBob3QgcGF0aCBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5FbGVtZW50UHJvcGVydHlBY2Nlc3Nvcih0aGlzLmxpZmVjeWNsZSwgb2JqLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSBhbmQgbWFrZSBwbHVnZ2FibGVcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSAnY2xhc3MnIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3N0eWxlJyB8fCBwcm9wZXJ0eU5hbWUgPT09ICdjc3MnXG4gICAgICAgICAgICAgICAgICAgIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyAmJiAodGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YWdOYW1lID09PSAnU0VMRUNUJylcbiAgICAgICAgICAgICAgICAgICAgfHwgcHJvcGVydHlOYW1lID09PSAnY2hlY2tlZCcgJiYgdGFnTmFtZSA9PT0gJ0lOUFVUJ1xuICAgICAgICAgICAgICAgICAgICB8fCBwcm9wZXJ0eU5hbWUgPT09ICdtb2RlbCcgJiYgdGFnTmFtZSA9PT0gJ0lOUFVUJ1xuICAgICAgICAgICAgICAgICAgICB8fCAvXnhsaW5rOi4rJC8uZXhlYyhwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ic2VydmVyKG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9eXFx3Kzp8XmRhdGEtfF5hcmlhLS8udGVzdChwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHx8IHRoaXMuc3ZnQW5hbHl6ZXIuaXNTdGFuZGFyZFN2Z0F0dHJpYnV0ZShvYmosIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgdGFnTmFtZSA9PT0gJ0lNRycgJiYgcHJvcGVydHlOYW1lID09PSAnc3JjJ1xuICAgICAgICAgICAgICAgICAgICB8fCB0YWdOYW1lID09PSAnQScgJiYgcHJvcGVydHlOYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGFBdHRyaWJ1dGVBY2Nlc3Nvcih0aGlzLmxpZmVjeWNsZSwgb2JqLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuRWxlbWVudFByb3BlcnR5QWNjZXNzb3IodGhpcy5saWZlY3ljbGUsIG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlBY2Nlc3NvcihvYmosIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QXJyYXlPYnNlcnZlcihvYnNlcnZlZEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QXJyYXlPYnNlcnZlcih0aGlzLmxpZmVjeWNsZSwgb2JzZXJ2ZWRBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWFwT2JzZXJ2ZXIob2JzZXJ2ZWRNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNYXBPYnNlcnZlcih0aGlzLmxpZmVjeWNsZSwgb2JzZXJ2ZWRNYXApO1xuICAgICAgICB9XG4gICAgICAgIGdldFNldE9ic2VydmVyKG9ic2VydmVkU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2V0T2JzZXJ2ZXIodGhpcy5saWZlY3ljbGUsIG9ic2VydmVkU2V0KTtcbiAgICAgICAgfVxuICAgICAgICBnZXRPckNyZWF0ZU9ic2VydmVyc0xvb2t1cChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouJG9ic2VydmVycyB8fCB0aGlzLmNyZWF0ZU9ic2VydmVyc0xvb2t1cChvYmopO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZU9ic2VydmVyc0xvb2t1cChvYmopIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ge307XG4gICAgICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnJG9ic2VydmVycycsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAga2VybmVsLlJlcG9ydGVyLndyaXRlKDAsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QWRhcHRlck9ic2VydmVyKG9iaiwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmFkYXB0ZXJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5hZGFwdGVyc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IGFkYXB0ZXIuZ2V0T2JzZXJ2ZXIob2JqLCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlUHJvcGVydHlPYnNlcnZlcihvYmosIHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJpbWl0aXZlT2JzZXJ2ZXIob2JqLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlzTm9kZTtcbiAgICAgICAgICAgIGlmIChET00uaXNOb2RlSW5zdGFuY2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkNsYXNzQXR0cmlidXRlQWNjZXNzb3IodGhpcy5saWZlY3ljbGUsIG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdzdHlsZScgfHwgcHJvcGVydHlOYW1lID09PSAnY3NzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuU3R5bGVBdHRyaWJ1dGVBY2Nlc3Nvcih0aGlzLmxpZmVjeWNsZSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IG9ialsndGFnTmFtZSddO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFbGVtZW50SGFuZGxlcihvYmosIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyAmJiB0YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuU2VsZWN0VmFsdWVPYnNlcnZlcih0aGlzLmxpZmVjeWNsZSwgb2JqLCBoYW5kbGVyLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ2NoZWNrZWQnICYmIHRhZ05hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkNoZWNrZWRPYnNlcnZlcih0aGlzLmxpZmVjeWNsZSwgb2JqLCBoYW5kbGVyLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlZhbHVlQXR0cmlidXRlT2JzZXJ2ZXIodGhpcy5saWZlY3ljbGUsIG9iaiwgcHJvcGVydHlOYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeGxpbmtSZXN1bHQgPSAvXnhsaW5rOiguKykkLy5leGVjKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHhsaW5rUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5YTGlua0F0dHJpYnV0ZUFjY2Vzc29yKHRoaXMubGlmZWN5Y2xlLCBvYmosIHByb3BlcnR5TmFtZSwgeGxpbmtSZXN1bHRbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSAncm9sZSdcbiAgICAgICAgICAgICAgICAgICAgfHwgL15cXHcrOnxeZGF0YS18XmFyaWEtLy50ZXN0KHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5zdmdBbmFseXplci5pc1N0YW5kYXJkU3ZnQXR0cmlidXRlKG9iaiwgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuRGF0YUF0dHJpYnV0ZUFjY2Vzc29yKHRoaXMubGlmZWN5Y2xlLCBvYmosIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzTm9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YWcgPSB0b1N0cmluZ1RhZyQxLmNhbGwob2JqKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSAnbGVuZ3RoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXJyYXlPYnNlcnZlcihvYmopLmdldExlbmd0aE9ic2VydmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlydHlDaGVja2VyLmNyZWF0ZVByb3BlcnR5KG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICBjYXNlICdbb2JqZWN0IE1hcF0nOlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSAnc2l6ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hcE9ic2VydmVyKG9iaikuZ2V0TGVuZ3RoT2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eUNoZWNrZXIuY3JlYXRlUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgU2V0XSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdzaXplJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2V0T2JzZXJ2ZXIob2JqKS5nZXRMZW5ndGhPYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcnR5Q2hlY2tlci5jcmVhdGVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAmJiBkZXNjcmlwdG9yLmdldC5nZXRPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmdldE9ic2VydmVyKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byB1c2UgYW4gYWRhcHRlciBiZWZvcmUgcmVzb3J0aW5nIHRvIGRpcnR5IGNoZWNraW5nLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGFwdGVyT2JzZXJ2ZXIgPSB0aGlzLmdldEFkYXB0ZXJPYnNlcnZlcihvYmosIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGFwdGVyT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyT2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcnR5Q2hlY2tlci5jcmVhdGVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVkT2JzZXJ2ZXIodGhpcywgdGhpcy5kaXJ0eUNoZWNrZXIsIHRoaXMubGlmZWN5Y2xlLCBvYmosIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlNldHRlck9ic2VydmVyKG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5PYnNlcnZlckxvY2F0b3IgPSBfX2RlY29yYXRlKFtcbiAgICAgICAga2VybmVsLmluamVjdChJTGlmZWN5Y2xlLCBJRXZlbnRNYW5hZ2VyLCBJRGlydHlDaGVja2VyLCBJU1ZHQW5hbHl6ZXIpXG4gICAgICAgIC8qQGludGVybmFsKi9cbiAgICBdLCBleHBvcnRzLk9ic2VydmVyTG9jYXRvcik7XG4gICAgZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbk9ic2VydmVyKGxpZmVjeWNsZSwgY29sbGVjdGlvbikge1xuICAgICAgICBzd2l0Y2ggKHRvU3RyaW5nVGFnJDEuY2FsbChjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBcnJheU9ic2VydmVyKGxpZmVjeWNsZSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IE1hcF0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNYXBPYnNlcnZlcihsaWZlY3ljbGUsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBTZXRdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2V0T2JzZXJ2ZXIobGlmZWN5Y2xlLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBleHBvcnRzLlVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3IgPSBjbGFzcyBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yIHtcbiAgICAgICAgY29uc3RydWN0b3Iob2JzZXJ2ZXJMb2NhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBiaW5kKGZsYWdzLCBzY29wZSwgYmluZGluZywgLi4uZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcig5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kaW5nLm1vZGUgIT09IGV4cG9ydHMuQmluZGluZ01vZGUudHdvV2F5ICYmIGJpbmRpbmcubW9kZSAhPT0gZXhwb3J0cy5CaW5kaW5nTW9kZS5mcm9tVmlldykge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIGJpbmRpbmcncyB0YXJnZXQgb2JzZXJ2ZXIgaGFzIGJlZW4gc2V0LlxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0T2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyTG9jYXRvci5nZXRPYnNlcnZlcihiaW5kaW5nLnRhcmdldCwgYmluZGluZy50YXJnZXRQcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldE9ic2VydmVyLmhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZGluZy50YXJnZXRPYnNlcnZlciA9IHRhcmdldE9ic2VydmVyO1xuICAgICAgICAgICAgLy8gc3Rhc2ggdGhlIG9yaWdpbmFsIGVsZW1lbnQgc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIub3JpZ2luYWxIYW5kbGVyID0gYmluZGluZy50YXJnZXRPYnNlcnZlci5oYW5kbGVyO1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZWxlbWVudCBzdWJzY3JpYmUgZnVuY3Rpb24gd2l0aCBvbmUgdGhhdCB1c2VzIHRoZSBjb3JyZWN0IGV2ZW50cy5cbiAgICAgICAgICAgIHRhcmdldE9ic2VydmVyLmhhbmRsZXIgPSBuZXcgRXZlbnRTdWJzY3JpYmVyKGV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5iaW5kKGZsYWdzLCBzY29wZSwgYmluZGluZykge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgdGhlIGJpbmRpbmcuXG4gICAgICAgICAgICBiaW5kaW5nLnRhcmdldE9ic2VydmVyLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgYmluZGluZy50YXJnZXRPYnNlcnZlci5oYW5kbGVyID0gYmluZGluZy50YXJnZXRPYnNlcnZlci5vcmlnaW5hbEhhbmRsZXI7XG4gICAgICAgICAgICBiaW5kaW5nLnRhcmdldE9ic2VydmVyLm9yaWdpbmFsSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBiaW5kaW5nQmVoYXZpb3IoJ3VwZGF0ZVRyaWdnZXInKSxcbiAgICAgICAga2VybmVsLmluamVjdChJT2JzZXJ2ZXJMb2NhdG9yKVxuICAgIF0sIGV4cG9ydHMuVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvcik7XG5cbiAgICBjbGFzcyBDYWxsIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCB0YXJnZXRQcm9wZXJ0eSwgb2JzZXJ2ZXJMb2NhdG9yLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgICAgIHRoaXMuJG5leHRCaW5kID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHByZXZCaW5kID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlID0gMCAvKiBub25lICovO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlciA9IG9ic2VydmVyTG9jYXRvci5nZXRPYnNlcnZlcih0YXJnZXQsIHRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsU291cmNlKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlQ29udGV4dCA9IHRoaXMuJHNjb3BlLm92ZXJyaWRlQ29udGV4dDtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3ZlcnJpZGVDb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShleHBvcnRzLkxpZmVjeWNsZUZsYWdzLm11c3RFdmFsdWF0ZSwgdGhpcy4kc2NvcGUsIHRoaXMubG9jYXRvcik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gYXJncykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZUNvbnRleHRbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgICRiaW5kKGZsYWdzLCBzY29wZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJHVuYmluZChmbGFncyB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUJpbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGlzQmluZGluZyBmbGFnXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSAxIC8qIGlzQmluZGluZyAqLztcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGhhc0JpbmQoc291cmNlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLmJpbmQoZmxhZ3MsIHNjb3BlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIuc2V0VmFsdWUoJGFyZ3MgPT4gdGhpcy5jYWxsU291cmNlKCRhcmdzKSwgZmxhZ3MpO1xuICAgICAgICAgICAgLy8gYWRkIGlzQm91bmQgZmxhZyBhbmQgcmVtb3ZlIGlzQmluZGluZyBmbGFnXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSAyIC8qIGlzQm91bmQgKi87XG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+MSAvKiBpc0JpbmRpbmcgKi87XG4gICAgICAgIH1cbiAgICAgICAgJHVuYmluZChmbGFncykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGlzVW5iaW5kaW5nIGZsYWdcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlIHw9IDY0IC8qIGlzVW5iaW5kaW5nICovO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChoYXNVbmJpbmQoc291cmNlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLnVuYmluZChmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kc2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zZXRWYWx1ZShudWxsLCBmbGFncyk7XG4gICAgICAgICAgICAvLyByZW1vdmUgaXNCb3VuZCBhbmQgaXNVbmJpbmRpbmcgZmxhZ3NcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlICY9IH4oMiAvKiBpc0JvdW5kICovIHwgNjQgLyogaXNVbmJpbmRpbmcgKi8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWVtcHR5IG5vLWFueVxuICAgICAgICBvYnNlcnZlUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUpIHsgfVxuICAgICAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7IH1cbiAgICB9XG5cbiAgICBjb25zdCBJRXhwcmVzc2lvblBhcnNlciA9IGtlcm5lbC5ESS5jcmVhdGVJbnRlcmZhY2UoKVxuICAgICAgICAud2l0aERlZmF1bHQoeCA9PiB4LnNpbmdsZXRvbihFeHByZXNzaW9uUGFyc2VyKSk7XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNsYXNzIEV4cHJlc3Npb25QYXJzZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbkxvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb25Mb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5mb3JPZkxvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2UoZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYmluZGluZ1R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5pbnRlcnBvbGF0aW9uTG9va3VwW2V4cHJlc3Npb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMuaW50ZXJwb2xhdGlvbkxvb2t1cFtleHByZXNzaW9uXSA9IHRoaXMucGFyc2VDb3JlKGV4cHJlc3Npb24sIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNTM5IC8qIEZvckNvbW1hbmQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZm9yT2ZMb29rdXBbZXhwcmVzc2lvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5mb3JPZkxvb2t1cFtleHByZXNzaW9uXSA9IHRoaXMucGFyc2VDb3JlKGV4cHJlc3Npb24sIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGVtcHR5IHN0cmluZ3MgZm9yIG5vcm1hbCBiaW5kaW5ncyBhbmQgdGhvc2UgdGhhdCBhcmUgZW1wdHkgYnkgZGVmYXVsdCAoc3VjaCBhcyBhIGN1c3RvbSBhdHRyaWJ1dGUgd2l0aG91dCBhbiBlcXVhbHMgc2lnbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBkb24ndCBjYWNoZSBpdCwgYmVjYXVzZSBlbXB0eSBzdHJpbmdzIGFyZSBhbHdheXMgaW52YWxpZCBmb3IgYW55IG90aGVyIHR5cGUgb2YgYmluZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAwICYmIChiaW5kaW5nVHlwZSAmICg1MyAvKiBCaW5kQ29tbWFuZCAqLyB8IDQ5IC8qIE9uZVRpbWVDb21tYW5kICovIHwgNTAgLyogVG9WaWV3Q29tbWFuZCAqLykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByaW1pdGl2ZUxpdGVyYWwuJGVtcHR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5leHByZXNzaW9uTG9va3VwW2V4cHJlc3Npb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMuZXhwcmVzc2lvbkxvb2t1cFtleHByZXNzaW9uXSA9IHRoaXMucGFyc2VDb3JlKGV4cHJlc3Npb24sIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhY2hlKGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZvck9mTG9va3VwLCBleHByZXNzaW9uTG9va3VwLCBpbnRlcnBvbGF0aW9uTG9va3VwIH0gPSB0aGlzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIGluIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwciA9IGV4cHJlc3Npb25zW2V4cHJlc3Npb25dO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwci4ka2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI0IC8qIEludGVycG9sYXRpb24gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uTG9va3VwW2V4cHJlc3Npb25dID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU1IC8qIEZvck9mU3RhdGVtZW50ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yT2ZMb29rdXBbZXhwcmVzc2lvbl0gPSBleHByO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uTG9va3VwW2V4cHJlc3Npb25dID0gZXhwcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VDb3JlKGV4cHJlc3Npb24sIGJpbmRpbmdUeXBlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZXhwcmVzc2lvbi5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFBhcnQuZW5kc1dpdGgoJygpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDYWxsU2NvcGUoZmlyc3RQYXJ0LnJlcGxhY2UoJygpJywgJycpLCBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV3IEFjY2Vzc1Njb3BlKHBhcnRzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBwYXJ0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydC5lbmRzV2l0aCgnKCknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDYWxsTWVtYmVyKGN1cnJlbnQsIGN1cnJlbnRQYXJ0LnJlcGxhY2UoJygpJywgJycpLCBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV3IEFjY2Vzc01lbWJlcihjdXJyZW50LCBwYXJ0c1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1hbnlcbiAgICBjb25zdCB7IHRvVmlldzogdG9WaWV3JDIsIG9uZVRpbWU6IG9uZVRpbWUkMiB9ID0gZXhwb3J0cy5CaW5kaW5nTW9kZTtcbiAgICBjbGFzcyBNdWx0aUludGVycG9sYXRpb25CaW5kaW5nIHtcbiAgICAgICAgY29uc3RydWN0b3Iob2JzZXJ2ZXJMb2NhdG9yLCBpbnRlcnBvbGF0aW9uLCB0YXJnZXQsIHRhcmdldFByb3BlcnR5LCBtb2RlLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICAgICAgdGhpcy4kbmV4dEJpbmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kcHJldkJpbmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgPSAwIC8qIG5vbmUgKi87XG4gICAgICAgICAgICB0aGlzLiRzY29wZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGUgY2hpbGQgZXhwcmVzc2lvbnMgb2YgYW4gSW50ZXJwb2xhdGlvbiBleHByZXNzaW9uIGFyZSBmdWxsIEF1cmVsaWEgZXhwcmVzc2lvbnMsIG1lYW5pbmcgdGhleSBtYXkgaW5jbHVkZVxuICAgICAgICAgICAgLy8gdmFsdWUgY29udmVydGVycyBhbmQgYmluZGluZyBiZWhhdmlvcnMuXG4gICAgICAgICAgICAvLyBFYWNoIGV4cHJlc3Npb24gcmVwcmVzZW50cyBvbmUgJHtpbnRlcnBvbGF0aW9ufSwgYW5kIGZvciBlYWNoIHdlIGNyZWF0ZSBhIGNoaWxkIFRleHRCaW5kaW5nIHVubGVzcyB0aGVyZSBpcyBvbmx5IG9uZSxcbiAgICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhlIHJlbmRlcmVyIHdpbGwgY3JlYXRlIHRoZSBUZXh0QmluZGluZyBkaXJlY3RseVxuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBpbnRlcnBvbGF0aW9uLmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnBhcnRzID0gQXJyYXkoZXhwcmVzc2lvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGV4cHJlc3Npb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9IG5ldyBleHBvcnRzLkludGVycG9sYXRpb25CaW5kaW5nKGV4cHJlc3Npb25zW2ldLCBpbnRlcnBvbGF0aW9uLCB0YXJnZXQsIHRhcmdldFByb3BlcnR5LCBtb2RlLCBvYnNlcnZlckxvY2F0b3IsIGxvY2F0b3IsIGkgPT09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICRiaW5kKGZsYWdzLCBzY29wZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJHVuYmluZChmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSAyIC8qIGlzQm91bmQgKi87XG4gICAgICAgICAgICB0aGlzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnBhcnRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIHBhcnRzW2ldLiRiaW5kKGZsYWdzLCBzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHVuYmluZChmbGFncykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kc3RhdGUgJj0gfjIgLyogaXNCb3VuZCAqLztcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy5wYXJ0cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1tpXS4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBvcnRzLkludGVycG9sYXRpb25CaW5kaW5nID0gY2xhc3MgSW50ZXJwb2xhdGlvbkJpbmRpbmcge1xuICAgICAgICBjb25zdHJ1Y3Rvcihzb3VyY2VFeHByZXNzaW9uLCBpbnRlcnBvbGF0aW9uLCB0YXJnZXQsIHRhcmdldFByb3BlcnR5LCBtb2RlLCBvYnNlcnZlckxvY2F0b3IsIGxvY2F0b3IsIGlzRmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbiA9IHNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFByb3BlcnR5ID0gdGFyZ2V0UHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICAgICAgdGhpcy5pc0ZpcnN0ID0gaXNGaXJzdDtcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlID0gMCAvKiBub25lICovO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlciA9IG9ic2VydmVyTG9jYXRvci5nZXRBY2Nlc3Nvcih0YXJnZXQsIHRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVUYXJnZXQodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyLnNldFZhbHVlKHZhbHVlLCBmbGFncyB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MudXBkYXRlVGFyZ2V0SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSB0aGlzLnRhcmdldE9ic2VydmVyLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuaW50ZXJwb2xhdGlvbi5ldmFsdWF0ZShmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMubG9jYXRvcik7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldChuZXdWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiBvbmVUaW1lJDIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJzaW9uKys7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLmNvbm5lY3QoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVub2JzZXJ2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJGJpbmQoZmxhZ3MsIHNjb3BlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHN0YXRlIHw9IDIgLyogaXNCb3VuZCAqLztcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uYmluZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24uYmluZChmbGFncywgc2NvcGUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGludGVycG9sYXRpb24gYWxyZWFkeSBnZXRzIHRoZSB3aG9sZSB2YWx1ZSwgd2Ugb25seSBuZWVkIHRvIGxldCB0aGUgZmlyc3RcbiAgICAgICAgICAgIC8vIHRleHQgYmluZGluZyBkbyB0aGUgdXBkYXRlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaXJzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0KHRoaXMuaW50ZXJwb2xhdGlvbi5ldmFsdWF0ZShmbGFncywgc2NvcGUsIHRoaXMubG9jYXRvciksIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgJiB0b1ZpZXckMikge1xuICAgICAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24uY29ubmVjdChmbGFncywgc2NvcGUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHN0YXRlICY9IH4yIC8qIGlzQm91bmQgKi87XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24udW5iaW5kKSB7XG4gICAgICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi51bmJpbmQoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudW5vYnNlcnZlKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkludGVycG9sYXRpb25CaW5kaW5nID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvbm5lY3RhYmxlKClcbiAgICBdLCBleHBvcnRzLkludGVycG9sYXRpb25CaW5kaW5nKTtcblxuICAgIGV4cG9ydHMuTGV0QmluZGluZyA9IGNsYXNzIExldEJpbmRpbmcge1xuICAgICAgICBjb25zdHJ1Y3Rvcihzb3VyY2VFeHByZXNzaW9uLCB0YXJnZXRQcm9wZXJ0eSwgb2JzZXJ2ZXJMb2NhdG9yLCBsb2NhdG9yLCB0b1ZpZXdNb2RlbCA9IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFByb3BlcnR5O1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICAgICAgdGhpcy50b1ZpZXdNb2RlbCA9IHRvVmlld01vZGVsO1xuICAgICAgICAgICAgdGhpcy4kbmV4dEJpbmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kcHJldkJpbmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgPSAwIC8qIG5vbmUgKi87XG4gICAgICAgICAgICB0aGlzLiRzY29wZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiRsaWZlY3ljbGUgPSBsb2NhdG9yLmdldChJTGlmZWN5Y2xlKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLiRzdGF0ZSAmIDIgLyogaXNCb3VuZCAqLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnVwZGF0ZVRhcmdldEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0YXJnZXQsIHRhcmdldFByb3BlcnR5IH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSB0YXJnZXRbdGFyZ2V0UHJvcGVydHldO1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcy5sb2NhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3RhcmdldFByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMTUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICAkYmluZChmbGFncywgc2NvcGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDIgLyogaXNCb3VuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRzY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiR1bmJpbmQoZmxhZ3MgfCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21CaW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBpc0JpbmRpbmcgZmxhZ1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgfD0gMSAvKiBpc0JpbmRpbmcgKi87XG4gICAgICAgICAgICB0aGlzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLnRvVmlld01vZGVsID8gc2NvcGUuYmluZGluZ0NvbnRleHQgOiBzY29wZS5vdmVycmlkZUNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uYmluZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24uYmluZChmbGFncywgc2NvcGUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc291cmNlRXhwcmVzc2lvbiBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZCBkdXJpbmcgYmluZFxuICAgICAgICAgICAgdGhpcy50YXJnZXRbdGhpcy50YXJnZXRQcm9wZXJ0eV0gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb24uZXZhbHVhdGUoZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQmluZCwgc2NvcGUsIHRoaXMubG9jYXRvcik7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24uY29ubmVjdChmbGFncywgc2NvcGUsIHRoaXMpO1xuICAgICAgICAgICAgLy8gYWRkIGlzQm91bmQgZmxhZyBhbmQgcmVtb3ZlIGlzQmluZGluZyBmbGFnXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSAyIC8qIGlzQm91bmQgKi87XG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+MSAvKiBpc0JpbmRpbmcgKi87XG4gICAgICAgIH1cbiAgICAgICAgJHVuYmluZChmbGFncykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGlzVW5iaW5kaW5nIGZsYWdcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlIHw9IDY0IC8qIGlzVW5iaW5kaW5nICovO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChzb3VyY2VFeHByZXNzaW9uLnVuYmluZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24udW5iaW5kKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRzY29wZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnVub2JzZXJ2ZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpc0JvdW5kIGFuZCBpc1VuYmluZGluZyBmbGFnc1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgJj0gfigyIC8qIGlzQm91bmQgKi8gfCA2NCAvKiBpc1VuYmluZGluZyAqLyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuTGV0QmluZGluZyA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb25uZWN0YWJsZSgpXG4gICAgXSwgZXhwb3J0cy5MZXRCaW5kaW5nKTtcblxuICAgIGNsYXNzIExpc3RlbmVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodGFyZ2V0RXZlbnQsIGRlbGVnYXRpb25TdHJhdGVneSwgc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCBwcmV2ZW50RGVmYXVsdCwgZXZlbnRNYW5hZ2VyLCBsb2NhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEV2ZW50ID0gdGFyZ2V0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRpb25TdHJhdGVneSA9IGRlbGVnYXRpb25TdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbiA9IHNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgICAgIHRoaXMuJG5leHRCaW5kID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHByZXZCaW5kID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlID0gMCAvKiBub25lICovO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxTb3VyY2UoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlQ29udGV4dCA9IHRoaXMuJHNjb3BlLm92ZXJyaWRlQ29udGV4dDtcbiAgICAgICAgICAgIG92ZXJyaWRlQ29udGV4dFsnJGV2ZW50J10gPSBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShleHBvcnRzLkxpZmVjeWNsZUZsYWdzLm11c3RFdmFsdWF0ZSwgdGhpcy4kc2NvcGUsIHRoaXMubG9jYXRvcik7XG4gICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVDb250ZXh0WyckZXZlbnQnXTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUgJiYgdGhpcy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxTb3VyY2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgICRiaW5kKGZsYWdzLCBzY29wZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJHVuYmluZChmbGFncyB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUJpbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGlzQmluZGluZyBmbGFnXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSAxIC8qIGlzQmluZGluZyAqLztcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGhhc0JpbmQoc291cmNlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLmJpbmQoZmxhZ3MsIHNjb3BlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0RXZlbnQsIHRoaXMsIHRoaXMuZGVsZWdhdGlvblN0cmF0ZWd5KTtcbiAgICAgICAgICAgIC8vIGFkZCBpc0JvdW5kIGZsYWcgYW5kIHJlbW92ZSBpc0JpbmRpbmcgZmxhZ1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgfD0gMiAvKiBpc0JvdW5kICovO1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgJj0gfjEgLyogaXNCaW5kaW5nICovO1xuICAgICAgICB9XG4gICAgICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBpc1VuYmluZGluZyBmbGFnXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSA2NCAvKiBpc1VuYmluZGluZyAqLztcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoaGFzVW5iaW5kKHNvdXJjZUV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi51bmJpbmQoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGlzQm91bmQgYW5kIGlzVW5iaW5kaW5nIGZsYWdzXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+KDIgLyogaXNCb3VuZCAqLyB8IDY0IC8qIGlzVW5iaW5kaW5nICovKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1lbXB0eSBuby1hbnlcbiAgICAgICAgb2JzZXJ2ZVByb3BlcnR5KG9iaiwgcHJvcGVydHlOYW1lKSB7IH1cbiAgICAgICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncykgeyB9XG4gICAgfVxuXG4gICAgY2xhc3MgUmVmIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCBsb2NhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICAgICAgdGhpcy4kbmV4dEJpbmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kcHJldkJpbmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgPSAwIC8qIG5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgJGJpbmQoZmxhZ3MsIHNjb3BlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kdW5iaW5kKGZsYWdzIHwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQmluZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgaXNCaW5kaW5nIGZsYWdcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlIHw9IDEgLyogaXNCaW5kaW5nICovO1xuICAgICAgICAgICAgdGhpcy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoaGFzQmluZChzb3VyY2VFeHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24uYmluZChmbGFncywgc2NvcGUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLmFzc2lnbihmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMubG9jYXRvciwgdGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gYWRkIGlzQm91bmQgZmxhZyBhbmQgcmVtb3ZlIGlzQmluZGluZyBmbGFnXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSAyIC8qIGlzQm91bmQgKi87XG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+MSAvKiBpc0JpbmRpbmcgKi87XG4gICAgICAgIH1cbiAgICAgICAgJHVuYmluZChmbGFncykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGlzVW5iaW5kaW5nIGZsYWdcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlIHw9IDY0IC8qIGlzVW5iaW5kaW5nICovO1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMubG9jYXRvcikgPT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLmFzc2lnbihmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMubG9jYXRvciwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGhhc1VuYmluZChzb3VyY2VFeHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24udW5iaW5kKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRzY29wZSA9IG51bGw7XG4gICAgICAgICAgICAvLyByZW1vdmUgaXNCb3VuZCBhbmQgaXNVbmJpbmRpbmcgZmxhZ3NcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlICY9IH4oMiAvKiBpc0JvdW5kICovIHwgNjQgLyogaXNVbmJpbmRpbmcgKi8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWVtcHR5IG5vLWFueVxuICAgICAgICBvYnNlcnZlUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUpIHsgfVxuICAgICAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7IH1cbiAgICB9XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1yZXNlcnZlZC1rZXl3b3Jkc1xuICAgIC8qQGludGVybmFsKi9cbiAgICBjb25zdCBjdXN0b21FbGVtZW50TmFtZSA9ICdjdXN0b20tZWxlbWVudCc7XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbUVsZW1lbnRLZXkobmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7Y3VzdG9tRWxlbWVudE5hbWV9OiR7bmFtZX1gO1xuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZnVuY3Rpb24gY3VzdG9tRWxlbWVudEJlaGF2aW9yKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuJGN1c3RvbUVsZW1lbnQgfHwgbnVsbDtcbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNvbnN0IGN1c3RvbUF0dHJpYnV0ZU5hbWUgPSAnY3VzdG9tLWF0dHJpYnV0ZSc7XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbUF0dHJpYnV0ZUtleShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHtjdXN0b21BdHRyaWJ1dGVOYW1lfToke25hbWV9YDtcbiAgICB9XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlVmFsdWVzID0gJ2FiY2RlZmdoaWprbCc7XG4gICAgY29uc3QgSVRhcmdldGVkSW5zdHJ1Y3Rpb24gPSBrZXJuZWwuREkuY3JlYXRlSW50ZXJmYWNlKCk7XG4gICAgZnVuY3Rpb24gaXNUYXJnZXRlZEluc3RydWN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICYmIGluc3RydWN0aW9uVHlwZVZhbHVlcy5pbmRleE9mKHR5cGUpICE9PSAtMTtcbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNvbnN0IGJ1aWxkUmVxdWlyZWQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIGNvbXBpbGVyOiAnZGVmYXVsdCdcbiAgICB9KTtcbiAgICBjb25zdCBidWlsZE5vdFJlcXVpcmVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgY29tcGlsZXI6ICdkZWZhdWx0J1xuICAgIH0pO1xuICAgIC8vIE5vdGU6IHRoaXMgaXMgYSBsaXR0bGUgcGVyZiB0aGluZzsgaGF2aW5nIG9uZSBwcmVkZWZpbmVkIGNsYXNzIHdpdGggdGhlIHByb3BlcnRpZXMgYWx3YXlzXG4gICAgLy8gYXNzaWduZWQgaW4gdGhlIHNhbWUgb3JkZXIgZW5zdXJlcyB0aGUgYnJvd3NlciBjYW4ga2VlcCByZXVzaW5nIHRoZSBzYW1lIGdlbmVyYXRlZCBoaWRkZW5cbiAgICAvLyBjbGFzc1xuICAgIGNsYXNzIERlZmF1bHRUZW1wbGF0ZURlZmluaXRpb24ge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICd1bm5hbWVkJztcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkID0gYnVpbGROb3RSZXF1aXJlZDtcbiAgICAgICAgICAgIHRoaXMuYmluZGFibGVzID0ga2VybmVsLlBMQVRGT1JNLmVtcHR5T2JqZWN0O1xuICAgICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheTtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0ga2VybmVsLlBMQVRGT1JNLmVtcHR5QXJyYXk7XG4gICAgICAgICAgICB0aGlzLnN1cnJvZ2F0ZXMgPSBrZXJuZWwuUExBVEZPUk0uZW1wdHlBcnJheTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVybGVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dPcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzU2xvdHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wbGF0ZURlZmluaXRpb25Bc3NpZ25hYmxlcyA9IFtcbiAgICAgICAgJ25hbWUnLFxuICAgICAgICAndGVtcGxhdGUnLFxuICAgICAgICAnY2FjaGUnLFxuICAgICAgICAnYnVpbGQnLFxuICAgICAgICAnY29udGFpbmVybGVzcycsXG4gICAgICAgICdzaGFkb3dPcHRpb25zJyxcbiAgICAgICAgJ2hhc1Nsb3RzJ1xuICAgIF07XG4gICAgY29uc3QgdGVtcGxhdGVEZWZpbml0aW9uQXJyYXlzID0gW1xuICAgICAgICAnaW5zdHJ1Y3Rpb25zJyxcbiAgICAgICAgJ2RlcGVuZGVuY2llcycsXG4gICAgICAgICdzdXJyb2dhdGVzJ1xuICAgIF07XG4gICAgZnVuY3Rpb24gYnVpbGRUZW1wbGF0ZURlZmluaXRpb24oY3RvciwgbmFtZU9yRGVmLCB0ZW1wbGF0ZSwgY2FjaGUsIGJ1aWxkLCBiaW5kYWJsZXMsIGluc3RydWN0aW9ucywgZGVwZW5kZW5jaWVzLCBzdXJyb2dhdGVzLCBjb250YWluZXJsZXNzLCBzaGFkb3dPcHRpb25zLCBoYXNTbG90cykge1xuICAgICAgICBjb25zdCBkZWYgPSBuZXcgRGVmYXVsdFRlbXBsYXRlRGVmaW5pdGlvbigpO1xuICAgICAgICAvLyBhbGwgY2FzZXMgZmFsbCB0aHJvdWdoIGludGVudGlvbmFsbHlcbiAgICAgICAgY29uc3QgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICAgIGNhc2UgMTI6IGlmIChoYXNTbG90cyAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBkZWYuaGFzU2xvdHMgPSBoYXNTbG90cztcbiAgICAgICAgICAgIGNhc2UgMTE6IGlmIChzaGFkb3dPcHRpb25zICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIGRlZi5zaGFkb3dPcHRpb25zID0gc2hhZG93T3B0aW9ucztcbiAgICAgICAgICAgIGNhc2UgMTA6IGlmIChjb250YWluZXJsZXNzICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIGRlZi5jb250YWluZXJsZXNzID0gY29udGFpbmVybGVzcztcbiAgICAgICAgICAgIGNhc2UgOTogaWYgKHN1cnJvZ2F0ZXMgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgZGVmLnN1cnJvZ2F0ZXMgPSBrZXJuZWwuUExBVEZPUk0udG9BcnJheShzdXJyb2dhdGVzKTtcbiAgICAgICAgICAgIGNhc2UgODogaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBkZWYuZGVwZW5kZW5jaWVzID0ga2VybmVsLlBMQVRGT1JNLnRvQXJyYXkoZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgIGNhc2UgNzogaWYgKGluc3RydWN0aW9ucyAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBkZWYuaW5zdHJ1Y3Rpb25zID0ga2VybmVsLlBMQVRGT1JNLnRvQXJyYXkoaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgIGNhc2UgNjogaWYgKGJpbmRhYmxlcyAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBkZWYuYmluZGFibGVzID0gT2JqZWN0LmFzc2lnbih7fSwgYmluZGFibGVzKTtcbiAgICAgICAgICAgIGNhc2UgNTogaWYgKGJ1aWxkICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIGRlZi5idWlsZCA9IGJ1aWxkID09PSB0cnVlID8gYnVpbGRSZXF1aXJlZCA6IGJ1aWxkID09PSBmYWxzZSA/IGJ1aWxkTm90UmVxdWlyZWQgOiBPYmplY3QuYXNzaWduKHt9LCBidWlsZCk7XG4gICAgICAgICAgICBjYXNlIDQ6IGlmIChjYWNoZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBkZWYuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgICAgIGNhc2UgMzogaWYgKHRlbXBsYXRlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIGRlZi50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmIChjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdG9yWydiaW5kYWJsZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmLmJpbmRhYmxlcyA9IE9iamVjdC5hc3NpZ24oe30sIGN0b3IuYmluZGFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3RvclsnY29udGFpbmVybGVzcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYuY29udGFpbmVybGVzcyA9IGN0b3IuY29udGFpbmVybGVzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3Rvclsnc2hhZG93T3B0aW9ucyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYuc2hhZG93T3B0aW9ucyA9IGN0b3Iuc2hhZG93T3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVPckRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVPckRlZi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYubmFtZSA9IG5hbWVPckRlZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lT3JEZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVEZWZpbml0aW9uQXNzaWduYWJsZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lT3JEZWZbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbcHJvcF0gPSBuYW1lT3JEZWZbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZURlZmluaXRpb25BcnJheXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lT3JEZWZbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbcHJvcF0gPSBrZXJuZWwuUExBVEZPUk0udG9BcnJheShuYW1lT3JEZWZbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVPckRlZlsnYmluZGFibGVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYuYmluZGFibGVzID09PSBrZXJuZWwuUExBVEZPUk0uZW1wdHlPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYuYmluZGFibGVzID0gT2JqZWN0LmFzc2lnbih7fSwgbmFtZU9yRGVmLmJpbmRhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGRlZi5iaW5kYWJsZXMsIG5hbWVPckRlZi5iaW5kYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGludm9jYXRpb25zIHRoYXQgcXVhY2sgbGlrZSBhIEBjdXN0b21FbGVtZW50IGRlY29yYXRvclxuICAgICAgICBpZiAoYXJnTGVuID09PSAyICYmIGN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZU9yRGVmID09PSAnc3RyaW5nJyB8fCAhKCdidWlsZCcgaW4gbmFtZU9yRGVmKSkge1xuICAgICAgICAgICAgICAgIGRlZi5idWlsZCA9IGJ1aWxkUmVxdWlyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5kYWJsZShjb25maWdPclRhcmdldCwgcHJvcCkge1xuICAgICAgICBsZXQgY29uZmlnO1xuICAgICAgICBjb25zdCBkZWNvcmF0b3IgPSBmdW5jdGlvbiBkZWNvcmF0ZSgkdGFyZ2V0LCAkcHJvcCkge1xuICAgICAgICAgICAgY29uc3QgVHlwZSA9ICR0YXJnZXQuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBsZXQgYmluZGFibGVzID0gVHlwZS5iaW5kYWJsZXM7XG4gICAgICAgICAgICBpZiAoYmluZGFibGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiaW5kYWJsZXMgPSBUeXBlLmJpbmRhYmxlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25maWcuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmF0dHJpYnV0ZSA9IGtlcm5lbC5QTEFURk9STS5rZWJhYkNhc2UoJHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2sgPSBgJHskcHJvcH1DaGFuZ2VkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29uZmlnLm1vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25maWcubW9kZSA9IGV4cG9ydHMuQmluZGluZ01vZGUudG9WaWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gTm9uIGludm9jYXRpb246XG4gICAgICAgICAgICAgICAgLy8gLSBAYmluZGFibGVcbiAgICAgICAgICAgICAgICAvLyBJbnZvY2F0aW9uIHdpdGggb3Igdy9vIG9wdHM6XG4gICAgICAgICAgICAgICAgLy8gLSBAYmluZGFibGUoKVxuICAgICAgICAgICAgICAgIC8vIC0gQGJpbmRhYmxlKHsuLi5vcHRzfSlcbiAgICAgICAgICAgICAgICBjb25maWcucHJvcGVydHkgPSAkcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRhYmxlc1tjb25maWcucHJvcGVydHldID0gY29uZmlnO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIE5vbiBpbnZvY2F0aW9uOlxuICAgICAgICAgICAgLy8gLSBAYmluZGFibGVcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcihjb25maWdPclRhcmdldCwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZ09yVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gQ2xhc3NEZWNvcmF0b3JcbiAgICAgICAgICAgIC8vIC0gQGJpbmRhYmxlKCdiYXInKVxuICAgICAgICAgICAgLy8gRGlyZWN0IGNhbGw6XG4gICAgICAgICAgICAvLyAtIEBiaW5kYWJsZSgnYmFyJykoRm9vKVxuICAgICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIEludm9jYXRpb24gd2l0aCBvciB3L28gb3B0czpcbiAgICAgICAgLy8gLSBAYmluZGFibGUoKVxuICAgICAgICAvLyAtIEBiaW5kYWJsZSh7Li4ub3B0c30pXG4gICAgICAgIGNvbmZpZyA9IChjb25maWdPclRhcmdldCB8fCB7fSk7XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdPclR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRhZ09yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50Rm9yVGFnKHRhZ09yVHlwZSwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50Rm9yVHlwZSh0YWdPclR5cGUsIHByb3BzLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgUmVuZGVyUGxhbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5vZGUsIGluc3RydWN0aW9ucywgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVmaW5pdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhenlEZWZpbml0aW9uIHx8ICh0aGlzLmxhenlEZWZpbml0aW9uID1cbiAgICAgICAgICAgICAgICBidWlsZFRlbXBsYXRlRGVmaW5pdGlvbihudWxsLCBudWxsLCB0aGlzLm5vZGUsIG51bGwsIHR5cGVvZiB0aGlzLm5vZGUgPT09ICdzdHJpbmcnLCBudWxsLCB0aGlzLmluc3RydWN0aW9ucywgdGhpcy5kZXBlbmRlbmNpZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRFbGVtZW50VGVtcGxhdGUoZW5naW5lLCBUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5naW5lLmdldEVsZW1lbnRUZW1wbGF0ZSh0aGlzLmRlZmluaXRpb24sIFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZVZpZXcoZW5naW5lLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWaWV3RmFjdG9yeShlbmdpbmUsIHBhcmVudENvbnRleHQpLmNyZWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGdldFZpZXdGYWN0b3J5KGVuZ2luZSwgcGFyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZ2luZS5nZXRWaWV3RmFjdG9yeSh0aGlzLmRlZmluaXRpb24sIHBhcmVudENvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qQGludGVybmFsKi9cbiAgICAgICAgbWVyZ2VJbnRvKHBhcmVudCwgaW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIERPTS5hcHBlbmRDaGlsZChwYXJlbnQsIHRoaXMubm9kZSk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCguLi50aGlzLmluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCguLi50aGlzLmRlcGVuZGVuY2llcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudEZvclRhZyh0YWdOYW1lLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGNvbnN0IGFsbEluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IERPTS5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICBsZXQgaGFzSW5zdHJ1Y3Rpb25zID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2godG8gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbdG9dO1xuICAgICAgICAgICAgICAgIGlmIChpc1RhcmdldGVkSW5zdHJ1Y3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0luc3RydWN0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgdG8sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBET00uc2V0QXR0cmlidXRlKGVsZW1lbnQsICdjbGFzcycsICdhdScpO1xuICAgICAgICAgICAgYWxsSW5zdHJ1Y3Rpb25zLnB1c2goaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGFkZENoaWxkcmVuKGVsZW1lbnQsIGNoaWxkcmVuLCBhbGxJbnN0cnVjdGlvbnMsIGRlcGVuZGVuY2llcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJQbGFuKGVsZW1lbnQsIGFsbEluc3RydWN0aW9ucywgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudEZvclR5cGUoVHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBUeXBlLmRlc2NyaXB0aW9uLm5hbWU7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBhbGxJbnN0cnVjdGlvbnMgPSBbaW5zdHJ1Y3Rpb25zXTtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIGNvbnN0IGNoaWxkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGNvbnN0IGJpbmRhYmxlcyA9IFR5cGUuZGVzY3JpcHRpb24uYmluZGFibGVzO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gRE9NLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIERPTS5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2NsYXNzJywgJ2F1Jyk7XG4gICAgICAgIGlmICghZGVwZW5kZW5jaWVzLmluY2x1ZGVzKFR5cGUpKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcImtcIiAvKiBoeWRyYXRlRWxlbWVudCAqLyxcbiAgICAgICAgICAgIHJlczogdGFnTmFtZSxcbiAgICAgICAgICAgIGluc3RydWN0aW9uczogY2hpbGRJbnN0cnVjdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2godG8gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbdG9dO1xuICAgICAgICAgICAgICAgIGlmIChpc1RhcmdldGVkSW5zdHJ1Y3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb25zLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZGFibGUgPSBiaW5kYWJsZXNbdG9dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaVwiIC8qIHNldFByb3BlcnR5ICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwialwiIC8qIHNldEF0dHJpYnV0ZSAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGFkZENoaWxkcmVuKGVsZW1lbnQsIGNoaWxkcmVuLCBhbGxJbnN0cnVjdGlvbnMsIGRlcGVuZGVuY2llcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJQbGFuKGVsZW1lbnQsIGFsbEluc3RydWN0aW9ucywgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4ocGFyZW50LCBjaGlsZHJlbiwgYWxsSW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIERPTS5hcHBlbmRDaGlsZChwYXJlbnQsIERPTS5jcmVhdGVUZXh0Tm9kZShjdXJyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChET00uaXNOb2RlSW5zdGFuY2UoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBET00uYXBwZW5kQ2hpbGQocGFyZW50LCBjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubWVyZ2VJbnRvKHBhcmVudCwgYWxsSW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uICRhdHRhY2hBdHRyaWJ1dGUoZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgOCAvKiBpc0F0dGFjaGVkICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlID0gdGhpcy4kbGlmZWN5Y2xlO1xuICAgICAgICBsaWZlY3ljbGUuYmVnaW5BdHRhY2goKTtcbiAgICAgICAgLy8gYWRkIGlzQXR0YWNoaW5nIGZsYWdcbiAgICAgICAgdGhpcy4kc3RhdGUgfD0gNCAvKiBpc0F0dGFjaGluZyAqLztcbiAgICAgICAgZmxhZ3MgfD0gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQXR0YWNoO1xuICAgICAgICBjb25zdCBob29rcyA9IHRoaXMuJGhvb2tzO1xuICAgICAgICBpZiAoaG9va3MgJiAxNiAvKiBoYXNBdHRhY2hpbmcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoaW5nKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgaXNBdHRhY2hlZCBmbGFnLCByZW1vdmUgaXNBdHRhY2hpbmcgZmxhZ1xuICAgICAgICB0aGlzLiRzdGF0ZSB8PSA4IC8qIGlzQXR0YWNoZWQgKi87XG4gICAgICAgIHRoaXMuJHN0YXRlICY9IH40IC8qIGlzQXR0YWNoaW5nICovO1xuICAgICAgICBpZiAoaG9va3MgJiAzMiAvKiBoYXNBdHRhY2hlZCAqLykge1xuICAgICAgICAgICAgbGlmZWN5Y2xlLmVucXVldWVBdHRhY2hlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBsaWZlY3ljbGUuZW5kQXR0YWNoKGZsYWdzKTtcbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uICRhdHRhY2hFbGVtZW50KGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDggLyogaXNBdHRhY2hlZCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpZmVjeWNsZSA9IHRoaXMuJGxpZmVjeWNsZTtcbiAgICAgICAgbGlmZWN5Y2xlLmJlZ2luQXR0YWNoKCk7XG4gICAgICAgIC8vIGFkZCBpc0F0dGFjaGluZyBmbGFnXG4gICAgICAgIHRoaXMuJHN0YXRlIHw9IDQgLyogaXNBdHRhY2hpbmcgKi87XG4gICAgICAgIGZsYWdzIHw9IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUF0dGFjaDtcbiAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLiRob29rcztcbiAgICAgICAgaWYgKGhvb2tzICYgMTYgLyogaGFzQXR0YWNoaW5nICovKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaGluZyhmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLiRhdHRhY2hhYmxlSGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnQuJGF0dGFjaChmbGFncyk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC4kbmV4dEF0dGFjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0aGlzLiRzdGF0ZSAmIDE2IC8qIGlzTW91bnRlZCAqLykpIHtcbiAgICAgICAgICAgIGxpZmVjeWNsZS5lbnF1ZXVlTW91bnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGlzQXR0YWNoZWQgZmxhZywgcmVtb3ZlIGlzQXR0YWNoaW5nIGZsYWdcbiAgICAgICAgdGhpcy4kc3RhdGUgfD0gOCAvKiBpc0F0dGFjaGVkICovO1xuICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+NCAvKiBpc0F0dGFjaGluZyAqLztcbiAgICAgICAgaWYgKGhvb2tzICYgMzIgLyogaGFzQXR0YWNoZWQgKi8pIHtcbiAgICAgICAgICAgIGxpZmVjeWNsZS5lbnF1ZXVlQXR0YWNoZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGlmZWN5Y2xlLmVuZEF0dGFjaChmbGFncyk7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkYXR0YWNoVmlldyhmbGFncykge1xuICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiA4IC8qIGlzQXR0YWNoZWQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgaXNBdHRhY2hpbmcgZmxhZ1xuICAgICAgICB0aGlzLiRzdGF0ZSB8PSA0IC8qIGlzQXR0YWNoaW5nICovO1xuICAgICAgICBmbGFncyB8PSBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21BdHRhY2g7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy4kYXR0YWNoYWJsZUhlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50LiRhdHRhY2goZmxhZ3MpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuJG5leHRBdHRhY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodGhpcy4kc3RhdGUgJiAxNiAvKiBpc01vdW50ZWQgKi8pKSB7XG4gICAgICAgICAgICB0aGlzLiRsaWZlY3ljbGUuZW5xdWV1ZU1vdW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBpc0F0dGFjaGVkIGZsYWcsIHJlbW92ZSBpc0F0dGFjaGluZyBmbGFnXG4gICAgICAgIHRoaXMuJHN0YXRlIHw9IDggLyogaXNBdHRhY2hlZCAqLztcbiAgICAgICAgdGhpcy4kc3RhdGUgJj0gfjQgLyogaXNBdHRhY2hpbmcgKi87XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkZGV0YWNoQXR0cmlidXRlKGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDggLyogaXNBdHRhY2hlZCAqLykge1xuICAgICAgICAgICAgY29uc3QgbGlmZWN5Y2xlID0gdGhpcy4kbGlmZWN5Y2xlO1xuICAgICAgICAgICAgbGlmZWN5Y2xlLmJlZ2luRGV0YWNoKCk7XG4gICAgICAgICAgICAvLyBhZGQgaXNEZXRhY2hpbmcgZmxhZ1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgfD0gMzIgLyogaXNEZXRhY2hpbmcgKi87XG4gICAgICAgICAgICBmbGFncyB8PSBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21EZXRhY2g7XG4gICAgICAgICAgICBjb25zdCBob29rcyA9IHRoaXMuJGhvb2tzO1xuICAgICAgICAgICAgaWYgKGhvb2tzICYgNjQgLyogaGFzRGV0YWNoaW5nICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hpbmcoZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIGlzQXR0YWNoZWQgYW5kIGlzRGV0YWNoaW5nIGZsYWdzXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+KDggLyogaXNBdHRhY2hlZCAqLyB8IDMyIC8qIGlzRGV0YWNoaW5nICovKTtcbiAgICAgICAgICAgIGlmIChob29rcyAmIDEyOCAvKiBoYXNEZXRhY2hlZCAqLykge1xuICAgICAgICAgICAgICAgIGxpZmVjeWNsZS5lbnF1ZXVlRGV0YWNoZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaWZlY3ljbGUuZW5kRGV0YWNoKGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZnVuY3Rpb24gJGRldGFjaEVsZW1lbnQoZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgOCAvKiBpc0F0dGFjaGVkICovKSB7XG4gICAgICAgICAgICBjb25zdCBsaWZlY3ljbGUgPSB0aGlzLiRsaWZlY3ljbGU7XG4gICAgICAgICAgICBsaWZlY3ljbGUuYmVnaW5EZXRhY2goKTtcbiAgICAgICAgICAgIC8vIGFkZCBpc0RldGFjaGluZyBmbGFnXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSB8PSAzMiAvKiBpc0RldGFjaGluZyAqLztcbiAgICAgICAgICAgIGZsYWdzIHw9IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbURldGFjaDtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDE2IC8qIGlzTW91bnRlZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgdW5tb3VudCBpZiBlaXRoZXI6XG4gICAgICAgICAgICAgICAgLy8gLSBObyBwYXJlbnQgdmlldy9lbGVtZW50IGlzIHF1ZXVlZCBmb3IgdW5tb3VudCB5ZXQsIG9yXG4gICAgICAgICAgICAgICAgLy8gLSBBdXJlbGlhIGlzIHN0b3BwaW5nIChpbiB3aGljaCBjYXNlIGFsbCBub2RlcyBuZWVkIHRvIHJldHVybiB0byB0aGVpciBmcmFnbWVudHMgZm9yIGEgY2xlYW4gbW91bnQgb24gbmV4dCBzdGFydClcbiAgICAgICAgICAgICAgICBpZiAoKChmbGFncyAmIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MucGFyZW50VW5tb3VudFF1ZXVlZCkgXiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnBhcmVudFVubW91bnRRdWV1ZWQpIHwgKGZsYWdzICYgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tU3RvcFRhc2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZS5lbnF1ZXVlVW5tb3VudCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MgfD0gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5wYXJlbnRVbm1vdW50UXVldWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhvb2tzID0gdGhpcy4kaG9va3M7XG4gICAgICAgICAgICBpZiAoaG9va3MgJiA2NCAvKiBoYXNEZXRhY2hpbmcgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaGluZyhmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuJGF0dGFjaGFibGVUYWlsO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LiRkZXRhY2goZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LiRwcmV2QXR0YWNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIGlzQXR0YWNoZWQgYW5kIGlzRGV0YWNoaW5nIGZsYWdzXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+KDggLyogaXNBdHRhY2hlZCAqLyB8IDMyIC8qIGlzRGV0YWNoaW5nICovKTtcbiAgICAgICAgICAgIGlmIChob29rcyAmIDEyOCAvKiBoYXNEZXRhY2hlZCAqLykge1xuICAgICAgICAgICAgICAgIGxpZmVjeWNsZS5lbnF1ZXVlRGV0YWNoZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaWZlY3ljbGUuZW5kRGV0YWNoKGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZnVuY3Rpb24gJGRldGFjaFZpZXcoZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgOCAvKiBpc0F0dGFjaGVkICovKSB7XG4gICAgICAgICAgICAvLyBhZGQgaXNEZXRhY2hpbmcgZmxhZ1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgfD0gMzIgLyogaXNEZXRhY2hpbmcgKi87XG4gICAgICAgICAgICBmbGFncyB8PSBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21EZXRhY2g7XG4gICAgICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiAxNiAvKiBpc01vdW50ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHVubW91bnQgaWYgZWl0aGVyOlxuICAgICAgICAgICAgICAgIC8vIC0gTm8gcGFyZW50IHZpZXcvZWxlbWVudCBpcyBxdWV1ZWQgZm9yIHVubW91bnQgeWV0LCBvclxuICAgICAgICAgICAgICAgIC8vIC0gQXVyZWxpYSBpcyBzdG9wcGluZyAoaW4gd2hpY2ggY2FzZSBhbGwgbm9kZXMgbmVlZCB0byByZXR1cm4gdG8gdGhlaXIgZnJhZ21lbnRzIGZvciBhIGNsZWFuIG1vdW50IG9uIG5leHQgc3RhcnQpXG4gICAgICAgICAgICAgICAgaWYgKCgoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLnBhcmVudFVubW91bnRRdWV1ZWQpIF4gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5wYXJlbnRVbm1vdW50UXVldWVkKSB8IChmbGFncyAmIGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbVN0b3BUYXNrKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsaWZlY3ljbGUuZW5xdWV1ZVVubW91bnQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzIHw9IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MucGFyZW50VW5tb3VudFF1ZXVlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuJGF0dGFjaGFibGVUYWlsO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LiRkZXRhY2goZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LiRwcmV2QXR0YWNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIGlzQXR0YWNoZWQgYW5kIGlzRGV0YWNoaW5nIGZsYWdzXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+KDggLyogaXNBdHRhY2hlZCAqLyB8IDMyIC8qIGlzRGV0YWNoaW5nICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZnVuY3Rpb24gJGNhY2hlQXR0cmlidXRlKGZsYWdzKSB7XG4gICAgICAgIGZsYWdzIHw9IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUNhY2hlO1xuICAgICAgICBpZiAodGhpcy4kaG9va3MgJiAyMDQ4IC8qIGhhc0NhY2hpbmcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGluZyhmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uICRjYWNoZUVsZW1lbnQoZmxhZ3MpIHtcbiAgICAgICAgZmxhZ3MgfD0gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQ2FjaGU7XG4gICAgICAgIGlmICh0aGlzLiRob29rcyAmIDIwNDggLyogaGFzQ2FjaGluZyAqLykge1xuICAgICAgICAgICAgdGhpcy5jYWNoaW5nKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuJGF0dGFjaGFibGVUYWlsO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudC4kY2FjaGUoZmxhZ3MpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuJHByZXZBdHRhY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uICRjYWNoZVZpZXcoZmxhZ3MpIHtcbiAgICAgICAgZmxhZ3MgfD0gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQ2FjaGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy4kYXR0YWNoYWJsZVRhaWw7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50LiRjYWNoZShmbGFncyk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC4kcHJldkF0dGFjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZnVuY3Rpb24gJG1vdW50RWxlbWVudChmbGFncykge1xuICAgICAgICB0aGlzLiRzdGF0ZSB8PSAxNiAvKiBpc01vdW50ZWQgKi87XG4gICAgICAgIHRoaXMuJHByb2plY3Rvci5wcm9qZWN0KHRoaXMuJG5vZGVzKTtcbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uICR1bm1vdW50RWxlbWVudChmbGFncykge1xuICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+MTYgLyogaXNNb3VudGVkICovO1xuICAgICAgICB0aGlzLiRwcm9qZWN0b3IudGFrZSh0aGlzLiRub2Rlcyk7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkbW91bnRWaWV3KGZsYWdzKSB7XG4gICAgICAgIHRoaXMuJHN0YXRlIHw9IDE2IC8qIGlzTW91bnRlZCAqLztcbiAgICAgICAgdGhpcy4kc3RhdGUgJj0gfjI1NiAvKiBuZWVkc01vdW50ICovO1xuICAgICAgICB0aGlzLiRub2Rlcy5pbnNlcnRCZWZvcmUodGhpcy5sb2NhdGlvbik7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkdW5tb3VudFZpZXcoZmxhZ3MpIHtcbiAgICAgICAgdGhpcy4kc3RhdGUgJj0gfjE2IC8qIGlzTW91bnRlZCAqLztcbiAgICAgICAgdGhpcy4kc3RhdGUgfD0gMjU2IC8qIG5lZWRzTW91bnQgKi87XG4gICAgICAgIHRoaXMuJG5vZGVzLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5pc0ZyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGcmVlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZS50cnlSZXR1cm5Ub0NhY2hlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhdGUgfD0gMTI4IC8qIGlzQ2FjaGVkICovO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZnVuY3Rpb24gJGJpbmRBdHRyaWJ1dGUoZmxhZ3MsIHNjb3BlKSB7XG4gICAgICAgIGZsYWdzIHw9IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUJpbmQ7XG4gICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDIgLyogaXNCb3VuZCAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHVuYmluZChmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlID0gdGhpcy4kbGlmZWN5Y2xlO1xuICAgICAgICBsaWZlY3ljbGUuYmVnaW5CaW5kKCk7XG4gICAgICAgIC8vIGFkZCBpc0JpbmRpbmcgZmxhZ1xuICAgICAgICB0aGlzLiRzdGF0ZSB8PSAxIC8qIGlzQmluZGluZyAqLztcbiAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLiRob29rcztcbiAgICAgICAgaWYgKGhvb2tzICYgOCAvKiBoYXNCb3VuZCAqLykge1xuICAgICAgICAgICAgbGlmZWN5Y2xlLmVucXVldWVCb3VuZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICBpZiAoaG9va3MgJiA0IC8qIGhhc0JpbmRpbmcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZyhmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGlzQm91bmQgZmxhZyBhbmQgcmVtb3ZlIGlzQmluZGluZyBmbGFnXG4gICAgICAgIHRoaXMuJHN0YXRlIHw9IDIgLyogaXNCb3VuZCAqLztcbiAgICAgICAgdGhpcy4kc3RhdGUgJj0gfjEgLyogaXNCaW5kaW5nICovO1xuICAgICAgICBsaWZlY3ljbGUuZW5kQmluZChmbGFncyk7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkYmluZEVsZW1lbnQoZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlID0gdGhpcy4kbGlmZWN5Y2xlO1xuICAgICAgICBsaWZlY3ljbGUuYmVnaW5CaW5kKCk7XG4gICAgICAgIC8vIGFkZCBpc0JpbmRpbmcgZmxhZ1xuICAgICAgICB0aGlzLiRzdGF0ZSB8PSAxIC8qIGlzQmluZGluZyAqLztcbiAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLiRob29rcztcbiAgICAgICAgZmxhZ3MgfD0gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQmluZDtcbiAgICAgICAgaWYgKGhvb2tzICYgOCAvKiBoYXNCb3VuZCAqLykge1xuICAgICAgICAgICAgbGlmZWN5Y2xlLmVucXVldWVCb3VuZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MgJiA0IC8qIGhhc0JpbmRpbmcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZyhmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzLiRzY29wZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLiRiaW5kYWJsZUhlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50LiRiaW5kKGZsYWdzLCBzY29wZSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC4kbmV4dEJpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGlzQm91bmQgZmxhZyBhbmQgcmVtb3ZlIGlzQmluZGluZyBmbGFnXG4gICAgICAgIHRoaXMuJHN0YXRlIHw9IDIgLyogaXNCb3VuZCAqLztcbiAgICAgICAgdGhpcy4kc3RhdGUgJj0gfjEgLyogaXNCaW5kaW5nICovO1xuICAgICAgICBsaWZlY3ljbGUuZW5kQmluZChmbGFncyk7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkYmluZFZpZXcoZmxhZ3MsIHNjb3BlKSB7XG4gICAgICAgIGZsYWdzIHw9IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUJpbmQ7XG4gICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDIgLyogaXNCb3VuZCAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHVuYmluZChmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGlzQmluZGluZyBmbGFnXG4gICAgICAgIHRoaXMuJHN0YXRlIHw9IDEgLyogaXNCaW5kaW5nICovO1xuICAgICAgICB0aGlzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuJGJpbmRhYmxlSGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnQuJGJpbmQoZmxhZ3MsIHNjb3BlKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LiRuZXh0QmluZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgaXNCb3VuZCBmbGFnIGFuZCByZW1vdmUgaXNCaW5kaW5nIGZsYWdcbiAgICAgICAgdGhpcy4kc3RhdGUgfD0gMiAvKiBpc0JvdW5kICovO1xuICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+MSAvKiBpc0JpbmRpbmcgKi87XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkdW5iaW5kQXR0cmlidXRlKGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDIgLyogaXNCb3VuZCAqLykge1xuICAgICAgICAgICAgY29uc3QgbGlmZWN5Y2xlID0gdGhpcy4kbGlmZWN5Y2xlO1xuICAgICAgICAgICAgbGlmZWN5Y2xlLmJlZ2luVW5iaW5kKCk7XG4gICAgICAgICAgICAvLyBhZGQgaXNVbmJpbmRpbmcgZmxhZ1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgfD0gNjQgLyogaXNVbmJpbmRpbmcgKi87XG4gICAgICAgICAgICBjb25zdCBob29rcyA9IHRoaXMuJGhvb2tzO1xuICAgICAgICAgICAgZmxhZ3MgfD0gZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tVW5iaW5kO1xuICAgICAgICAgICAgaWYgKGhvb2tzICYgNTEyIC8qIGhhc1VuYm91bmQgKi8pIHtcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGUuZW5xdWV1ZVVuYm91bmQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaG9va3MgJiAyNTYgLyogaGFzVW5iaW5kaW5nICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJpbmRpbmcoZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIGlzQm91bmQgYW5kIGlzVW5iaW5kaW5nIGZsYWdzXG4gICAgICAgICAgICB0aGlzLiRzdGF0ZSAmPSB+KDIgLyogaXNCb3VuZCAqLyB8IDY0IC8qIGlzVW5iaW5kaW5nICovKTtcbiAgICAgICAgICAgIGxpZmVjeWNsZS5lbmRVbmJpbmQoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkdW5iaW5kRWxlbWVudChmbGFncykge1xuICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGxpZmVjeWNsZSA9IHRoaXMuJGxpZmVjeWNsZTtcbiAgICAgICAgICAgIGxpZmVjeWNsZS5iZWdpblVuYmluZCgpO1xuICAgICAgICAgICAgLy8gYWRkIGlzVW5iaW5kaW5nIGZsYWdcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlIHw9IDY0IC8qIGlzVW5iaW5kaW5nICovO1xuICAgICAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLiRob29rcztcbiAgICAgICAgICAgIGZsYWdzIHw9IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbVVuYmluZDtcbiAgICAgICAgICAgIGlmIChob29rcyAmIDUxMiAvKiBoYXNVbmJvdW5kICovKSB7XG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlLmVucXVldWVVbmJvdW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhvb2tzICYgMjU2IC8qIGhhc1VuYmluZGluZyAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMudW5iaW5kaW5nKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy4kYmluZGFibGVUYWlsO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LiR1bmJpbmQoZmxhZ3MpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LiRwcmV2QmluZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSBpc0JvdW5kIGFuZCBpc1VuYmluZGluZyBmbGFnc1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgJj0gfigyIC8qIGlzQm91bmQgKi8gfCA2NCAvKiBpc1VuYmluZGluZyAqLyk7XG4gICAgICAgICAgICBsaWZlY3ljbGUuZW5kVW5iaW5kKGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZnVuY3Rpb24gJHVuYmluZFZpZXcoZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN0YXRlICYgMiAvKiBpc0JvdW5kICovKSB7XG4gICAgICAgICAgICAvLyBhZGQgaXNVbmJpbmRpbmcgZmxhZ1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgfD0gNjQgLyogaXNVbmJpbmRpbmcgKi87XG4gICAgICAgICAgICBmbGFncyB8PSBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21VbmJpbmQ7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuJGJpbmRhYmxlVGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC4kcHJldkJpbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgaXNCb3VuZCBhbmQgaXNVbmJpbmRpbmcgZmxhZ3NcbiAgICAgICAgICAgIHRoaXMuJHN0YXRlICY9IH4oMiAvKiBpc0JvdW5kICovIHwgNjQgLyogaXNVbmJpbmRpbmcgKi8pO1xuICAgICAgICAgICAgdGhpcy4kc2NvcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNsYXNzIFZpZXcge1xuICAgICAgICBjb25zdHJ1Y3RvcigkbGlmZWN5Y2xlLCBjYWNoZSkge1xuICAgICAgICAgICAgdGhpcy4kbGlmZWN5Y2xlID0gJGxpZmVjeWNsZTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgICAgIHRoaXMuJGJpbmRhYmxlSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiRiaW5kYWJsZVRhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kbmV4dEJpbmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kcHJldkJpbmQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kYXR0YWNoYWJsZUhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kYXR0YWNoYWJsZVRhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kbmV4dEF0dGFjaCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiRwcmV2QXR0YWNoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJG5leHRNb3VudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLiRtb3VudEZsYWdzID0gMDtcbiAgICAgICAgICAgIHRoaXMuJG5leHRVbm1vdW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJHVubW91bnRGbGFncyA9IDA7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VW5iaW5kQWZ0ZXJEZXRhY2ggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUgPSAwIC8qIG5vbmUgKi87XG4gICAgICAgICAgICB0aGlzLiRzY29wZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzRnJlZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGhvbGQobG9jYXRpb24sIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoIWxvY2F0aW9uLnBhcmVudE5vZGUpIHsgLy8gdW5tZXQgaW52YXJpYW50OiBsb2NhdGlvbiBtdXN0IGJlIGEgY2hpbGQgb2Ygc29tZSBvdGhlciBub2RlXG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDYwKTsgLy8gVE9ETzogb3JnYW5pemUgZXJyb3IgY29kZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IHRoaXMuJG5vZGVzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLm5leHRTaWJsaW5nID09PSBsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YXRlICY9IH4yNTYgLyogbmVlZHNNb3VudCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJHN0YXRlIHw9IDI1NiAvKiBuZWVkc01vdW50ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvY2tTY29wZShzY29wZSkge1xuICAgICAgICAgICAgdGhpcy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIHRoaXMuJGJpbmQgPSBsb2NrZWRCaW5kO1xuICAgICAgICB9XG4gICAgICAgIHJlbGVhc2UoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGcmVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzdGF0ZSAmIDggLyogaXNBdHRhY2hlZCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmNhblJldHVyblRvQ2FjaGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kdW5tb3VudChmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNsYXNzIFZpZXdGYWN0b3J5IHtcbiAgICAgICAgY29uc3RydWN0b3IobmFtZSwgdGVtcGxhdGUsIGxpZmVjeWNsZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgIHRoaXMubGlmZWN5Y2xlID0gbGlmZWN5Y2xlO1xuICAgICAgICAgICAgdGhpcy5pc0NhY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplID0gLTE7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzZXRDYWNoZVNpemUoc2l6ZSwgZG9Ob3RPdmVycmlkZUlmQWxyZWFkeVNldCkge1xuICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBWaWV3RmFjdG9yeS5tYXhDYWNoZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWNoZVNpemUgPT09IC0xIHx8ICFkb05vdE92ZXJyaWRlSWZBbHJlYWR5U2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZVNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzQ2FjaGluZyA9IHRoaXMuY2FjaGVTaXplID4gMDtcbiAgICAgICAgfVxuICAgICAgICBjYW5SZXR1cm5Ub0NhY2hlKHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlICE9PSBudWxsICYmIHRoaXMuY2FjaGUubGVuZ3RoIDwgdGhpcy5jYWNoZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5UmV0dXJuVG9DYWNoZSh2aWV3KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5SZXR1cm5Ub0NhY2hlKHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgdmlldy4kY2FjaGUoZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5ub25lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgICAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgICAgICBpZiAoY2FjaGUgIT09IG51bGwgJiYgY2FjaGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcgPSBjYWNoZS5wb3AoKTtcbiAgICAgICAgICAgICAgICB2aWV3LiRzdGF0ZSAmPSB+MTI4IC8qIGlzQ2FjaGVkICovO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldyA9IG5ldyBWaWV3KHRoaXMubGlmZWN5Y2xlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUucmVuZGVyKHZpZXcpO1xuICAgICAgICAgICAgaWYgKCF2aWV3LiRub2Rlcykge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcig5MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfVxuICAgIH1cbiAgICBWaWV3RmFjdG9yeS5tYXhDYWNoZVNpemUgPSAweEZGRkY7XG4gICAgZnVuY3Rpb24gbG9ja2VkQmluZChmbGFncykge1xuICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyB8PSBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21CaW5kO1xuICAgICAgICBjb25zdCBsb2NrZWRTY29wZSA9IHRoaXMuJHNjb3BlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuJGJpbmRhYmxlSGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnQuJGJpbmQoZmxhZ3MsIGxvY2tlZFNjb3BlKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LiRuZXh0QmluZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzdGF0ZSB8PSAyIC8qIGlzQm91bmQgKi87XG4gICAgfVxuICAgICgocHJvdG8pID0+IHtcbiAgICAgICAgcHJvdG8uJGJpbmQgPSAkYmluZFZpZXc7XG4gICAgICAgIHByb3RvLiR1bmJpbmQgPSAkdW5iaW5kVmlldztcbiAgICAgICAgcHJvdG8uJGF0dGFjaCA9ICRhdHRhY2hWaWV3O1xuICAgICAgICBwcm90by4kZGV0YWNoID0gJGRldGFjaFZpZXc7XG4gICAgICAgIHByb3RvLiRjYWNoZSA9ICRjYWNoZVZpZXc7XG4gICAgICAgIHByb3RvLiRtb3VudCA9ICRtb3VudFZpZXc7XG4gICAgICAgIHByb3RvLiR1bm1vdW50ID0gJHVubW91bnRWaWV3O1xuICAgIH0pKFZpZXcucHJvdG90eXBlKTtcblxuICAgIGZ1bmN0aW9uIHJlbmRlclN0cmF0ZWd5KG5hbWVPclNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0ID0+IFJlbmRlclN0cmF0ZWd5UmVzb3VyY2UuZGVmaW5lKG5hbWVPclNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgY29uc3QgUmVuZGVyU3RyYXRlZ3lSZXNvdXJjZSA9IHtcbiAgICAgICAgbmFtZTogJ3JlbmRlci1zdHJhdGVneScsXG4gICAgICAgIGtleUZyb20obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX06JHtuYW1lfWA7XG4gICAgICAgIH0sXG4gICAgICAgIGlzVHlwZShUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZS5raW5kID09PSB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmUobmFtZU9yU291cmNlLCBjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHR5cGVvZiBuYW1lT3JTb3VyY2UgPT09ICdzdHJpbmcnID8geyBuYW1lOiBuYW1lT3JTb3VyY2UgfSA6IG5hbWVPclNvdXJjZTtcbiAgICAgICAgICAgIGNvbnN0IFR5cGUgPSBjdG9yO1xuICAgICAgICAgICAgVHlwZS5raW5kID0gUmVuZGVyU3RyYXRlZ3lSZXNvdXJjZTtcbiAgICAgICAgICAgIFR5cGUuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIFR5cGUucmVnaXN0ZXIgPSByZWdpc3RlclJlbmRlclN0cmF0ZWd5O1xuICAgICAgICAgICAgcmV0dXJuIFR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiByZWdpc3RlclJlbmRlclN0cmF0ZWd5KGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCByZXNvdXJjZUtleSA9IFJlbmRlclN0cmF0ZWd5UmVzb3VyY2Uua2V5RnJvbSh0aGlzLmRlc2NyaXB0aW9uLm5hbWUpO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoa2VybmVsLlJlZ2lzdHJhdGlvbi5zaW5nbGV0b24ocmVzb3VyY2VLZXksIHRoaXMpKTtcbiAgICB9XG4gICAgY29uc3QgSVRlbXBsYXRlQ29tcGlsZXIgPSBrZXJuZWwuREkuY3JlYXRlSW50ZXJmYWNlKCkubm9EZWZhdWx0KCk7XG4gICAgKGZ1bmN0aW9uIChWaWV3Q29tcGlsZUZsYWdzKSB7XG4gICAgICAgIFZpZXdDb21waWxlRmxhZ3NbVmlld0NvbXBpbGVGbGFnc1tcIm5vbmVcIl0gPSAxXSA9IFwibm9uZVwiO1xuICAgICAgICBWaWV3Q29tcGlsZUZsYWdzW1ZpZXdDb21waWxlRmxhZ3NbXCJzdXJyb2dhdGVcIl0gPSAyXSA9IFwic3Vycm9nYXRlXCI7XG4gICAgICAgIFZpZXdDb21waWxlRmxhZ3NbVmlld0NvbXBpbGVGbGFnc1tcInNoYWRvd0RPTVwiXSA9IDRdID0gXCJzaGFkb3dET01cIjtcbiAgICB9KShleHBvcnRzLlZpZXdDb21waWxlRmxhZ3MgfHwgKGV4cG9ydHMuVmlld0NvbXBpbGVGbGFncyA9IHt9KSk7XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGZ1bmN0aW9uICRoeWRyYXRlQXR0cmlidXRlKHJlbmRlcmluZ0VuZ2luZSkge1xuICAgICAgICBjb25zdCBUeXBlID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmVuZGVyaW5nRW5naW5lLmFwcGx5UnVudGltZUJlaGF2aW9yKFR5cGUsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy4kaG9va3MgJiAyIC8qIGhhc0NyZWF0ZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiAkaHlkcmF0ZUVsZW1lbnQocmVuZGVyaW5nRW5naW5lLCBob3N0LCBvcHRpb25zID0ga2VybmVsLlBMQVRGT1JNLmVtcHR5T2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IFR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFR5cGUuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuJHNjb3BlID0gU2NvcGUuY3JlYXRlKHRoaXMsIG51bGwpO1xuICAgICAgICByZW5kZXJpbmdFbmdpbmUuYXBwbHlSdW50aW1lQmVoYXZpb3IoVHlwZSwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLiRob29rcyAmIDEwMjQgLyogaGFzUmVuZGVyICovKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlbmRlcihob3N0LCBvcHRpb25zLnBhcnRzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgJ2dldEVsZW1lbnRUZW1wbGF0ZScgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSByZXN1bHQuZ2V0RWxlbWVudFRlbXBsYXRlKHJlbmRlcmluZ0VuZ2luZSwgVHlwZSk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUucmVuZGVyKHRoaXMsIGhvc3QsIG9wdGlvbnMucGFydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSByZW5kZXJpbmdFbmdpbmUuZ2V0RWxlbWVudFRlbXBsYXRlKGRlc2NyaXB0aW9uLCBUeXBlKTtcbiAgICAgICAgICAgIHRlbXBsYXRlLnJlbmRlcih0aGlzLCBob3N0LCBvcHRpb25zLnBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy4kcHJvamVjdG9yID0gZGV0ZXJtaW5lUHJvamVjdG9yKHRoaXMsIGhvc3QsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuJGhvb2tzICYgMiAvKiBoYXNDcmVhdGVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgY29uc3QgZGVmYXVsdFNoYWRvd09wdGlvbnMgPSB7XG4gICAgICAgIG1vZGU6ICdvcGVuJ1xuICAgIH07XG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lUHJvamVjdG9yKCRjdXN0b21FbGVtZW50LCBob3N0LCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLnNoYWRvd09wdGlvbnMgfHwgZGVmaW5pdGlvbi5oYXNTbG90cykge1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uY29udGFpbmVybGVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYWRvd0RPTVByb2plY3RvcigkY3VzdG9tRWxlbWVudCwgaG9zdCwgZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29udGFpbmVybGVzcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXJsZXNzUHJvamVjdG9yKCRjdXN0b21FbGVtZW50LCBob3N0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhvc3RQcm9qZWN0b3IoJGN1c3RvbUVsZW1lbnQsIGhvc3QpO1xuICAgIH1cbiAgICBjb25zdCBJUmVuZGVyaW5nRW5naW5lID0ga2VybmVsLkRJLmNyZWF0ZUludGVyZmFjZSgpXG4gICAgICAgIC53aXRoRGVmYXVsdCh4ID0+IHguc2luZ2xldG9uKGV4cG9ydHMuUmVuZGVyaW5nRW5naW5lKSk7XG4gICAgY29uc3QgZGVmYXVsdENvbXBpbGVyTmFtZSA9ICdkZWZhdWx0JztcbiAgICBleHBvcnRzLlJlbmRlcmluZ0VuZ2luZSA9IFxuICAgIC8qQGludGVybmFsKi9cbiAgICBjbGFzcyBSZW5kZXJpbmdFbmdpbmUge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGxpZmVjeWNsZSwgb2JzZXJ2ZXJMb2NhdG9yLCBldmVudE1hbmFnZXIsIHBhcnNlciwgdGVtcGxhdGVDb21waWxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5mYWN0b3J5TG9va3VwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvckxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZXJzID0gdGVtcGxhdGVDb21waWxlcnMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2NbaXRlbS5uYW1lXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldEVsZW1lbnRUZW1wbGF0ZShkZWZpbml0aW9uLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMudGVtcGxhdGVMb29rdXAuZ2V0KGRlZmluaXRpb24pO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdGhpcy50ZW1wbGF0ZUZyb21Tb3VyY2UoZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgLy9JZiB0aGUgZWxlbWVudCBoYXMgYSB2aWV3LCBzdXBwb3J0IFJlY3Vyc2l2ZSBDb21wb25lbnRzIGJ5IGFkZGluZyBzZWxmIHRvIG93biB2aWV3IHRlbXBsYXRlIGNvbnRhaW5lci5cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQucmVuZGVyQ29udGV4dCAhPT0gbnVsbCAmJiBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGUucmVnaXN0ZXIoZm91bmQucmVuZGVyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGVMb29rdXAuc2V0KGRlZmluaXRpb24sIGZvdW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBnZXRWaWV3RmFjdG9yeShkZWZpbml0aW9uLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmYWN0b3J5ID0gdGhpcy5mYWN0b3J5TG9va3VwLmdldChkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkU291cmNlID0gYnVpbGRUZW1wbGF0ZURlZmluaXRpb24obnVsbCwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlRnJvbVNvdXJjZSh2YWxpZFNvdXJjZSwgcGFyZW50Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgZmFjdG9yeSA9IG5ldyBWaWV3RmFjdG9yeSh2YWxpZFNvdXJjZS5uYW1lLCB0ZW1wbGF0ZSwgdGhpcy5saWZlY3ljbGUpO1xuICAgICAgICAgICAgICAgIGZhY3Rvcnkuc2V0Q2FjaGVTaXplKHZhbGlkU291cmNlLmNhY2hlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZhY3RvcnlMb29rdXAuc2V0KGRlZmluaXRpb24sIGZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlSdW50aW1lQmVoYXZpb3IoVHlwZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMuYmVoYXZpb3JMb29rdXAuZ2V0KFR5cGUpO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gUnVudGltZUJlaGF2aW9yLmNyZWF0ZShUeXBlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWhhdmlvckxvb2t1cC5zZXQoVHlwZSwgZm91bmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQuYXBwbHlUbyhpbnN0YW5jZSwgdGhpcy5saWZlY3ljbGUpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZVJlbmRlcmVyKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVuZGVyZXIoY29udGV4dCwgdGhpcy5vYnNlcnZlckxvY2F0b3IsIHRoaXMuZXZlbnRNYW5hZ2VyLCB0aGlzLnBhcnNlciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVGcm9tU291cmNlKGRlZmluaXRpb24sIHBhcmVudENvbnRleHQpIHtcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQgPSBwYXJlbnRDb250ZXh0IHx8IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmJ1aWxkLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVyTmFtZSA9IGRlZmluaXRpb24uYnVpbGQuY29tcGlsZXIgfHwgZGVmYXVsdENvbXBpbGVyTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc1tjb21waWxlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoMjAsIGNvbXBpbGVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IGNvbXBpbGVyLmNvbXBpbGUoZGVmaW5pdGlvbiwgbmV3IFJ1bnRpbWVDb21waWxhdGlvblJlc291cmNlcyhwYXJlbnRDb250ZXh0KSwgZXhwb3J0cy5WaWV3Q29tcGlsZUZsYWdzLnN1cnJvZ2F0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZWRUZW1wbGF0ZSh0aGlzLCBwYXJlbnRDb250ZXh0LCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub1ZpZXdUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5SZW5kZXJpbmdFbmdpbmUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAga2VybmVsLmluamVjdChrZXJuZWwuSUNvbnRhaW5lciwgSUxpZmVjeWNsZSwgSU9ic2VydmVyTG9jYXRvciwgSUV2ZW50TWFuYWdlciwgSUV4cHJlc3Npb25QYXJzZXIsIGtlcm5lbC5hbGwoSVRlbXBsYXRlQ29tcGlsZXIpKVxuICAgICAgICAvKkBpbnRlcm5hbCovXG4gICAgXSwgZXhwb3J0cy5SZW5kZXJpbmdFbmdpbmUpO1xuICAgIGNvbnN0IGNoaWxkT2JzZXJ2ZXJPcHRpb25zJDEgPSB7IGNoaWxkTGlzdDogdHJ1ZSB9O1xuICAgIC8qQGludGVybmFsKi9cbiAgICBjbGFzcyBTaGFkb3dET01Qcm9qZWN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigkY3VzdG9tRWxlbWVudCwgaG9zdCwgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IERPTS5hdHRhY2hTaGFkb3coaG9zdCwgZGVmaW5pdGlvbi5zaGFkb3dPcHRpb25zIHx8IGRlZmF1bHRTaGFkb3dPcHRpb25zKTtcbiAgICAgICAgICAgIGhvc3QuJGN1c3RvbUVsZW1lbnQgPSAkY3VzdG9tRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC4kY3VzdG9tRWxlbWVudCA9ICRjdXN0b21FbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhvc3QuY2hpbGROb2RlcztcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVUb0NoaWxkcmVuQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBET00uY3JlYXRlTm9kZU9ic2VydmVyKHRoaXMuaG9zdCwgY2FsbGJhY2ssIGNoaWxkT2JzZXJ2ZXJPcHRpb25zJDEpO1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVFbmNhcHN1bGF0aW9uU291cmNlKHBhcmVudEVuY2Fwc3VsYXRpb25Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcHJvamVjdChub2Rlcykge1xuICAgICAgICAgICAgbm9kZXMuYXBwZW5kVG8odGhpcy5ob3N0KTtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdCA9IGtlcm5lbC5QTEFURk9STS5ub29wO1xuICAgICAgICB9XG4gICAgICAgIHRha2Uobm9kZXMpIHtcbiAgICAgICAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3IgaXMgcmVxdWlyZWQgYmVjYXVzZSB0aGUgaG9zdCBlbGVtZW50IHJlbW92YWxcbiAgICAgICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIHRoZSBwcm9qZWN0ZWQgbm9kZXMgYmVpbmcgcmVtb3ZlZCwgc2luY2UgdGhleSBhcmUgaW5cbiAgICAgICAgICAgIC8vIHRoZSBTaGFkb3dET00uXG4gICAgICAgIH1cbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNsYXNzIENvbnRhaW5lcmxlc3NQcm9qZWN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigkY3VzdG9tRWxlbWVudCwgaG9zdCkge1xuICAgICAgICAgICAgdGhpcy4kY3VzdG9tRWxlbWVudCA9ICRjdXN0b21FbGVtZW50O1xuICAgICAgICAgICAgaWYgKGhvc3QuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPSBrZXJuZWwuUExBVEZPUk0udG9BcnJheShob3N0LmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0ga2VybmVsLlBMQVRGT1JNLmVtcHR5QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3QgPSBET00uY29udmVydFRvUmVuZGVyTG9jYXRpb24oaG9zdCk7XG4gICAgICAgICAgICB0aGlzLmhvc3QuJGN1c3RvbUVsZW1lbnQgPSAkY3VzdG9tRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZVRvQ2hpbGRyZW5DaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgc2luY2UgdGhpcyBzY2VuYXJpbyB3aWxsIG5ldmVyIGhhdmUgY2hpbGRyZW4uXG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZUVuY2Fwc3VsYXRpb25Tb3VyY2UocGFyZW50RW5jYXBzdWxhdGlvblNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRFbmNhcHN1bGF0aW9uU291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRFbmNhcHN1bGF0aW9uU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHByb2plY3Qobm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRjdXN0b21FbGVtZW50LiRzdGF0ZSAmIDI1NiAvKiBuZWVkc01vdW50ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY3VzdG9tRWxlbWVudC4kc3RhdGUgJj0gfjI1NiAvKiBuZWVkc01vdW50ICovO1xuICAgICAgICAgICAgICAgIG5vZGVzLmluc2VydEJlZm9yZSh0aGlzLmhvc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRha2Uobm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuJGN1c3RvbUVsZW1lbnQuJHN0YXRlIHw9IDI1NiAvKiBuZWVkc01vdW50ICovO1xuICAgICAgICAgICAgbm9kZXMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNsYXNzIEhvc3RQcm9qZWN0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigkY3VzdG9tRWxlbWVudCwgaG9zdCkge1xuICAgICAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgICAgIGhvc3QuJGN1c3RvbUVsZW1lbnQgPSAkY3VzdG9tRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuaXNBcHBIb3N0ID0gaG9zdC5oYXNPd25Qcm9wZXJ0eSgnJGF1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIGtlcm5lbC5QTEFURk9STS5lbXB0eUFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZVRvQ2hpbGRyZW5DaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgc2luY2UgdGhpcyBzY2VuYXJpbyB3aWxsIG5ldmVyIGhhdmUgY2hpbGRyZW4uXG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZUVuY2Fwc3VsYXRpb25Tb3VyY2UocGFyZW50RW5jYXBzdWxhdGlvblNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudEVuY2Fwc3VsYXRpb25Tb3VyY2UgfHwgdGhpcy5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIHByb2plY3Qobm9kZXMpIHtcbiAgICAgICAgICAgIG5vZGVzLmFwcGVuZFRvKHRoaXMuaG9zdCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBcHBIb3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0ID0ga2VybmVsLlBMQVRGT1JNLm5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFrZShub2Rlcykge1xuICAgICAgICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBpcyByZXF1aXJlZCBiZWNhdXNlIHRoZSBob3N0IGVsZW1lbnQgcmVtb3ZhbFxuICAgICAgICAgICAgLy8gd2lsbCByZXN1bHQgaW4gdGhlIHByb2plY3RlZCBub2RlcyBiZWluZyByZW1vdmVkLCBzaW5jZSB0aGV5IGFyZSBjaGlsZHJlbi5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXBwSG9zdCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGF0IGlzIHRoZSBhcHAgaG9zdCwgd2hpY2ggaXMgbm90IHBhcnQgb2YgYSByZW1vdmFibGUgbm9kZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgIG5vZGVzLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjbGFzcyBSdW50aW1lQmVoYXZpb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgICAgICBzdGF0aWMgY3JlYXRlKENvbXBvbmVudCwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGJlaGF2aW9yID0gbmV3IFJ1bnRpbWVCZWhhdmlvcigpO1xuICAgICAgICAgICAgYmVoYXZpb3IuYmluZGFibGVzID0gQ29tcG9uZW50LmRlc2NyaXB0aW9uLmJpbmRhYmxlcztcbiAgICAgICAgICAgIHJldHVybiBiZWhhdmlvcjtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVRvKGluc3RhbmNlLCBsaWZlY3ljbGUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLiRsaWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgICAgICBpZiAoJyRwcm9qZWN0b3InIGluIGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVRvRWxlbWVudChsaWZlY3ljbGUsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUb0NvcmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGx5VG9FbGVtZW50KGxpZmVjeWNsZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuYXBwbHlUb0NvcmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLiRjaGlsZHJlbiA9IG5ldyBleHBvcnRzLkNoaWxkcmVuT2JzZXJ2ZXIobGlmZWN5Y2xlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCAnJGNoaWxkcmVuJywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kb2JzZXJ2ZXJzLiRjaGlsZHJlbi5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5VG9Db3JlKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRhYmxlcyA9IHRoaXMuYmluZGFibGVzO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYmluZGFibGVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG9ic2VydmFibGVOYW1lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IG9ic2VydmFibGVOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnNbbmFtZV0gPSBuZXcgZXhwb3J0cy5PYnNlcnZlcihpbnN0YW5jZSwgbmFtZSwgYmluZGFibGVzW25hbWVdLmNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVHZXR0ZXJTZXR0ZXIoaW5zdGFuY2UsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0YW5jZSwgJyRvYnNlcnZlcnMnLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9ic2VydmVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdldHRlclNldHRlcihpbnN0YW5jZSwgbmFtZSkge1xuICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCBuYW1lLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRvYnNlcnZlcnNbbmFtZV0uZ2V0VmFsdWUoKTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuJG9ic2VydmVyc1tuYW1lXS5zZXRWYWx1ZSh2YWx1ZSwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy51cGRhdGVUYXJnZXRJbnN0YW5jZSk7IH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBleHBvcnRzLkNoaWxkcmVuT2JzZXJ2ZXIgPSBjbGFzcyBDaGlsZHJlbk9ic2VydmVyIHtcbiAgICAgICAgY29uc3RydWN0b3IobGlmZWN5Y2xlLCBjdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxpZmVjeWNsZSA9IGxpZmVjeWNsZTtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRWxlbWVudCA9IGN1c3RvbUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vYnNlcnZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21FbGVtZW50LiRwcm9qZWN0b3Iuc3Vic2NyaWJlVG9DaGlsZHJlbkNoYW5nZSgoKSA9PiB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2VkKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBmaW5kRWxlbWVudHModGhpcy5jdXN0b21FbGVtZW50LiRwcm9qZWN0b3IuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWUobmV3VmFsdWUpIHsgfVxuICAgICAgICBmbHVzaChmbGFncykge1xuICAgICAgICAgICAgdGhpcy5jYWxsU3Vic2NyaWJlcnModGhpcy5jaGlsZHJlbiwgdW5kZWZpbmVkLCBmbGFncyB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MudXBkYXRlVGFyZ2V0SW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVN1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgb25DaGlsZHJlbkNoYW5nZWQoKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gZmluZEVsZW1lbnRzKHRoaXMuY3VzdG9tRWxlbWVudC4kcHJvamVjdG9yLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGlmICgnJGNoaWxkcmVuQ2hhbmdlZCcgaW4gdGhpcy5jdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21FbGVtZW50LiRjaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGlmZWN5Y2xlLmVucXVldWVGbHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuQ2hpbGRyZW5PYnNlcnZlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBzdWJzY3JpYmVyQ29sbGVjdGlvbihleHBvcnRzLk11dGF0aW9uS2luZC5pbnN0YW5jZSlcbiAgICBdLCBleHBvcnRzLkNoaWxkcmVuT2JzZXJ2ZXIpO1xuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiBmaW5kRWxlbWVudHMobm9kZXMpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBub2Rlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbm9kZXNbaV07XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjdXN0b21FbGVtZW50QmVoYXZpb3IoY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBjbGFzcyBSdW50aW1lQ29tcGlsYXRpb25SZXNvdXJjZXMge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGZpbmQoa2luZCwgbmFtZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2luZC5rZXlGcm9tKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2ZXIoa2V5LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgIT09IG51bGwgJiYgcmVzb2x2ZXIuZ2V0RmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSByZXNvbHZlci5nZXRGYWN0b3J5KHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGZhY3RvcnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkudHlwZS5kZXNjcmlwdGlvbiB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZShraW5kLCBuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBraW5kLmtleUZyb20obmFtZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmhhcyhrZXksIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIG1haW4gaW1wbGVtZW50YXRpb24gb2YgSVRlbXBsYXRlLlxuICAgIC8vIEl0IGlzIHVzZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBJVmlldyBiYXNlZCBvbiBhIGNvbXBpbGVkIFRlbXBsYXRlRGVmaW5pdGlvbi5cbiAgICAvLyBUZW1wbGF0ZURlZmluaXRpb25zIGFyZSBoYW5kLWNvZGVkIHRvZGF5LCBidXQgd2lsbCB1bHRpbWF0ZWx5IGJlIHRoZSBvdXRwdXQgb2YgdGhlXG4gICAgLy8gVGVtcGxhdGVDb21waWxlciBlaXRoZXIgdGhyb3VnaCBhIEpJVCBvciBBT1QgcHJvY2Vzcy5cbiAgICAvLyBFc3NlbnRpYWxseSwgQ29tcGlsZWRUZW1wbGF0ZSB3cmFwcyB1cCB0aGUgc21hbGwgYml0IG9mIGNvZGUgdGhhdCBpcyBuZWVkZWQgdG8gdGFrZSBhIFRlbXBsYXRlRGVmaW5pdGlvblxuICAgIC8vIGFuZCBjcmVhdGUgaW5zdGFuY2VzIG9mIGl0IG9uIGRlbWFuZC5cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgY2xhc3MgQ29tcGlsZWRUZW1wbGF0ZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJlbmRlcmluZ0VuZ2luZSwgcGFyZW50UmVuZGVyQ29udGV4dCwgdGVtcGxhdGVEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlRGVmaW5pdGlvbiA9IHRlbXBsYXRlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeSA9IE5vZGVTZXF1ZW5jZUZhY3RvcnkuY3JlYXRlRm9yKHRlbXBsYXRlRGVmaW5pdGlvbi50ZW1wbGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvbnRleHQgPSBjcmVhdGVSZW5kZXJDb250ZXh0KHJlbmRlcmluZ0VuZ2luZSwgcGFyZW50UmVuZGVyQ29udGV4dCwgdGVtcGxhdGVEZWZpbml0aW9uLmRlcGVuZGVuY2llcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKHJlbmRlcmFibGUsIGhvc3QsIHBhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IHJlbmRlcmFibGUuJG5vZGVzID0gdGhpcy5mYWN0b3J5LmNyZWF0ZU5vZGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgcmVuZGVyYWJsZS4kY29udGV4dCA9IHRoaXMucmVuZGVyQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ29udGV4dC5yZW5kZXIocmVuZGVyYWJsZSwgbm9kZXMuZmluZFRhcmdldHMoKSwgdGhpcy50ZW1wbGF0ZURlZmluaXRpb24sIGhvc3QsIHBhcnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIElUZW1wbGF0ZSB0aGF0IGFsd2F5cyByZXR1cm5zIGEgbm9kZSBzZXF1ZW5jZSByZXByZXNlbnRpbmcgXCJubyBET01cIiB0byByZW5kZXIuXG4gICAgLypAaW50ZXJuYWwqL1xuICAgIGNvbnN0IG5vVmlld1RlbXBsYXRlID0ge1xuICAgICAgICByZW5kZXJDb250ZXh0OiBudWxsLFxuICAgICAgICByZW5kZXIocmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZS4kbm9kZXMgPSBOb2RlU2VxdWVuY2UuZW1wdHk7XG4gICAgICAgICAgICByZW5kZXJhYmxlLiRjb250ZXh0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyQ29udGV4dChyZW5kZXJpbmdFbmdpbmUsIHBhcmVudFJlbmRlckNvbnRleHQsIGRlcGVuZGVuY2llcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gcGFyZW50UmVuZGVyQ29udGV4dC5jcmVhdGVDaGlsZCgpO1xuICAgICAgICBjb25zdCByZW5kZXJhYmxlUHJvdmlkZXIgPSBuZXcgSW5zdGFuY2VQcm92aWRlcigpO1xuICAgICAgICBjb25zdCBlbGVtZW50UHJvdmlkZXIgPSBuZXcgSW5zdGFuY2VQcm92aWRlcigpO1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvblByb3ZpZGVyID0gbmV3IEluc3RhbmNlUHJvdmlkZXIoKTtcbiAgICAgICAgY29uc3QgZmFjdG9yeVByb3ZpZGVyID0gbmV3IFZpZXdGYWN0b3J5UHJvdmlkZXIocmVuZGVyaW5nRW5naW5lKTtcbiAgICAgICAgY29uc3QgcmVuZGVyTG9jYXRpb25Qcm92aWRlciA9IG5ldyBJbnN0YW5jZVByb3ZpZGVyKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gcmVuZGVyaW5nRW5naW5lLmNyZWF0ZVJlbmRlcmVyKGNvbnRleHQpO1xuICAgICAgICBET00ucmVnaXN0ZXJFbGVtZW50UmVzb2x2ZXIoY29udGV4dCwgZWxlbWVudFByb3ZpZGVyKTtcbiAgICAgICAgY29udGV4dC5yZWdpc3RlclJlc29sdmVyKElWaWV3RmFjdG9yeSwgZmFjdG9yeVByb3ZpZGVyKTtcbiAgICAgICAgY29udGV4dC5yZWdpc3RlclJlc29sdmVyKElSZW5kZXJhYmxlLCByZW5kZXJhYmxlUHJvdmlkZXIpO1xuICAgICAgICBjb250ZXh0LnJlZ2lzdGVyUmVzb2x2ZXIoSVRhcmdldGVkSW5zdHJ1Y3Rpb24sIGluc3RydWN0aW9uUHJvdmlkZXIpO1xuICAgICAgICBjb250ZXh0LnJlZ2lzdGVyUmVzb2x2ZXIoSVJlbmRlckxvY2F0aW9uLCByZW5kZXJMb2NhdGlvblByb3ZpZGVyKTtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgY29udGV4dC5yZWdpc3RlciguLi5kZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlcmFibGUsIHRhcmdldHMsIHRlbXBsYXRlRGVmaW5pdGlvbiwgaG9zdCwgcGFydHMpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihyZW5kZXJhYmxlLCB0YXJnZXRzLCB0ZW1wbGF0ZURlZmluaXRpb24sIGhvc3QsIHBhcnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29udGV4dC5iZWdpbkNvbXBvbmVudE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uLCBmYWN0b3J5LCBwYXJ0cywgbG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGVQcm92aWRlci5wcmVwYXJlKHJlbmRlcmFibGUpO1xuICAgICAgICAgICAgZWxlbWVudFByb3ZpZGVyLnByZXBhcmUodGFyZ2V0KTtcbiAgICAgICAgICAgIGluc3RydWN0aW9uUHJvdmlkZXIucHJlcGFyZShpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnlQcm92aWRlci5wcmVwYXJlKGZhY3RvcnksIHBhcnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHJlbmRlckxvY2F0aW9uUHJvdmlkZXIucHJlcGFyZShsb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgY29udGV4dC5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmFjdG9yeVByb3ZpZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHJlbmRlcmFibGVQcm92aWRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvblByb3ZpZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGVsZW1lbnRQcm92aWRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICByZW5kZXJMb2NhdGlvblByb3ZpZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBjbGFzcyBJbnN0YW5jZVByb3ZpZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmVwYXJlKGluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHsgLy8gdW5tZXQgcHJlY29uZGl0aW9uOiBjYWxsIHByZXBhcmVcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoNTApOyAvLyBUT0RPOiBvcmdhbml6ZSBlcnJvciBjb2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qQGludGVybmFsKi9cbiAgICBjbGFzcyBWaWV3RmFjdG9yeVByb3ZpZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IocmVuZGVyaW5nRW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ0VuZ2luZSA9IHJlbmRlcmluZ0VuZ2luZTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwYXJlKGZhY3RvcnksIHBhcnRzKSB7XG4gICAgICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlbWVudHMgPSBwYXJ0cyB8fCBrZXJuZWwuUExBVEZPUk0uZW1wdHlPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmZhY3Rvcnk7XG4gICAgICAgICAgICBpZiAoZmFjdG9yeSA9PT0gdW5kZWZpbmVkKSB7IC8vIHVubWV0IHByZWNvbmRpdGlvbjogY2FsbCBwcmVwYXJlXG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDUwKTsgLy8gVE9ETzogb3JnYW5pemUgZXJyb3IgY29kZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmFjdG9yeS5uYW1lIHx8ICFmYWN0b3J5Lm5hbWUubGVuZ3RoKSB7IC8vIHVubWV0IGludmFyaWFudDogZmFjdG9yeSBtdXN0IGhhdmUgYSBuYW1lXG4gICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDUxKTsgLy8gVE9ETzogb3JnYW5pemUgZXJyb3IgY29kZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5yZXBsYWNlbWVudHNbZmFjdG9yeS5uYW1lXTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmluZ0VuZ2luZS5nZXRWaWV3RmFjdG9yeShmb3VuZCwgcmVxdWVzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VtZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQmluZGFibGUocmVuZGVyYWJsZSwgYmluZGFibGUpIHtcbiAgICAgICAgYmluZGFibGUuJHByZXZCaW5kID0gcmVuZGVyYWJsZS4kYmluZGFibGVUYWlsO1xuICAgICAgICBiaW5kYWJsZS4kbmV4dEJpbmQgPSBudWxsO1xuICAgICAgICBpZiAocmVuZGVyYWJsZS4kYmluZGFibGVUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlLiRiaW5kYWJsZUhlYWQgPSBiaW5kYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGUuJGJpbmRhYmxlVGFpbC4kbmV4dEJpbmQgPSBiaW5kYWJsZTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJhYmxlLiRiaW5kYWJsZVRhaWwgPSBiaW5kYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQXR0YWNoYWJsZShyZW5kZXJhYmxlLCBhdHRhY2hhYmxlKSB7XG4gICAgICAgIGF0dGFjaGFibGUuJHByZXZBdHRhY2ggPSByZW5kZXJhYmxlLiRhdHRhY2hhYmxlVGFpbDtcbiAgICAgICAgYXR0YWNoYWJsZS4kbmV4dEF0dGFjaCA9IG51bGw7XG4gICAgICAgIGlmIChyZW5kZXJhYmxlLiRhdHRhY2hhYmxlVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZS4kYXR0YWNoYWJsZUhlYWQgPSBhdHRhY2hhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyYWJsZS4kYXR0YWNoYWJsZVRhaWwuJG5leHRBdHRhY2ggPSBhdHRhY2hhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmFibGUuJGF0dGFjaGFibGVUYWlsID0gYXR0YWNoYWJsZTtcbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGU6ZnVuY3Rpb24tbmFtZVxuICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWFueVxuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIGNsYXNzIFJlbmRlcmVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoY29udGV4dCwgb2JzZXJ2ZXJMb2NhdG9yLCBldmVudE1hbmFnZXIsIHBhcnNlciwgcmVuZGVyaW5nRW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdFbmdpbmUgPSByZW5kZXJpbmdFbmdpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKHJlbmRlcmFibGUsIHRhcmdldHMsIGRlZmluaXRpb24sIGhvc3QsIHBhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbnN0cnVjdGlvbnMgPSBkZWZpbml0aW9uLmluc3RydWN0aW9ucztcbiAgICAgICAgICAgIGlmICh0YXJnZXRzLmxlbmd0aCAhPT0gdGFyZ2V0SW5zdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRzLmxlbmd0aCA+IHRhcmdldEluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cga2VybmVsLlJlcG9ydGVyLmVycm9yKDMwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGtlcm5lbC5SZXBvcnRlci5lcnJvcigzMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gdGFyZ2V0SW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGluc3RydWN0aW9uc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tjdXJyZW50LnR5cGVdKHJlbmRlcmFibGUsIHRhcmdldCwgY3VycmVudCwgcGFydHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob3N0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vycm9nYXRlSW5zdHJ1Y3Rpb25zID0gZGVmaW5pdGlvbi5zdXJyb2dhdGVzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHN1cnJvZ2F0ZUluc3RydWN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdXJyb2dhdGVJbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbY3VycmVudC50eXBlXShyZW5kZXJhYmxlLCBob3N0LCBjdXJyZW50LCBwYXJ0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGVFbGVtZW50SW5zdGFuY2UocmVuZGVyYWJsZSwgdGFyZ2V0LCBpbnN0cnVjdGlvbiwgY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9uLmluc3RydWN0aW9ucztcbiAgICAgICAgICAgIGNvbXBvbmVudC4kaHlkcmF0ZSh0aGlzLnJlbmRlcmluZ0VuZ2luZSwgdGFyZ2V0LCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZEluc3RydWN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkSW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUeXBlID0gY3VycmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHRoaXNbY3VycmVudFR5cGVdKHJlbmRlcmFibGUsIGNvbXBvbmVudCwgY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRCaW5kYWJsZShyZW5kZXJhYmxlLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgYWRkQXR0YWNoYWJsZShyZW5kZXJhYmxlLCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIFtcImFcIiAvKiB0ZXh0QmluZGluZyAqL10ocmVuZGVyYWJsZSwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRhcmdldC5uZXh0U2libGluZztcbiAgICAgICAgICAgIERPTS50cmVhdEFzTm9uV2hpdGVzcGFjZShuZXh0KTtcbiAgICAgICAgICAgIERPTS5yZW1vdmUodGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0ICRmcm9tID0gaW5zdHJ1Y3Rpb24uZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSAoJGZyb20uJGtpbmQgPyAkZnJvbSA6IHRoaXMucGFyc2VyLnBhcnNlKCRmcm9tLCAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8pKTtcbiAgICAgICAgICAgIGlmIChleHByLmlzTXVsdGkpIHtcbiAgICAgICAgICAgICAgICBhZGRCaW5kYWJsZShyZW5kZXJhYmxlLCBuZXcgTXVsdGlJbnRlcnBvbGF0aW9uQmluZGluZyh0aGlzLm9ic2VydmVyTG9jYXRvciwgZXhwciwgbmV4dCwgJ3RleHRDb250ZW50JywgZXhwb3J0cy5CaW5kaW5nTW9kZS50b1ZpZXcsIHRoaXMuY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQmluZGFibGUocmVuZGVyYWJsZSwgbmV3IGV4cG9ydHMuSW50ZXJwb2xhdGlvbkJpbmRpbmcoZXhwci5maXJzdEV4cHJlc3Npb24sIGV4cHIsIG5leHQsICd0ZXh0Q29udGVudCcsIGV4cG9ydHMuQmluZGluZ01vZGUudG9WaWV3LCB0aGlzLm9ic2VydmVyTG9jYXRvciwgdGhpcy5jb250ZXh0LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgW1wiYlwiIC8qIGludGVycG9sYXRpb24gKi9dKHJlbmRlcmFibGUsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0ICRmcm9tID0gaW5zdHJ1Y3Rpb24uZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSAoJGZyb20uJGtpbmQgPyAkZnJvbSA6IHRoaXMucGFyc2VyLnBhcnNlKCRmcm9tLCAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8pKTtcbiAgICAgICAgICAgIGlmIChleHByLmlzTXVsdGkpIHtcbiAgICAgICAgICAgICAgICBhZGRCaW5kYWJsZShyZW5kZXJhYmxlLCBuZXcgTXVsdGlJbnRlcnBvbGF0aW9uQmluZGluZyh0aGlzLm9ic2VydmVyTG9jYXRvciwgZXhwciwgdGFyZ2V0LCBpbnN0cnVjdGlvbi50bywgZXhwb3J0cy5CaW5kaW5nTW9kZS50b1ZpZXcsIHRoaXMuY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQmluZGFibGUocmVuZGVyYWJsZSwgbmV3IGV4cG9ydHMuSW50ZXJwb2xhdGlvbkJpbmRpbmcoZXhwci5maXJzdEV4cHJlc3Npb24sIGV4cHIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24udG8sIGV4cG9ydHMuQmluZGluZ01vZGUudG9WaWV3LCB0aGlzLm9ic2VydmVyTG9jYXRvciwgdGhpcy5jb250ZXh0LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgW1wiY1wiIC8qIHByb3BlcnR5QmluZGluZyAqL10ocmVuZGVyYWJsZSwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgJGZyb20gPSBpbnN0cnVjdGlvbi5mcm9tO1xuICAgICAgICAgICAgYWRkQmluZGFibGUocmVuZGVyYWJsZSwgbmV3IGV4cG9ydHMuQmluZGluZygkZnJvbS4ka2luZCA/ICRmcm9tIDogdGhpcy5wYXJzZXIucGFyc2UoJGZyb20sIDQ4IC8qIElzUHJvcGVydHlDb21tYW5kICovIHwgaW5zdHJ1Y3Rpb24ubW9kZSksIHRhcmdldCwgaW5zdHJ1Y3Rpb24udG8sIGluc3RydWN0aW9uLm1vZGUsIHRoaXMub2JzZXJ2ZXJMb2NhdG9yLCB0aGlzLmNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBbXCJkXCIgLyogaXRlcmF0b3JCaW5kaW5nICovXShyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCAkZnJvbSA9IGluc3RydWN0aW9uLmZyb207XG4gICAgICAgICAgICBhZGRCaW5kYWJsZShyZW5kZXJhYmxlLCBuZXcgZXhwb3J0cy5CaW5kaW5nKCRmcm9tLiRraW5kID8gJGZyb20gOiB0aGlzLnBhcnNlci5wYXJzZSgkZnJvbSwgNTM5IC8qIEZvckNvbW1hbmQgKi8pLCB0YXJnZXQsIGluc3RydWN0aW9uLnRvLCBleHBvcnRzLkJpbmRpbmdNb2RlLnRvVmlldywgdGhpcy5vYnNlcnZlckxvY2F0b3IsIHRoaXMuY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIFtcImVcIiAvKiBsaXN0ZW5lckJpbmRpbmcgKi9dKHJlbmRlcmFibGUsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0ICRmcm9tID0gaW5zdHJ1Y3Rpb24uZnJvbTtcbiAgICAgICAgICAgIGFkZEJpbmRhYmxlKHJlbmRlcmFibGUsIG5ldyBMaXN0ZW5lcihpbnN0cnVjdGlvbi50bywgaW5zdHJ1Y3Rpb24uc3RyYXRlZ3ksICRmcm9tLiRraW5kID8gJGZyb20gOiB0aGlzLnBhcnNlci5wYXJzZSgkZnJvbSwgODAgLyogSXNFdmVudENvbW1hbmQgKi8gfCAoaW5zdHJ1Y3Rpb24uc3RyYXRlZ3kgKyA2IC8qIERlbGVnYXRpb25TdHJhdGVneURlbHRhICovKSksIHRhcmdldCwgaW5zdHJ1Y3Rpb24ucHJldmVudERlZmF1bHQsIHRoaXMuZXZlbnRNYW5hZ2VyLCB0aGlzLmNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBbXCJmXCIgLyogY2FsbEJpbmRpbmcgKi9dKHJlbmRlcmFibGUsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0ICRmcm9tID0gaW5zdHJ1Y3Rpb24uZnJvbTtcbiAgICAgICAgICAgIGFkZEJpbmRhYmxlKHJlbmRlcmFibGUsIG5ldyBDYWxsKCRmcm9tLiRraW5kID8gJGZyb20gOiB0aGlzLnBhcnNlci5wYXJzZSgkZnJvbSwgMTUzIC8qIENhbGxDb21tYW5kICovKSwgdGFyZ2V0LCBpbnN0cnVjdGlvbi50bywgdGhpcy5vYnNlcnZlckxvY2F0b3IsIHRoaXMuY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIFtcImdcIiAvKiByZWZCaW5kaW5nICovXShyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCAkZnJvbSA9IGluc3RydWN0aW9uLmZyb207XG4gICAgICAgICAgICBhZGRCaW5kYWJsZShyZW5kZXJhYmxlLCBuZXcgUmVmKCRmcm9tLiRraW5kID8gJGZyb20gOiB0aGlzLnBhcnNlci5wYXJzZSgkZnJvbSwgMTI4MCAvKiBJc1JlZiAqLyksIHRhcmdldCwgdGhpcy5jb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgW1wiaFwiIC8qIHN0eWxlUHJvcGVydHlCaW5kaW5nICovXShyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCAkZnJvbSA9IGluc3RydWN0aW9uLmZyb207XG4gICAgICAgICAgICBhZGRCaW5kYWJsZShyZW5kZXJhYmxlLCBuZXcgZXhwb3J0cy5CaW5kaW5nKCRmcm9tLiRraW5kID8gJGZyb20gOiB0aGlzLnBhcnNlci5wYXJzZSgkZnJvbSwgNDggLyogSXNQcm9wZXJ0eUNvbW1hbmQgKi8gfCBleHBvcnRzLkJpbmRpbmdNb2RlLnRvVmlldyksIHRhcmdldC5zdHlsZSwgaW5zdHJ1Y3Rpb24udG8sIGV4cG9ydHMuQmluZGluZ01vZGUudG9WaWV3LCB0aGlzLm9ic2VydmVyTG9jYXRvciwgdGhpcy5jb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgW1wiaVwiIC8qIHNldFByb3BlcnR5ICovXShyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB0YXJnZXRbaW5zdHJ1Y3Rpb24udG9dID0gaW5zdHJ1Y3Rpb24udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgW1wialwiIC8qIHNldEF0dHJpYnV0ZSAqL10ocmVuZGVyYWJsZSwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgRE9NLnNldEF0dHJpYnV0ZSh0YXJnZXQsIGluc3RydWN0aW9uLnRvLCBpbnN0cnVjdGlvbi52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgW1wia1wiIC8qIGh5ZHJhdGVFbGVtZW50ICovXShyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gY29udGV4dC5iZWdpbkNvbXBvbmVudE9wZXJhdGlvbihyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uLCBudWxsLCBudWxsLCB0YXJnZXQsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29udGV4dC5nZXQoY3VzdG9tRWxlbWVudEtleShpbnN0cnVjdGlvbi5yZXMpKTtcbiAgICAgICAgICAgIHRoaXMuaHlkcmF0ZUVsZW1lbnRJbnN0YW5jZShyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgb3BlcmF0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBbXCJsXCIgLyogaHlkcmF0ZUF0dHJpYnV0ZSAqL10ocmVuZGVyYWJsZSwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gY29udGV4dC5iZWdpbkNvbXBvbmVudE9wZXJhdGlvbihyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbnRleHQuZ2V0KGN1c3RvbUF0dHJpYnV0ZUtleShpbnN0cnVjdGlvbi5yZXMpKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC4kaHlkcmF0ZSh0aGlzLnJlbmRlcmluZ0VuZ2luZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZEluc3RydWN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkSW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIHRoaXNbY3VycmVudC50eXBlXShyZW5kZXJhYmxlLCBjb21wb25lbnQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQmluZGFibGUocmVuZGVyYWJsZSwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIGFkZEF0dGFjaGFibGUocmVuZGVyYWJsZSwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgW1wibVwiIC8qIGh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIgKi9dKHJlbmRlcmFibGUsIHRhcmdldCwgaW5zdHJ1Y3Rpb24sIHBhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9uLmluc3RydWN0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlbmRlcmluZ0VuZ2luZS5nZXRWaWV3RmFjdG9yeShpbnN0cnVjdGlvbi5kZWYsIHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gY29udGV4dC5iZWdpbkNvbXBvbmVudE9wZXJhdGlvbihyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uLCBmYWN0b3J5LCBwYXJ0cywgRE9NLmNvbnZlcnRUb1JlbmRlckxvY2F0aW9uKHRhcmdldCksIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbnRleHQuZ2V0KGN1c3RvbUF0dHJpYnV0ZUtleShpbnN0cnVjdGlvbi5yZXMpKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC4kaHlkcmF0ZSh0aGlzLnJlbmRlcmluZ0VuZ2luZSk7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubGluaykge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5saW5rKHJlbmRlcmFibGUuJGF0dGFjaGFibGVUYWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoaWxkSW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gY2hpbGRJbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgdGhpc1tjdXJyZW50LnR5cGVdKHJlbmRlcmFibGUsIGNvbXBvbmVudCwgY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRCaW5kYWJsZShyZW5kZXJhYmxlLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgYWRkQXR0YWNoYWJsZShyZW5kZXJhYmxlLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgb3BlcmF0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBbXCJ6XCIgLyogcmVuZGVyU3RyYXRlZ3kgKi9dKHJlbmRlcmFibGUsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5TmFtZSA9IGluc3RydWN0aW9uLm5hbWU7XG4gICAgICAgICAgICBpZiAodGhpc1tzdHJhdGVneU5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuY29udGV4dC5nZXQoUmVuZGVyU3RyYXRlZ3lSZXNvdXJjZS5rZXlGcm9tKHN0cmF0ZWd5TmFtZSkpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSA9PT0gbnVsbCB8fCBzdHJhdGVneSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biByZW5kZXJTdHJhdGVneSBcIiR7c3RyYXRlZ3lOYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbc3RyYXRlZ3lOYW1lXSA9IHN0cmF0ZWd5LnJlbmRlci5iaW5kKHN0cmF0ZWd5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbc3RyYXRlZ3lOYW1lXShyZW5kZXJhYmxlLCB0YXJnZXQsIGluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBbXCJuXCIgLyogbGV0RWxlbWVudCAqL10ocmVuZGVyYWJsZSwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB0b1ZpZXdNb2RlbCA9IGluc3RydWN0aW9uLnRvVmlld01vZGVsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2hpbGRJbnN0cnVjdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkSW5zdHJ1Y3Rpb24gPSBjaGlsZEluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCAkZnJvbSA9IGNoaWxkSW5zdHJ1Y3Rpb24uZnJvbTtcbiAgICAgICAgICAgICAgICBhZGRCaW5kYWJsZShyZW5kZXJhYmxlLCBuZXcgZXhwb3J0cy5MZXRCaW5kaW5nKCRmcm9tLiRraW5kID8gJGZyb20gOiB0aGlzLnBhcnNlci5wYXJzZSgkZnJvbSwgNDggLyogSXNQcm9wZXJ0eUNvbW1hbmQgKi8pLCBjaGlsZEluc3RydWN0aW9uLnRvLCB0aGlzLm9ic2VydmVyTG9jYXRvciwgdGhpcy5jb250ZXh0LCB0b1ZpZXdNb2RlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb3JhdG9yOiBJbmRpY2F0ZXMgdGhhdCB0aGUgZGVjb3JhdGVkIGNsYXNzIGlzIGEgY3VzdG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRWxlbWVudChuYW1lT3JTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldCA9PiBDdXN0b21FbGVtZW50UmVzb3VyY2UuZGVmaW5lKG5hbWVPclNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU2hhZG93RE9NKHRhcmdldE9yT3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHRhcmdldE9yT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCAhdGFyZ2V0T3JPcHRpb25zXG4gICAgICAgICAgICA/IGRlZmF1bHRTaGFkb3dPcHRpb25zXG4gICAgICAgICAgICA6IHRhcmdldE9yT3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gdXNlU2hhZG93RE9NRGVjb3JhdG9yKHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0LnNoYWRvd09wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHRhcmdldE9yT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IHVzZVNoYWRvd0RPTURlY29yYXRvcih0YXJnZXRPck9wdGlvbnMpIDogdXNlU2hhZG93RE9NRGVjb3JhdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluZXJsZXNzRGVjb3JhdG9yKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuY29udGFpbmVybGVzcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5lcmxlc3ModGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGNvbnRhaW5lcmxlc3NEZWNvcmF0b3IgOiBjb250YWluZXJsZXNzRGVjb3JhdG9yKHRhcmdldCk7XG4gICAgfVxuICAgIGNvbnN0IEN1c3RvbUVsZW1lbnRSZXNvdXJjZSA9IHtcbiAgICAgICAgbmFtZTogY3VzdG9tRWxlbWVudE5hbWUsXG4gICAgICAgIGtleUZyb206IGN1c3RvbUVsZW1lbnRLZXksXG4gICAgICAgIGlzVHlwZShUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZS5raW5kID09PSB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBiZWhhdmlvckZvcjogY3VzdG9tRWxlbWVudEJlaGF2aW9yLFxuICAgICAgICBkZWZpbmUobmFtZU9yU291cmNlLCBjdG9yID0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFuYW1lT3JTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBrZXJuZWwuUmVwb3J0ZXIuZXJyb3IoNzApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgVHlwZSA9IChjdG9yID09PSBudWxsID8gY2xhc3MgSFRNTE9ubHlFbGVtZW50IHtcbiAgICAgICAgICAgIH0gOiBjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYnVpbGRUZW1wbGF0ZURlZmluaXRpb24oVHlwZSwgbmFtZU9yU291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gVHlwZS5wcm90b3R5cGU7XG4gICAgICAgICAgICBUeXBlLmtpbmQgPSBDdXN0b21FbGVtZW50UmVzb3VyY2U7XG4gICAgICAgICAgICBUeXBlLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICBUeXBlLnJlZ2lzdGVyID0gcmVnaXN0ZXJFbGVtZW50O1xuICAgICAgICAgICAgcHJvdG8uJGh5ZHJhdGUgPSAkaHlkcmF0ZUVsZW1lbnQ7XG4gICAgICAgICAgICBwcm90by4kYmluZCA9ICRiaW5kRWxlbWVudDtcbiAgICAgICAgICAgIHByb3RvLiRhdHRhY2ggPSAkYXR0YWNoRWxlbWVudDtcbiAgICAgICAgICAgIHByb3RvLiRkZXRhY2ggPSAkZGV0YWNoRWxlbWVudDtcbiAgICAgICAgICAgIHByb3RvLiR1bmJpbmQgPSAkdW5iaW5kRWxlbWVudDtcbiAgICAgICAgICAgIHByb3RvLiRjYWNoZSA9ICRjYWNoZUVsZW1lbnQ7XG4gICAgICAgICAgICBwcm90by4kcHJldkJpbmQgPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uJG5leHRCaW5kID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLiRwcmV2QXR0YWNoID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLiRuZXh0QXR0YWNoID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLiRuZXh0VW5iaW5kQWZ0ZXJEZXRhY2ggPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uJHNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLiRob29rcyA9IDA7XG4gICAgICAgICAgICBwcm90by4kc3RhdGUgPSAyNTYgLyogbmVlZHNNb3VudCAqLztcbiAgICAgICAgICAgIHByb3RvLiRiaW5kYWJsZUhlYWQgPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uJGJpbmRhYmxlVGFpbCA9IG51bGw7XG4gICAgICAgICAgICBwcm90by4kYXR0YWNoYWJsZUhlYWQgPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uJGF0dGFjaGFibGVUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLiRtb3VudCA9ICRtb3VudEVsZW1lbnQ7XG4gICAgICAgICAgICBwcm90by4kdW5tb3VudCA9ICR1bm1vdW50RWxlbWVudDtcbiAgICAgICAgICAgIHByb3RvLiRuZXh0TW91bnQgPSBudWxsO1xuICAgICAgICAgICAgcHJvdG8uJG5leHRVbm1vdW50ID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLiRwcm9qZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCdmbHVzaCcgaW4gcHJvdG8pIHtcbiAgICAgICAgICAgICAgICBwcm90by4kbmV4dEZsdXNoID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnYmluZGluZycgaW4gcHJvdG8pXG4gICAgICAgICAgICAgICAgcHJvdG8uJGhvb2tzIHw9IDQgLyogaGFzQmluZGluZyAqLztcbiAgICAgICAgICAgIGlmICgnYm91bmQnIGluIHByb3RvKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uJGhvb2tzIHw9IDggLyogaGFzQm91bmQgKi87XG4gICAgICAgICAgICAgICAgcHJvdG8uJG5leHRCb3VuZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3VuYmluZGluZycgaW4gcHJvdG8pXG4gICAgICAgICAgICAgICAgcHJvdG8uJGhvb2tzIHw9IDI1NiAvKiBoYXNVbmJpbmRpbmcgKi87XG4gICAgICAgICAgICBpZiAoJ3VuYm91bmQnIGluIHByb3RvKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uJGhvb2tzIHw9IDUxMiAvKiBoYXNVbmJvdW5kICovO1xuICAgICAgICAgICAgICAgIHByb3RvLiRuZXh0VW5ib3VuZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3JlbmRlcicgaW4gcHJvdG8pXG4gICAgICAgICAgICAgICAgcHJvdG8uJGhvb2tzIHw9IDEwMjQgLyogaGFzUmVuZGVyICovO1xuICAgICAgICAgICAgaWYgKCdjcmVhdGVkJyBpbiBwcm90bylcbiAgICAgICAgICAgICAgICBwcm90by4kaG9va3MgfD0gMiAvKiBoYXNDcmVhdGVkICovO1xuICAgICAgICAgICAgaWYgKCdhdHRhY2hpbmcnIGluIHByb3RvKVxuICAgICAgICAgICAgICAgIHByb3RvLiRob29rcyB8PSAxNiAvKiBoYXNBdHRhY2hpbmcgKi87XG4gICAgICAgICAgICBpZiAoJ2F0dGFjaGVkJyBpbiBwcm90bykge1xuICAgICAgICAgICAgICAgIHByb3RvLiRob29rcyB8PSAzMiAvKiBoYXNBdHRhY2hlZCAqLztcbiAgICAgICAgICAgICAgICBwcm90by4kbmV4dEF0dGFjaGVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnZGV0YWNoaW5nJyBpbiBwcm90bylcbiAgICAgICAgICAgICAgICBwcm90by4kaG9va3MgfD0gNjQgLyogaGFzRGV0YWNoaW5nICovO1xuICAgICAgICAgICAgaWYgKCdjYWNoaW5nJyBpbiBwcm90bylcbiAgICAgICAgICAgICAgICBwcm90by4kaG9va3MgfD0gMjA0OCAvKiBoYXNDYWNoaW5nICovO1xuICAgICAgICAgICAgaWYgKCdkZXRhY2hlZCcgaW4gcHJvdG8pIHtcbiAgICAgICAgICAgICAgICBwcm90by4kaG9va3MgfD0gMTI4IC8qIGhhc0RldGFjaGVkICovO1xuICAgICAgICAgICAgICAgIHByb3RvLiRuZXh0RGV0YWNoZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiByZWdpc3RlckVsZW1lbnQoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlS2V5ID0gQ3VzdG9tRWxlbWVudFJlc291cmNlLmtleUZyb20odGhpcy5kZXNjcmlwdGlvbi5uYW1lKTtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyKGtlcm5lbC5SZWdpc3RyYXRpb24udHJhbnNpZW50KHJlc291cmNlS2V5LCB0aGlzKSk7XG4gICAgfVxuICAgIC8vIHRzbGludDplbmFibGU6YWxpZ25cbiAgICAvLyBUT0RPXG4gICAgLy8gIyMgRGVmYXVsdFNsb3RQcm9qZWN0b3JcbiAgICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiBJRWxlbWVudFByb2plY3RvciB0aGF0IGNhbiBoYW5kbGUgYSBzdWJzZXQgb2YgZGVmYXVsdFxuICAgIC8vIHNsb3QgcHJvamVjdGlvbiBzY2VuYXJpb3Mgd2l0aG91dCBuZWVkaW5nIHJlYWwgU2hhZG93IERPTS5cbiAgICAvLyAjIyMgQ29uZGl0aW9uc1xuICAgIC8vIFdlIGNhbiBkbyBhIG9uZS10aW1lLCBzdGF0aWMgY29tcG9zaXRpb24gb2YgdGhlIGNvbnRlbnQgYW5kIHZpZXcsXG4gICAgLy8gdG8gZW11bGF0ZSBzaGFkb3cgRE9NLCBpZiB0aGUgZm9sbG93aW5nIGNvbnN0cmFpbnRzIGFyZSBtZXQ6XG4gICAgLy8gKiBUaGVyZSBtdXN0IGJlIGV4YWN0bHkgb25lIHNsb3QgYW5kIGl0IG11c3QgYmUgYSBkZWZhdWx0IHNsb3QuXG4gICAgLy8gKiBUaGUgZGVmYXVsdCBzbG90IG11c3Qgbm90IGhhdmUgYW55IGZhbGxiYWNrIGNvbnRlbnQuXG4gICAgLy8gKiBUaGUgZGVmYXVsdCBzbG90IG11c3Qgbm90IGhhdmUgYSBjdXN0b20gZWxlbWVudCBhcyBpdHMgaW1tZWRpYXRlIHBhcmVudCBvclxuICAgIC8vICAgYSBzbG90IGF0dHJpYnV0ZSAocmUtcHJvamVjdGlvbikuXG4gICAgLy8gIyMjIFByb2plY3Rpb25cbiAgICAvLyBUaGUgcHJvamVjdG9yIGNvcGllcyBhbGwgY29udGVudCBub2RlcyB0byB0aGUgc2xvdCdzIGxvY2F0aW9uLlxuICAgIC8vIFRoZSBjb3B5IHByb2Nlc3Mgc2hvdWxkIGluamVjdCBhIGNvbW1lbnQgbm9kZSBiZWZvcmUgYW5kIGFmdGVyIHRoZSBzbG90dGVkXG4gICAgLy8gY29udGVudCwgc28gdGhhdCB0aGUgYm91bmRzIG9mIHRoZSBjb250ZW50IGNhbiBiZSBjbGVhcmx5IGRldGVybWluZWQsXG4gICAgLy8gZXZlbiBpZiB0aGUgc2xvdHRlZCBjb250ZW50IGhhcyB0ZW1wbGF0ZSBjb250cm9sbGVycyBvciBzdHJpbmcgaW50ZXJwb2xhdGlvbi5cbiAgICAvLyAjIyMgRW5jYXBzdWxhdGlvbiBTb3VyY2VcbiAgICAvLyBVc2VzIHRoZSBzYW1lIHN0cmF0ZWd5IGFzIEhvc3RQcm9qZWN0b3IuXG4gICAgLy8gIyMjIENoaWxkcmVuXG4gICAgLy8gVGhlIHByb2plY3RvciBhZGRzIGEgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZVxuICAgIC8vIHNsb3QgY29tbWVudC4gV2hlbiBkaXJlY3QgY2hpbGRyZW4gb2YgdGhhdCBub2RlIGNoYW5nZSwgdGhlIHByb2plY3RvclxuICAgIC8vIHdpbGwgZ2F0aGVyIHVwIGFsbCBub2RlcyBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHNsb3QgY29tbWVudHMuXG5cbiAgICBjb25zdCBjb21wb3NlU291cmNlID0ge1xuICAgICAgICBuYW1lOiAnYXUtY29tcG9zZScsXG4gICAgICAgIGNvbnRhaW5lcmxlc3M6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IGNvbXBvc2VQcm9wcyA9IFsnc3ViamVjdCcsICdjb21wb3NpbmcnXTtcbiAgICBleHBvcnRzLkNvbXBvc2UgPSBjbGFzcyBDb21wb3NlIHtcbiAgICAgICAgY29uc3RydWN0b3IocmVuZGVyYWJsZSwgaW5zdHJ1Y3Rpb24sIHJlbmRlcmluZ0VuZ2luZSwgY29vcmRpbmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyYWJsZSA9IHJlbmRlcmFibGU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ0VuZ2luZSA9IHJlbmRlcmluZ0VuZ2luZTtcbiAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0b3IgPSBjb29yZGluYXRvcjtcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdFN1YmplY3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRvci5vblN3YXBDb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IGluc3RydWN0aW9uLmluc3RydWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICFjb21wb3NlUHJvcHMuaW5jbHVkZXMoeC50bykpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2l0ZW0udG9dID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kaW5nKGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29tcG9zaXRpb24odGhpcy5zdWJqZWN0LCB1bmRlZmluZWQsIGZsYWdzKTtcbiAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0b3IuYmluZGluZyhmbGFncywgdGhpcy4kc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaGluZyhmbGFncykge1xuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRvci5hdHRhY2hpbmcoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaGluZyhmbGFncykge1xuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRvci5kZXRhY2hpbmcoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHVuYmluZGluZyhmbGFncykge1xuICAgICAgICAgICAgdGhpcy5sYXN0U3ViamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLnVuYmluZGluZyhmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGluZyhmbGFncykge1xuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRvci5jYWNoaW5nKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJqZWN0Q2hhbmdlZChuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb21wb3NpdGlvbihuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0Q29tcG9zaXRpb24oc3ViamVjdCwgcHJldmlvdXNTdWJqZWN0LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFN1YmplY3QgPT09IHN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgICAgIGlmIChzdWJqZWN0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QgPSBzdWJqZWN0LnRoZW4oeCA9PiB0aGlzLnJlc29sdmVWaWV3KHgsIGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0ID0gdGhpcy5yZXNvbHZlVmlldyhzdWJqZWN0LCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmNvbXBvc2Uoc3ViamVjdCwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVWaWV3KHN1YmplY3QsIGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5wcm92aWRlVmlld0ZvcihzdWJqZWN0KTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmlldy5ob2xkKHRoaXMuJHByb2plY3Rvci5ob3N0LCBmbGFncyk7XG4gICAgICAgICAgICAgICAgdmlldy5sb2NrU2NvcGUodGhpcy5yZW5kZXJhYmxlLiRzY29wZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlVmlld0ZvcihzdWJqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnbG9ja1Njb3BlJyBpbiBzdWJqZWN0KSB7IC8vIElWaWV3XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2NyZWF0ZVZpZXcnIGluIHN1YmplY3QpIHsgLy8gUmVuZGVyUGxhblxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJqZWN0LmNyZWF0ZVZpZXcodGhpcy5yZW5kZXJpbmdFbmdpbmUsIHRoaXMucmVuZGVyYWJsZS4kY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2NyZWF0ZScgaW4gc3ViamVjdCkgeyAvLyBJVmlld0ZhY3RvcnlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViamVjdC5jcmVhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgndGVtcGxhdGUnIGluIHN1YmplY3QpIHsgLy8gUmF3IFRlbXBsYXRlIERlZmluaXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJpbmdFbmdpbmUuZ2V0Vmlld0ZhY3Rvcnkoc3ViamVjdCwgdGhpcy5yZW5kZXJhYmxlLiRjb250ZXh0KS5jcmVhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnN0cnVjdGFibGUgKEN1c3RvbSBFbGVtZW50IENvbnN0cnVjdG9yKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoc3ViamVjdCwgdGhpcy5wcm9wZXJ0aWVzLCB0aGlzLiRwcm9qZWN0b3IuY2hpbGRyZW4pLmNyZWF0ZVZpZXcodGhpcy5yZW5kZXJpbmdFbmdpbmUsIHRoaXMucmVuZGVyYWJsZS4kY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBiaW5kYWJsZVxuICAgIF0sIGV4cG9ydHMuQ29tcG9zZS5wcm90b3R5cGUsIFwic3ViamVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBiaW5kYWJsZVxuICAgIF0sIGV4cG9ydHMuQ29tcG9zZS5wcm90b3R5cGUsIFwiY29tcG9zaW5nXCIsIHZvaWQgMCk7XG4gICAgZXhwb3J0cy5Db21wb3NlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGN1c3RvbUVsZW1lbnQoY29tcG9zZVNvdXJjZSksXG4gICAgICAgIGtlcm5lbC5pbmplY3QoSVJlbmRlcmFibGUsIElUYXJnZXRlZEluc3RydWN0aW9uLCBJUmVuZGVyaW5nRW5naW5lLCBleHBvcnRzLkNvbXBvc2l0aW9uQ29vcmRpbmF0b3IpXG4gICAgXSwgZXhwb3J0cy5Db21wb3NlKTtcblxuICAgIC8qKlxuICAgICAqIERlY29yYXRvcjogSW5kaWNhdGVzIHRoYXQgdGhlIGRlY29yYXRlZCBjbGFzcyBpcyBhIGN1c3RvbSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tQXR0cmlidXRlKG5hbWVPckRlZikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0ID0+IEN1c3RvbUF0dHJpYnV0ZVJlc291cmNlLmRlZmluZShuYW1lT3JEZWYsIHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29yYXRvcjogQXBwbGllZCB0byBjdXN0b20gYXR0cmlidXRlcy4gSW5kaWNhdGVzIHRoYXQgd2hhdGV2ZXIgZWxlbWVudCB0aGVcbiAgICAgKiBhdHRyaWJ1dGUgaXMgcGxhY2VkIG9uIHNob3VsZCBiZSBjb252ZXJ0ZWQgaW50byBhIHRlbXBsYXRlIGFuZCB0aGF0IHRoaXNcbiAgICAgKiBhdHRyaWJ1dGUgY29udHJvbHMgdGhlIGluc3RhbnRpYXRpb24gb2YgdGhlIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlQ29udHJvbGxlcihuYW1lT3JEZWYpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldCA9PiBDdXN0b21BdHRyaWJ1dGVSZXNvdXJjZS5kZWZpbmUodHlwZW9mIG5hbWVPckRlZiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8geyBpc1RlbXBsYXRlQ29udHJvbGxlcjogdHJ1ZSwgbmFtZTogbmFtZU9yRGVmIH1cbiAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7IGlzVGVtcGxhdGVDb250cm9sbGVyOiB0cnVlIH0sIG5hbWVPckRlZiksIHRhcmdldCk7XG4gICAgfVxuICAgIGNvbnN0IEN1c3RvbUF0dHJpYnV0ZVJlc291cmNlID0ge1xuICAgICAgICBuYW1lOiBjdXN0b21BdHRyaWJ1dGVOYW1lLFxuICAgICAgICBrZXlGcm9tOiBjdXN0b21BdHRyaWJ1dGVLZXksXG4gICAgICAgIGlzVHlwZShUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZS5raW5kID09PSB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmUobmFtZU9yU291cmNlLCBjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBUeXBlID0gY3RvcjtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gY3JlYXRlQ3VzdG9tQXR0cmlidXRlRGVzY3JpcHRpb24odHlwZW9mIG5hbWVPclNvdXJjZSA9PT0gJ3N0cmluZycgPyB7IG5hbWU6IG5hbWVPclNvdXJjZSB9IDogbmFtZU9yU291cmNlLCBUeXBlKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gVHlwZS5wcm90b3R5cGU7XG4gICAgICAgICAgICBUeXBlLmtpbmQgPSBDdXN0b21BdHRyaWJ1dGVSZXNvdXJjZTtcbiAgICAgICAgICAgIFR5cGUuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIFR5cGUucmVnaXN0ZXIgPSByZWdpc3RlckF0dHJpYnV0ZTtcbiAgICAgICAgICAgIHByb3RvLiRoeWRyYXRlID0gJGh5ZHJhdGVBdHRyaWJ1dGU7XG4gICAgICAgICAgICBwcm90by4kYmluZCA9ICRiaW5kQXR0cmlidXRlO1xuICAgICAgICAgICAgcHJvdG8uJGF0dGFjaCA9ICRhdHRhY2hBdHRyaWJ1dGU7XG4gICAgICAgICAgICBwcm90by4kZGV0YWNoID0gJGRldGFjaEF0dHJpYnV0ZTtcbiAgICAgICAgICAgIHByb3RvLiR1bmJpbmQgPSAkdW5iaW5kQXR0cmlidXRlO1xuICAgICAgICAgICAgcHJvdG8uJGNhY2hlID0gJGNhY2hlQXR0cmlidXRlO1xuICAgICAgICAgICAgcHJvdG8uJHByZXZCaW5kID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLiRuZXh0QmluZCA9IG51bGw7XG4gICAgICAgICAgICBwcm90by4kcHJldkF0dGFjaCA9IG51bGw7XG4gICAgICAgICAgICBwcm90by4kbmV4dEF0dGFjaCA9IG51bGw7XG4gICAgICAgICAgICBwcm90by4kbmV4dFVuYmluZEFmdGVyRGV0YWNoID0gbnVsbDtcbiAgICAgICAgICAgIHByb3RvLiRzY29wZSA9IG51bGw7XG4gICAgICAgICAgICBwcm90by4kaG9va3MgPSAwO1xuICAgICAgICAgICAgcHJvdG8uJHN0YXRlID0gMDtcbiAgICAgICAgICAgIGlmICgnZmx1c2gnIGluIHByb3RvKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uJG5leHRGbHVzaCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2JpbmRpbmcnIGluIHByb3RvKVxuICAgICAgICAgICAgICAgIHByb3RvLiRob29rcyB8PSA0IC8qIGhhc0JpbmRpbmcgKi87XG4gICAgICAgICAgICBpZiAoJ2JvdW5kJyBpbiBwcm90bykge1xuICAgICAgICAgICAgICAgIHByb3RvLiRob29rcyB8PSA4IC8qIGhhc0JvdW5kICovO1xuICAgICAgICAgICAgICAgIHByb3RvLiRuZXh0Qm91bmQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCd1bmJpbmRpbmcnIGluIHByb3RvKVxuICAgICAgICAgICAgICAgIHByb3RvLiRob29rcyB8PSAyNTYgLyogaGFzVW5iaW5kaW5nICovO1xuICAgICAgICAgICAgaWYgKCd1bmJvdW5kJyBpbiBwcm90bykge1xuICAgICAgICAgICAgICAgIHByb3RvLiRob29rcyB8PSA1MTIgLyogaGFzVW5ib3VuZCAqLztcbiAgICAgICAgICAgICAgICBwcm90by4kbmV4dFVuYm91bmQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdjcmVhdGVkJyBpbiBwcm90bylcbiAgICAgICAgICAgICAgICBwcm90by4kaG9va3MgfD0gMiAvKiBoYXNDcmVhdGVkICovO1xuICAgICAgICAgICAgaWYgKCdhdHRhY2hpbmcnIGluIHByb3RvKVxuICAgICAgICAgICAgICAgIHByb3RvLiRob29rcyB8PSAxNiAvKiBoYXNBdHRhY2hpbmcgKi87XG4gICAgICAgICAgICBpZiAoJ2F0dGFjaGVkJyBpbiBwcm90bykge1xuICAgICAgICAgICAgICAgIHByb3RvLiRob29rcyB8PSAzMiAvKiBoYXNBdHRhY2hlZCAqLztcbiAgICAgICAgICAgICAgICBwcm90by4kbmV4dEF0dGFjaGVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnZGV0YWNoaW5nJyBpbiBwcm90bylcbiAgICAgICAgICAgICAgICBwcm90by4kaG9va3MgfD0gNjQgLyogaGFzRGV0YWNoaW5nICovO1xuICAgICAgICAgICAgaWYgKCdjYWNoaW5nJyBpbiBwcm90bylcbiAgICAgICAgICAgICAgICBwcm90by4kaG9va3MgfD0gMjA0OCAvKiBoYXNDYWNoaW5nICovO1xuICAgICAgICAgICAgaWYgKCdkZXRhY2hlZCcgaW4gcHJvdG8pIHtcbiAgICAgICAgICAgICAgICBwcm90by4kaG9va3MgfD0gMTI4IC8qIGhhc0RldGFjaGVkICovO1xuICAgICAgICAgICAgICAgIHByb3RvLiRuZXh0RGV0YWNoZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qQGludGVybmFsKi9cbiAgICBmdW5jdGlvbiByZWdpc3RlckF0dHJpYnV0ZShjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLmRlc2NyaXB0aW9uO1xuICAgICAgICBjb25zdCByZXNvdXJjZUtleSA9IEN1c3RvbUF0dHJpYnV0ZVJlc291cmNlLmtleUZyb20oZGVzY3JpcHRpb24ubmFtZSk7XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSBkZXNjcmlwdGlvbi5hbGlhc2VzO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoa2VybmVsLlJlZ2lzdHJhdGlvbi50cmFuc2llbnQocmVzb3VyY2VLZXksIHRoaXMpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYWxpYXNlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhbGlhc0tleSA9IEN1c3RvbUF0dHJpYnV0ZVJlc291cmNlLmtleUZyb20oYWxpYXNlc1tpXSk7XG4gICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoa2VybmVsLlJlZ2lzdHJhdGlvbi5hbGlhcyhyZXNvdXJjZUtleSwgYWxpYXNLZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKkBpbnRlcm5hbCovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VzdG9tQXR0cmlidXRlRGVzY3JpcHRpb24oZGVmLCBUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBkZWYubmFtZSxcbiAgICAgICAgICAgIGFsaWFzZXM6IGRlZi5hbGlhc2VzIHx8IGtlcm5lbC5QTEFURk9STS5lbXB0eUFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdEJpbmRpbmdNb2RlOiBkZWYuZGVmYXVsdEJpbmRpbmdNb2RlIHx8IGV4cG9ydHMuQmluZGluZ01vZGUudG9WaWV3LFxuICAgICAgICAgICAgaXNUZW1wbGF0ZUNvbnRyb2xsZXI6IGRlZi5pc1RlbXBsYXRlQ29udHJvbGxlciB8fCBmYWxzZSxcbiAgICAgICAgICAgIGJpbmRhYmxlczogT2JqZWN0LmFzc2lnbih7fSwgVHlwZS5iaW5kYWJsZXMsIGRlZi5iaW5kYWJsZXMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZXhwb3J0cy5JZiA9IGNsYXNzIElmIHtcbiAgICAgICAgY29uc3RydWN0b3IoaWZGYWN0b3J5LCBsb2NhdGlvbiwgY29vcmRpbmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuaWZGYWN0b3J5ID0gaWZGYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRvciA9IGNvb3JkaW5hdG9yO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbHNlRmFjdG9yeSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlmVmlldyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVsc2VWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBiaW5kaW5nKGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy51cGRhdGVWaWV3KGZsYWdzKTtcbiAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0b3IuY29tcG9zZSh2aWV3LCBmbGFncyk7XG4gICAgICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmJpbmRpbmcoZmxhZ3MsIHRoaXMuJHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0b3IuYXR0YWNoaW5nKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhY2hpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0b3IuZGV0YWNoaW5nKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICB1bmJpbmRpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0b3IudW5iaW5kaW5nKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoaW5nKGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZlZpZXcgIT09IG51bGwgJiYgdGhpcy5pZlZpZXcucmVsZWFzZShmbGFncykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlmVmlldyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbHNlVmlldyAhPT0gbnVsbCAmJiB0aGlzLmVsc2VWaWV3LnJlbGVhc2UoZmxhZ3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbHNlVmlldyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmNhY2hpbmcoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21GbHVzaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnVwZGF0ZVZpZXcoZmxhZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0b3IuY29tcG9zZSh2aWV3LCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRsaWZlY3ljbGUuZW5xdWV1ZUZsdXNoKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZsdXNoKGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy51cGRhdGVWaWV3KGZsYWdzKTtcbiAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0b3IuY29tcG9zZSh2aWV3LCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgLypAaW50ZXJuYWwqL1xuICAgICAgICB1cGRhdGVWaWV3KGZsYWdzKSB7XG4gICAgICAgICAgICBsZXQgdmlldztcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmlldyA9IHRoaXMuaWZWaWV3ID0gdGhpcy5lbnN1cmVWaWV3KHRoaXMuaWZWaWV3LCB0aGlzLmlmRmFjdG9yeSwgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lbHNlRmFjdG9yeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLmVsc2VWaWV3ID0gdGhpcy5lbnN1cmVWaWV3KHRoaXMuZWxzZVZpZXcsIHRoaXMuZWxzZUZhY3RvcnksIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpZXcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgLypAaW50ZXJuYWwqL1xuICAgICAgICBlbnN1cmVWaWV3KHZpZXcsIGZhY3RvcnksIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAodmlldyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZpZXcgPSBmYWN0b3J5LmNyZWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldy5ob2xkKHRoaXMubG9jYXRpb24sIGZsYWdzKTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgYmluZGFibGVcbiAgICBdLCBleHBvcnRzLklmLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgIGV4cG9ydHMuSWYgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGVtcGxhdGVDb250cm9sbGVyKCdpZicpLFxuICAgICAgICBrZXJuZWwuaW5qZWN0KElWaWV3RmFjdG9yeSwgSVJlbmRlckxvY2F0aW9uLCBleHBvcnRzLkNvbXBvc2l0aW9uQ29vcmRpbmF0b3IpXG4gICAgXSwgZXhwb3J0cy5JZik7XG4gICAgZXhwb3J0cy5FbHNlID0gY2xhc3MgRWxzZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgbGluayhpZkJlaGF2aW9yKSB7XG4gICAgICAgICAgICBpZkJlaGF2aW9yLmVsc2VGYWN0b3J5ID0gdGhpcy5mYWN0b3J5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkVsc2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGVtcGxhdGVDb250cm9sbGVyKCdlbHNlJyksXG4gICAgICAgIGtlcm5lbC5pbmplY3QoSVZpZXdGYWN0b3J5KVxuICAgIF0sIGV4cG9ydHMuRWxzZSk7XG5cbiAgICBleHBvcnRzLlJlcGVhdCA9IGNsYXNzIFJlcGVhdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxvY2F0aW9uLCByZW5kZXJhYmxlLCBmYWN0b3J5KSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmFibGUgPSByZW5kZXJhYmxlO1xuICAgICAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvblNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ0luc3RhbmNlTXV0YXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kaW5nKGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29sbGVjdGlvbk9ic2VydmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmQoZmxhZ3MpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5yZW5kZXJhYmxlLiRiaW5kYWJsZUhlYWQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnRhcmdldCA9PT0gdGhpcyAmJiBjdXJyZW50LnRhcmdldFByb3BlcnR5ID09PSAnaXRlbXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yT2YgPSBjdXJyZW50LnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC4kbmV4dEJpbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvY2FsID0gdGhpcy5mb3JPZi5kZWNsYXJhdGlvbi5ldmFsdWF0ZShmbGFncywgdGhpcy4kc2NvcGUsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVmlld3MobnVsbCwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaGluZyhmbGFncykge1xuICAgICAgICAgICAgY29uc3QgeyB2aWV3cywgbG9jYXRpb24gfSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB2aWV3cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IHZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIHZpZXcuaG9sZChsb2NhdGlvbiwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIHZpZXcuJGF0dGFjaChmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoaW5nKGZsYWdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZpZXdzIH0gPSB0aGlzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmlld3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB2aWV3c1tpXTtcbiAgICAgICAgICAgICAgICB2aWV3LiRkZXRhY2goZmxhZ3MpO1xuICAgICAgICAgICAgICAgIHZpZXcucmVsZWFzZShmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5ib3VuZChmbGFncykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbGxlY3Rpb25PYnNlcnZlcigpO1xuICAgICAgICAgICAgY29uc3QgeyB2aWV3cyB9ID0gdGhpcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZpZXdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdmlld3NbaV07XG4gICAgICAgICAgICAgICAgdmlldy4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsZWQgYnkgU2V0dGVyT2JzZXJ2ZXIgKHN5bmMpXG4gICAgICAgIGl0ZW1zQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29sbGVjdGlvbk9ic2VydmVyKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NWaWV3cyhudWxsLCBmbGFncyB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MudXBkYXRlVGFyZ2V0SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxlZCBieSBhIENvbGxlY3Rpb25PYnNlcnZlciAoYXN5bmMpXG4gICAgICAgIGhhbmRsZUJhdGNoZWRDaGFuZ2UoaW5kZXhNYXApIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1ZpZXdzKGluZGV4TWFwLCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21GbHVzaCB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MudXBkYXRlVGFyZ2V0SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBpbmRleE1hcCA9PT0gbnVsbCwgaXQgaXMgYW4gaW5zdGFuY2UgbXV0YXRpb24sIG90aGVyd2lzZSBpdCdzIGFuIGl0ZW1zIG11dGF0aW9uXG4gICAgICAgIHByb2Nlc3NWaWV3cyhpbmRleE1hcCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmlld3MsICRsaWZlY3ljbGUgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxvY2FsLCAkc2NvcGUsIGZhY3RvcnksIGZvck9mLCBpdGVtcyB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRMZW5ndGggPSB2aWV3cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gZm9yT2YuY291bnQoaXRlbXMpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRMZW5ndGggPCBuZXdMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3MubGVuZ3RoID0gbmV3TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gb2xkTGVuZ3RoOyBpIDwgbmV3TGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdzW2ldID0gZmFjdG9yeS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdMZW5ndGggPCBvbGRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxpZmVjeWNsZS5iZWdpbkRldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbmV3TGVuZ3RoLCB2aWV3ID0gdmlld3NbaV07IGkgPCBvbGRMZW5ndGg7IHZpZXcgPSB2aWV3c1srK2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnJlbGVhc2UoZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy4kZGV0YWNoKGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkbGlmZWN5Y2xlLmVuZERldGFjaChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgICRsaWZlY3ljbGUuYmVnaW5VbmJpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5ld0xlbmd0aCwgdmlldyA9IHZpZXdzW2ldOyBpIDwgb2xkTGVuZ3RoOyB2aWV3ID0gdmlld3NbKytpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkbGlmZWN5Y2xlLmVuZFVuYmluZChmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdzLmxlbmd0aCA9IG5ld0xlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld0xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRsaWZlY3ljbGUuYmVnaW5CaW5kKCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvck9mLml0ZXJhdGUoaXRlbXMsIChhcnIsIGksIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB2aWV3c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXZpZXcuJHNjb3BlICYmIHZpZXcuJHNjb3BlLmJpbmRpbmdDb250ZXh0W2xvY2FsXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuJGJpbmQoZmxhZ3MsIFNjb3BlLmZyb21QYXJlbnQoJHNjb3BlLCB2aWV3LiRzY29wZS5iaW5kaW5nQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy4kYmluZChmbGFncywgU2NvcGUuZnJvbVBhcmVudCgkc2NvcGUsIEJpbmRpbmdDb250ZXh0LmNyZWF0ZShsb2NhbCwgaXRlbSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JPZi5pdGVyYXRlKGl0ZW1zLCAoYXJyLCBpLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhNYXBbaV0gPT09IGkgJiYgISF2aWV3LiRzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuJGJpbmQoZmxhZ3MsIFNjb3BlLmZyb21QYXJlbnQoJHNjb3BlLCB2aWV3LiRzY29wZS5iaW5kaW5nQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy4kYmluZChmbGFncywgU2NvcGUuZnJvbVBhcmVudCgkc2NvcGUsIEJpbmRpbmdDb250ZXh0LmNyZWF0ZShsb2NhbCwgaXRlbSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRsaWZlY3ljbGUuZW5kQmluZChmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiA4IC8qIGlzQXR0YWNoZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxvY2F0aW9uIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICRsaWZlY3ljbGUuYmVnaW5BdHRhY2goKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhNYXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmlld3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IHZpZXdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5ob2xkKGxvY2F0aW9uLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LiRhdHRhY2goZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB2aWV3cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhNYXBbaV0gIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5ob2xkKGxvY2F0aW9uLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy4kYXR0YWNoKGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkbGlmZWN5Y2xlLmVuZEF0dGFjaChmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDb2xsZWN0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRPYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiAoMiAvKiBpc0JvdW5kICovIHwgMSAvKiBpc0JpbmRpbmcgKi8pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3T2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gZ2V0Q29sbGVjdGlvbk9ic2VydmVyKHRoaXMuJGxpZmVjeWNsZSwgdGhpcy5pdGVtcyk7XG4gICAgICAgICAgICAgICAgaWYgKG9sZE9ic2VydmVyICE9PSBuZXdPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZE9ic2VydmVyLnVuc3Vic2NyaWJlQmF0Y2hlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JzZXJ2ZXIuc3Vic2NyaWJlQmF0Y2hlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvbGRPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIG9sZE9ic2VydmVyLnVuc3Vic2NyaWJlQmF0Y2hlZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGJpbmRhYmxlXG4gICAgXSwgZXhwb3J0cy5SZXBlYXQucHJvdG90eXBlLCBcIml0ZW1zXCIsIHZvaWQgMCk7XG4gICAgZXhwb3J0cy5SZXBlYXQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAga2VybmVsLmluamVjdChJUmVuZGVyTG9jYXRpb24sIElSZW5kZXJhYmxlLCBJVmlld0ZhY3RvcnkpLFxuICAgICAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoJ3JlcGVhdCcpXG4gICAgXSwgZXhwb3J0cy5SZXBlYXQpO1xuXG4gICAgZXhwb3J0cy5SZXBsYWNlYWJsZSA9IGNsYXNzIFJlcGxhY2VhYmxlIHtcbiAgICAgICAgY29uc3RydWN0b3IoZmFjdG9yeSwgbG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlldy5ob2xkKGxvY2F0aW9uLCBleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21DcmVhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGJpbmRpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcuJGJpbmQoZmxhZ3MsIHRoaXMuJHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcuJGF0dGFjaChmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoaW5nKGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3LiRkZXRhY2goZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHVuYmluZGluZyhmbGFncykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlldy4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5SZXBsYWNlYWJsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoJ3JlcGxhY2VhYmxlJyksXG4gICAgICAgIGtlcm5lbC5pbmplY3QoSVZpZXdGYWN0b3J5LCBJUmVuZGVyTG9jYXRpb24pXG4gICAgXSwgZXhwb3J0cy5SZXBsYWNlYWJsZSk7XG5cbiAgICBleHBvcnRzLldpdGggPSBjbGFzcyBXaXRoIHtcbiAgICAgICAgY29uc3RydWN0b3IoZmFjdG9yeSwgbG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcuaG9sZChsb2NhdGlvbiwgZXhwb3J0cy5MaWZlY3ljbGVGbGFncy5mcm9tQ3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZUNoYW5nZWQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc3RhdGUgJiAyIC8qIGlzQm91bmQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRDaGlsZChleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21CaW5kYWJsZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJpbmRpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZENoaWxkKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hpbmcoZmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcuJGF0dGFjaChmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoaW5nKGZsYWdzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3LiRkZXRhY2goZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHVuYmluZGluZyhmbGFncykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlldy4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kQ2hpbGQoZmxhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gU2NvcGUuZnJvbVBhcmVudCh0aGlzLiRzY29wZSwgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3LiRiaW5kKGZsYWdzLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBiaW5kYWJsZVxuICAgIF0sIGV4cG9ydHMuV2l0aC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICBleHBvcnRzLldpdGggPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGVtcGxhdGVDb250cm9sbGVyKCd3aXRoJyksXG4gICAgICAgIGtlcm5lbC5pbmplY3QoSVZpZXdGYWN0b3J5LCBJUmVuZGVyTG9jYXRpb24pXG4gICAgXSwgZXhwb3J0cy5XaXRoKTtcblxuICAgIGNsYXNzIEF1cmVsaWEge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIgPSBrZXJuZWwuREkuY3JlYXRlQ29udGFpbmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGFza3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFRhc2tzID0gW107XG4gICAgICAgICAgICB0aGlzLmlzU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgICAgICBrZXJuZWwuUmVnaXN0cmF0aW9uXG4gICAgICAgICAgICAgICAgLmluc3RhbmNlKEF1cmVsaWEsIHRoaXMpXG4gICAgICAgICAgICAgICAgLnJlZ2lzdGVyKGNvbnRhaW5lciwgQXVyZWxpYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXIoLi4ucGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZWdpc3RlciguLi5wYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgYXBwKGNvbmZpZykge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29uZmlnLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGNvbnN0IGhvc3QgPSBjb25maWcuaG9zdDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGFzayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBob3N0LiRhdSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudHMuaW5jbHVkZXMoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZSA9IHRoaXMuY29udGFpbmVyLmdldChJUmVuZGVyaW5nRW5naW5lKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LiRoeWRyYXRlKHJlLCBob3N0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LiRiaW5kKGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbVN0YXJ0VGFzayB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbUJpbmQpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC4kYXR0YWNoKGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbVN0YXJ0VGFzayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdGFydFRhc2tzLnB1c2goc3RhcnRUYXNrKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFRhc2tzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC4kZGV0YWNoKGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbVN0b3BUYXNrKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuJHVuYmluZChleHBvcnRzLkxpZmVjeWNsZUZsYWdzLmZyb21TdG9wVGFzayB8IGV4cG9ydHMuTGlmZWN5Y2xlRmxhZ3MuZnJvbVVuYmluZCk7XG4gICAgICAgICAgICAgICAgaG9zdC4kYXUgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRhc2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuU3RhcnRUYXNrIG9mIHRoaXMuc3RhcnRUYXNrcykge1xuICAgICAgICAgICAgICAgIHJ1blN0YXJ0VGFzaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1blN0b3BUYXNrIG9mIHRoaXMuc3RvcFRhc2tzKSB7XG4gICAgICAgICAgICAgICAgcnVuU3RvcFRhc2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGtlcm5lbC5QTEFURk9STS5nbG9iYWwuQXVyZWxpYSA9IEF1cmVsaWE7XG5cbiAgICBleHBvcnRzLmVuYWJsZUFycmF5T2JzZXJ2YXRpb24gPSBlbmFibGVBcnJheU9ic2VydmF0aW9uO1xuICAgIGV4cG9ydHMuZGlzYWJsZUFycmF5T2JzZXJ2YXRpb24gPSBkaXNhYmxlQXJyYXlPYnNlcnZhdGlvbjtcbiAgICBleHBvcnRzLm5hdGl2ZVB1c2ggPSBuYXRpdmVQdXNoO1xuICAgIGV4cG9ydHMubmF0aXZlUG9wID0gbmF0aXZlUG9wO1xuICAgIGV4cG9ydHMubmF0aXZlU2hpZnQgPSBuYXRpdmVTaGlmdDtcbiAgICBleHBvcnRzLm5hdGl2ZVVuc2hpZnQgPSBuYXRpdmVVbnNoaWZ0O1xuICAgIGV4cG9ydHMubmF0aXZlU3BsaWNlID0gbmF0aXZlU3BsaWNlO1xuICAgIGV4cG9ydHMubmF0aXZlUmV2ZXJzZSA9IG5hdGl2ZVJldmVyc2U7XG4gICAgZXhwb3J0cy5uYXRpdmVTb3J0ID0gbmF0aXZlU29ydDtcbiAgICBleHBvcnRzLmVuYWJsZU1hcE9ic2VydmF0aW9uID0gZW5hYmxlTWFwT2JzZXJ2YXRpb247XG4gICAgZXhwb3J0cy5kaXNhYmxlTWFwT2JzZXJ2YXRpb24gPSBkaXNhYmxlTWFwT2JzZXJ2YXRpb247XG4gICAgZXhwb3J0cy5uYXRpdmVTZXQgPSBuYXRpdmVTZXQ7XG4gICAgZXhwb3J0cy5uYXRpdmVNYXBEZWxldGUgPSBuYXRpdmVEZWxldGU7XG4gICAgZXhwb3J0cy5uYXRpdmVNYXBDbGVhciA9IG5hdGl2ZUNsZWFyO1xuICAgIGV4cG9ydHMuZW5hYmxlU2V0T2JzZXJ2YXRpb24gPSBlbmFibGVTZXRPYnNlcnZhdGlvbjtcbiAgICBleHBvcnRzLmRpc2FibGVTZXRPYnNlcnZhdGlvbiA9IGRpc2FibGVTZXRPYnNlcnZhdGlvbjtcbiAgICBleHBvcnRzLm5hdGl2ZUFkZCA9IG5hdGl2ZUFkZDtcbiAgICBleHBvcnRzLm5hdGl2ZVNldERlbGV0ZSA9IG5hdGl2ZURlbGV0ZSQxO1xuICAgIGV4cG9ydHMubmF0aXZlU2V0Q2xlYXIgPSBuYXRpdmVDbGVhciQxO1xuICAgIGV4cG9ydHMuQmluZGluZ01vZGVCZWhhdmlvciA9IEJpbmRpbmdNb2RlQmVoYXZpb3I7XG4gICAgZXhwb3J0cy5kZWJvdW5jZUNhbGxTb3VyY2UgPSBkZWJvdW5jZUNhbGxTb3VyY2U7XG4gICAgZXhwb3J0cy5kZWJvdW5jZUNhbGwgPSBkZWJvdW5jZUNhbGw7XG4gICAgZXhwb3J0cy5JU2FuaXRpemVyID0gSVNhbml0aXplcjtcbiAgICBleHBvcnRzLmhhbmRsZVNlbGZFdmVudCA9IGhhbmRsZVNlbGZFdmVudDtcbiAgICBleHBvcnRzLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgZXhwb3J0cy5jb25uZWN0cyA9IGNvbm5lY3RzO1xuICAgIGV4cG9ydHMub2JzZXJ2ZXMgPSBvYnNlcnZlcztcbiAgICBleHBvcnRzLmNhbGxzRnVuY3Rpb24gPSBjYWxsc0Z1bmN0aW9uO1xuICAgIGV4cG9ydHMuaGFzQW5jZXN0b3IgPSBoYXNBbmNlc3RvcjtcbiAgICBleHBvcnRzLmlzQXNzaWduYWJsZSA9IGlzQXNzaWduYWJsZTtcbiAgICBleHBvcnRzLmlzTGVmdEhhbmRTaWRlID0gaXNMZWZ0SGFuZFNpZGU7XG4gICAgZXhwb3J0cy5pc1ByaW1hcnkgPSBpc1ByaW1hcnk7XG4gICAgZXhwb3J0cy5pc1Jlc291cmNlID0gaXNSZXNvdXJjZTtcbiAgICBleHBvcnRzLmhhc0JpbmQgPSBoYXNCaW5kO1xuICAgIGV4cG9ydHMuaGFzVW5iaW5kID0gaGFzVW5iaW5kO1xuICAgIGV4cG9ydHMuaXNMaXRlcmFsID0gaXNMaXRlcmFsO1xuICAgIGV4cG9ydHMuYXJlUHVyZUxpdGVyYWxzID0gYXJlUHVyZUxpdGVyYWxzO1xuICAgIGV4cG9ydHMuaXNQdXJlTGl0ZXJhbCA9IGlzUHVyZUxpdGVyYWw7XG4gICAgZXhwb3J0cy5CaW5kaW5nQmVoYXZpb3IgPSBCaW5kaW5nQmVoYXZpb3I7XG4gICAgZXhwb3J0cy5WYWx1ZUNvbnZlcnRlciA9IFZhbHVlQ29udmVydGVyO1xuICAgIGV4cG9ydHMuQXNzaWduID0gQXNzaWduO1xuICAgIGV4cG9ydHMuQ29uZGl0aW9uYWwgPSBDb25kaXRpb25hbDtcbiAgICBleHBvcnRzLkFjY2Vzc1RoaXMgPSBBY2Nlc3NUaGlzO1xuICAgIGV4cG9ydHMuQWNjZXNzU2NvcGUgPSBBY2Nlc3NTY29wZTtcbiAgICBleHBvcnRzLkFjY2Vzc01lbWJlciA9IEFjY2Vzc01lbWJlcjtcbiAgICBleHBvcnRzLkFjY2Vzc0tleWVkID0gQWNjZXNzS2V5ZWQ7XG4gICAgZXhwb3J0cy5DYWxsU2NvcGUgPSBDYWxsU2NvcGU7XG4gICAgZXhwb3J0cy5DYWxsTWVtYmVyID0gQ2FsbE1lbWJlcjtcbiAgICBleHBvcnRzLkNhbGxGdW5jdGlvbiA9IENhbGxGdW5jdGlvbjtcbiAgICBleHBvcnRzLkJpbmFyeSA9IEJpbmFyeTtcbiAgICBleHBvcnRzLlVuYXJ5ID0gVW5hcnk7XG4gICAgZXhwb3J0cy5QcmltaXRpdmVMaXRlcmFsID0gUHJpbWl0aXZlTGl0ZXJhbDtcbiAgICBleHBvcnRzLkh0bWxMaXRlcmFsID0gSHRtbExpdGVyYWw7XG4gICAgZXhwb3J0cy5BcnJheUxpdGVyYWwgPSBBcnJheUxpdGVyYWw7XG4gICAgZXhwb3J0cy5PYmplY3RMaXRlcmFsID0gT2JqZWN0TGl0ZXJhbDtcbiAgICBleHBvcnRzLlRlbXBsYXRlID0gVGVtcGxhdGU7XG4gICAgZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZSA9IFRhZ2dlZFRlbXBsYXRlO1xuICAgIGV4cG9ydHMuQXJyYXlCaW5kaW5nUGF0dGVybiA9IEFycmF5QmluZGluZ1BhdHRlcm47XG4gICAgZXhwb3J0cy5PYmplY3RCaW5kaW5nUGF0dGVybiA9IE9iamVjdEJpbmRpbmdQYXR0ZXJuO1xuICAgIGV4cG9ydHMuQmluZGluZ0lkZW50aWZpZXIgPSBCaW5kaW5nSWRlbnRpZmllcjtcbiAgICBleHBvcnRzLkZvck9mU3RhdGVtZW50ID0gRm9yT2ZTdGF0ZW1lbnQ7XG4gICAgZXhwb3J0cy5JbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGlvbjtcbiAgICBleHBvcnRzLkl0ZXJhdGVGb3JPZlN0YXRlbWVudCA9IEl0ZXJhdGVGb3JPZlN0YXRlbWVudDtcbiAgICBleHBvcnRzLkNvdW50Rm9yT2ZTdGF0ZW1lbnQgPSBDb3VudEZvck9mU3RhdGVtZW50O1xuICAgIGV4cG9ydHMuYmluZGluZ0JlaGF2aW9yID0gYmluZGluZ0JlaGF2aW9yO1xuICAgIGV4cG9ydHMuQmluZGluZ0JlaGF2aW9yUmVzb3VyY2UgPSBCaW5kaW5nQmVoYXZpb3JSZXNvdXJjZTtcbiAgICBleHBvcnRzLkludGVybmFsT2JzZXJ2ZXJzTG9va3VwID0gSW50ZXJuYWxPYnNlcnZlcnNMb29rdXA7XG4gICAgZXhwb3J0cy5CaW5kaW5nQ29udGV4dCA9IEJpbmRpbmdDb250ZXh0O1xuICAgIGV4cG9ydHMuU2NvcGUgPSBTY29wZTtcbiAgICBleHBvcnRzLk92ZXJyaWRlQ29udGV4dCA9IE92ZXJyaWRlQ29udGV4dDtcbiAgICBleHBvcnRzLkNhbGwgPSBDYWxsO1xuICAgIGV4cG9ydHMuY29sbGVjdGlvbk9ic2VydmVyID0gY29sbGVjdGlvbk9ic2VydmVyO1xuICAgIGV4cG9ydHMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbXB1dGVkT2JzZXJ2ZXIgPSBjcmVhdGVDb21wdXRlZE9ic2VydmVyO1xuICAgIGV4cG9ydHMuR2V0dGVyQ29udHJvbGxlciA9IEdldHRlckNvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5JRGlydHlDaGVja2VyID0gSURpcnR5Q2hlY2tlcjtcbiAgICBleHBvcnRzLkRpcnR5Q2hlY2tlciA9IERpcnR5Q2hlY2tlcjtcbiAgICBleHBvcnRzLmZpbmRPcmlnaW5hbEV2ZW50VGFyZ2V0ID0gZmluZE9yaWdpbmFsRXZlbnRUYXJnZXQ7XG4gICAgZXhwb3J0cy5MaXN0ZW5lclRyYWNrZXIgPSBMaXN0ZW5lclRyYWNrZXI7XG4gICAgZXhwb3J0cy5EZWxlZ2F0ZU9yQ2FwdHVyZVN1YnNjcmlwdGlvbiA9IERlbGVnYXRlT3JDYXB0dXJlU3Vic2NyaXB0aW9uO1xuICAgIGV4cG9ydHMuVHJpZ2dlclN1YnNjcmlwdGlvbiA9IFRyaWdnZXJTdWJzY3JpcHRpb247XG4gICAgZXhwb3J0cy5FdmVudFN1YnNjcmliZXIgPSBFdmVudFN1YnNjcmliZXI7XG4gICAgZXhwb3J0cy5JRXZlbnRNYW5hZ2VyID0gSUV2ZW50TWFuYWdlcjtcbiAgICBleHBvcnRzLkV2ZW50TWFuYWdlciA9IEV2ZW50TWFuYWdlcjtcbiAgICBleHBvcnRzLklFeHByZXNzaW9uUGFyc2VyID0gSUV4cHJlc3Npb25QYXJzZXI7XG4gICAgZXhwb3J0cy5FeHByZXNzaW9uUGFyc2VyID0gRXhwcmVzc2lvblBhcnNlcjtcbiAgICBleHBvcnRzLk11bHRpSW50ZXJwb2xhdGlvbkJpbmRpbmcgPSBNdWx0aUludGVycG9sYXRpb25CaW5kaW5nO1xuICAgIGV4cG9ydHMuTGlzdGVuZXIgPSBMaXN0ZW5lcjtcbiAgICBleHBvcnRzLklPYnNlcnZlckxvY2F0b3IgPSBJT2JzZXJ2ZXJMb2NhdG9yO1xuICAgIGV4cG9ydHMuZ2V0Q29sbGVjdGlvbk9ic2VydmVyID0gZ2V0Q29sbGVjdGlvbk9ic2VydmVyO1xuICAgIGV4cG9ydHMuUHJpbWl0aXZlT2JzZXJ2ZXIgPSBQcmltaXRpdmVPYnNlcnZlcjtcbiAgICBleHBvcnRzLlJlZiA9IFJlZjtcbiAgICBleHBvcnRzLklTaWduYWxlciA9IElTaWduYWxlcjtcbiAgICBleHBvcnRzLlNpZ25hbGVyID0gU2lnbmFsZXI7XG4gICAgZXhwb3J0cy5zdWJzY3JpYmVyQ29sbGVjdGlvbiA9IHN1YnNjcmliZXJDb2xsZWN0aW9uO1xuICAgIGV4cG9ydHMuYmF0Y2hlZFN1YnNjcmliZXJDb2xsZWN0aW9uID0gYmF0Y2hlZFN1YnNjcmliZXJDb2xsZWN0aW9uO1xuICAgIGV4cG9ydHMuSVNWR0FuYWx5emVyID0gSVNWR0FuYWx5emVyO1xuICAgIGV4cG9ydHMuUHJvcGVydHlBY2Nlc3NvciA9IFByb3BlcnR5QWNjZXNzb3I7XG4gICAgZXhwb3J0cy50YXJnZXRPYnNlcnZlciA9IHRhcmdldE9ic2VydmVyO1xuICAgIGV4cG9ydHMudmFsdWVDb252ZXJ0ZXIgPSB2YWx1ZUNvbnZlcnRlcjtcbiAgICBleHBvcnRzLlZhbHVlQ29udmVydGVyUmVzb3VyY2UgPSBWYWx1ZUNvbnZlcnRlclJlc291cmNlO1xuICAgIGV4cG9ydHMuYmluZGFibGUgPSBiaW5kYWJsZTtcbiAgICBleHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuICAgIGV4cG9ydHMuUmVuZGVyUGxhbiA9IFJlbmRlclBsYW47XG4gICAgZXhwb3J0cy5jdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy50ZW1wbGF0ZUNvbnRyb2xsZXIgPSB0ZW1wbGF0ZUNvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5DdXN0b21BdHRyaWJ1dGVSZXNvdXJjZSA9IEN1c3RvbUF0dHJpYnV0ZVJlc291cmNlO1xuICAgIGV4cG9ydHMucmVnaXN0ZXJBdHRyaWJ1dGUgPSByZWdpc3RlckF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLmNyZWF0ZUN1c3RvbUF0dHJpYnV0ZURlc2NyaXB0aW9uID0gY3JlYXRlQ3VzdG9tQXR0cmlidXRlRGVzY3JpcHRpb247XG4gICAgZXhwb3J0cy5jdXN0b21FbGVtZW50ID0gY3VzdG9tRWxlbWVudDtcbiAgICBleHBvcnRzLnVzZVNoYWRvd0RPTSA9IHVzZVNoYWRvd0RPTTtcbiAgICBleHBvcnRzLmNvbnRhaW5lcmxlc3MgPSBjb250YWluZXJsZXNzO1xuICAgIGV4cG9ydHMuQ3VzdG9tRWxlbWVudFJlc291cmNlID0gQ3VzdG9tRWxlbWVudFJlc291cmNlO1xuICAgIGV4cG9ydHMucmVnaXN0ZXJFbGVtZW50ID0gcmVnaXN0ZXJFbGVtZW50O1xuICAgIGV4cG9ydHMuJGF0dGFjaEF0dHJpYnV0ZSA9ICRhdHRhY2hBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy4kYXR0YWNoRWxlbWVudCA9ICRhdHRhY2hFbGVtZW50O1xuICAgIGV4cG9ydHMuJGF0dGFjaFZpZXcgPSAkYXR0YWNoVmlldztcbiAgICBleHBvcnRzLiRkZXRhY2hBdHRyaWJ1dGUgPSAkZGV0YWNoQXR0cmlidXRlO1xuICAgIGV4cG9ydHMuJGRldGFjaEVsZW1lbnQgPSAkZGV0YWNoRWxlbWVudDtcbiAgICBleHBvcnRzLiRkZXRhY2hWaWV3ID0gJGRldGFjaFZpZXc7XG4gICAgZXhwb3J0cy4kY2FjaGVBdHRyaWJ1dGUgPSAkY2FjaGVBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy4kY2FjaGVFbGVtZW50ID0gJGNhY2hlRWxlbWVudDtcbiAgICBleHBvcnRzLiRjYWNoZVZpZXcgPSAkY2FjaGVWaWV3O1xuICAgIGV4cG9ydHMuJG1vdW50RWxlbWVudCA9ICRtb3VudEVsZW1lbnQ7XG4gICAgZXhwb3J0cy4kdW5tb3VudEVsZW1lbnQgPSAkdW5tb3VudEVsZW1lbnQ7XG4gICAgZXhwb3J0cy4kbW91bnRWaWV3ID0gJG1vdW50VmlldztcbiAgICBleHBvcnRzLiR1bm1vdW50VmlldyA9ICR1bm1vdW50VmlldztcbiAgICBleHBvcnRzLiRiaW5kQXR0cmlidXRlID0gJGJpbmRBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy4kYmluZEVsZW1lbnQgPSAkYmluZEVsZW1lbnQ7XG4gICAgZXhwb3J0cy4kYmluZFZpZXcgPSAkYmluZFZpZXc7XG4gICAgZXhwb3J0cy4kdW5iaW5kQXR0cmlidXRlID0gJHVuYmluZEF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLiR1bmJpbmRFbGVtZW50ID0gJHVuYmluZEVsZW1lbnQ7XG4gICAgZXhwb3J0cy4kdW5iaW5kVmlldyA9ICR1bmJpbmRWaWV3O1xuICAgIGV4cG9ydHMucmVuZGVyU3RyYXRlZ3kgPSByZW5kZXJTdHJhdGVneTtcbiAgICBleHBvcnRzLlJlbmRlclN0cmF0ZWd5UmVzb3VyY2UgPSBSZW5kZXJTdHJhdGVneVJlc291cmNlO1xuICAgIGV4cG9ydHMucmVnaXN0ZXJSZW5kZXJTdHJhdGVneSA9IHJlZ2lzdGVyUmVuZGVyU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5JVGVtcGxhdGVDb21waWxlciA9IElUZW1wbGF0ZUNvbXBpbGVyO1xuICAgIGV4cG9ydHMuJGh5ZHJhdGVBdHRyaWJ1dGUgPSAkaHlkcmF0ZUF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLiRoeWRyYXRlRWxlbWVudCA9ICRoeWRyYXRlRWxlbWVudDtcbiAgICBleHBvcnRzLmRlZmF1bHRTaGFkb3dPcHRpb25zID0gZGVmYXVsdFNoYWRvd09wdGlvbnM7XG4gICAgZXhwb3J0cy5JUmVuZGVyaW5nRW5naW5lID0gSVJlbmRlcmluZ0VuZ2luZTtcbiAgICBleHBvcnRzLlNoYWRvd0RPTVByb2plY3RvciA9IFNoYWRvd0RPTVByb2plY3RvcjtcbiAgICBleHBvcnRzLkNvbnRhaW5lcmxlc3NQcm9qZWN0b3IgPSBDb250YWluZXJsZXNzUHJvamVjdG9yO1xuICAgIGV4cG9ydHMuSG9zdFByb2plY3RvciA9IEhvc3RQcm9qZWN0b3I7XG4gICAgZXhwb3J0cy5SdW50aW1lQmVoYXZpb3IgPSBSdW50aW1lQmVoYXZpb3I7XG4gICAgZXhwb3J0cy5maW5kRWxlbWVudHMgPSBmaW5kRWxlbWVudHM7XG4gICAgZXhwb3J0cy5SdW50aW1lQ29tcGlsYXRpb25SZXNvdXJjZXMgPSBSdW50aW1lQ29tcGlsYXRpb25SZXNvdXJjZXM7XG4gICAgZXhwb3J0cy5Db21waWxlZFRlbXBsYXRlID0gQ29tcGlsZWRUZW1wbGF0ZTtcbiAgICBleHBvcnRzLm5vVmlld1RlbXBsYXRlID0gbm9WaWV3VGVtcGxhdGU7XG4gICAgZXhwb3J0cy5jcmVhdGVSZW5kZXJDb250ZXh0ID0gY3JlYXRlUmVuZGVyQ29udGV4dDtcbiAgICBleHBvcnRzLkluc3RhbmNlUHJvdmlkZXIgPSBJbnN0YW5jZVByb3ZpZGVyO1xuICAgIGV4cG9ydHMuVmlld0ZhY3RvcnlQcm92aWRlciA9IFZpZXdGYWN0b3J5UHJvdmlkZXI7XG4gICAgZXhwb3J0cy5hZGRCaW5kYWJsZSA9IGFkZEJpbmRhYmxlO1xuICAgIGV4cG9ydHMuYWRkQXR0YWNoYWJsZSA9IGFkZEF0dGFjaGFibGU7XG4gICAgZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICAgIGV4cG9ydHMuVmlldyA9IFZpZXc7XG4gICAgZXhwb3J0cy5WaWV3RmFjdG9yeSA9IFZpZXdGYWN0b3J5O1xuICAgIGV4cG9ydHMuQXVyZWxpYSA9IEF1cmVsaWE7XG4gICAgZXhwb3J0cy5jdXN0b21FbGVtZW50TmFtZSA9IGN1c3RvbUVsZW1lbnROYW1lO1xuICAgIGV4cG9ydHMuY3VzdG9tRWxlbWVudEtleSA9IGN1c3RvbUVsZW1lbnRLZXk7XG4gICAgZXhwb3J0cy5jdXN0b21FbGVtZW50QmVoYXZpb3IgPSBjdXN0b21FbGVtZW50QmVoYXZpb3I7XG4gICAgZXhwb3J0cy5jdXN0b21BdHRyaWJ1dGVOYW1lID0gY3VzdG9tQXR0cmlidXRlTmFtZTtcbiAgICBleHBvcnRzLmN1c3RvbUF0dHJpYnV0ZUtleSA9IGN1c3RvbUF0dHJpYnV0ZUtleTtcbiAgICBleHBvcnRzLklUYXJnZXRlZEluc3RydWN0aW9uID0gSVRhcmdldGVkSW5zdHJ1Y3Rpb247XG4gICAgZXhwb3J0cy5pc1RhcmdldGVkSW5zdHJ1Y3Rpb24gPSBpc1RhcmdldGVkSW5zdHJ1Y3Rpb247XG4gICAgZXhwb3J0cy5idWlsZFJlcXVpcmVkID0gYnVpbGRSZXF1aXJlZDtcbiAgICBleHBvcnRzLmJ1aWxkVGVtcGxhdGVEZWZpbml0aW9uID0gYnVpbGRUZW1wbGF0ZURlZmluaXRpb247XG4gICAgZXhwb3J0cy5FTEVNRU5UX05PREUgPSBFTEVNRU5UX05PREU7XG4gICAgZXhwb3J0cy5BVFRSSUJVVEVfTk9ERSA9IEFUVFJJQlVURV9OT0RFO1xuICAgIGV4cG9ydHMuVEVYVF9OT0RFID0gVEVYVF9OT0RFO1xuICAgIGV4cG9ydHMuQ09NTUVOVF9OT0RFID0gQ09NTUVOVF9OT0RFO1xuICAgIGV4cG9ydHMuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gICAgZXhwb3J0cy5JTm9kZSA9IElOb2RlO1xuICAgIGV4cG9ydHMuSVJlbmRlckxvY2F0aW9uID0gSVJlbmRlckxvY2F0aW9uO1xuICAgIGV4cG9ydHMuRE9NID0gRE9NO1xuICAgIGV4cG9ydHMuTm9kZVNlcXVlbmNlID0gTm9kZVNlcXVlbmNlO1xuICAgIGV4cG9ydHMuVGV4dE5vZGVTZXF1ZW5jZSA9IFRleHROb2RlU2VxdWVuY2U7XG4gICAgZXhwb3J0cy5GcmFnbWVudE5vZGVTZXF1ZW5jZSA9IEZyYWdtZW50Tm9kZVNlcXVlbmNlO1xuICAgIGV4cG9ydHMuTm9kZVNlcXVlbmNlRmFjdG9yeSA9IE5vZGVTZXF1ZW5jZUZhY3Rvcnk7XG4gICAgZXhwb3J0cy5BdU1hcmtlciA9IEF1TWFya2VyO1xuICAgIGV4cG9ydHMuSVJlbmRlcmFibGUgPSBJUmVuZGVyYWJsZTtcbiAgICBleHBvcnRzLklWaWV3RmFjdG9yeSA9IElWaWV3RmFjdG9yeTtcbiAgICBleHBvcnRzLklMaWZlY3ljbGUgPSBJTGlmZWN5Y2xlO1xuICAgIGV4cG9ydHMuSUZsdXNoTGlmZWN5Y2xlID0gSUZsdXNoTGlmZWN5Y2xlO1xuICAgIGV4cG9ydHMuSUJpbmRMaWZlY3ljbGUgPSBJQmluZExpZmVjeWNsZTtcbiAgICBleHBvcnRzLklBdHRhY2hMaWZlY3ljbGUgPSBJQXR0YWNoTGlmZWN5Y2xlO1xuICAgIGV4cG9ydHMuTGlmZWN5Y2xlID0gTGlmZWN5Y2xlO1xuICAgIGV4cG9ydHMuTGlmZWN5Y2xlVGFzayA9IExpZmVjeWNsZVRhc2s7XG4gICAgZXhwb3J0cy5BZ2dyZWdhdGVMaWZlY3ljbGVUYXNrID0gQWdncmVnYXRlTGlmZWN5Y2xlVGFzaztcbiAgICBleHBvcnRzLlByb21pc2VTd2FwID0gUHJvbWlzZVN3YXA7XG4gICAgZXhwb3J0cy5Qcm9taXNlVGFzayA9IFByb21pc2VUYXNrO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LnVtZC5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@aurelia/runtime/dist/index.umd.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/app.html":
/*!**********************!*\
  !*** ./src/app.html ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<template>\\n  <div>${message}</div>\\n</template>\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwLmh0bWw/NTE5YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUMsUUFBUSIsImZpbGUiOiIuL3NyYy9hcHAuaHRtbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8dGVtcGxhdGU+XFxuICA8ZGl2PiR7bWVzc2FnZX08L2Rpdj5cXG48L3RlbXBsYXRlPlxcblwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app.html\n");

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/*! exports provided: App */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"App\", function() { return App; });\n/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ \"./node_modules/@aurelia/runtime/dist/index.umd.js\");\n/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _app_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app.html */ \"./src/app.html\");\n/* harmony import */ var _app_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_app_html__WEBPACK_IMPORTED_MODULE_1__);\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\nlet App = class App {\r\n    constructor() {\r\n        this.message = \"Hello World!\";\r\n    }\r\n};\r\nApp = __decorate([\r\n    Object(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__[\"customElement\"])({ name: \"app\", template: (_app_html__WEBPACK_IMPORTED_MODULE_1___default()) })\r\n], App);\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwLnRzP2YxYjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBQWtCLFNBQUksSUFBSSxTQUFJO0FBQzlCO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ2lEO0FBQ2Y7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBYSxFQUFFLGNBQWMsNERBQVEsRUFBRTtBQUMzQztBQUNlIiwiZmlsZSI6Ii4vc3JjL2FwcC50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbmltcG9ydCB7IGN1c3RvbUVsZW1lbnQgfSBmcm9tIFwiQGF1cmVsaWEvcnVudGltZVwiO1xyXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSBcIi4vYXBwLmh0bWxcIjtcclxubGV0IEFwcCA9IGNsYXNzIEFwcCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkhlbGxvIFdvcmxkIVwiO1xyXG4gICAgfVxyXG59O1xyXG5BcHAgPSBfX2RlY29yYXRlKFtcclxuICAgIGN1c3RvbUVsZW1lbnQoeyBuYW1lOiBcImFwcFwiLCB0ZW1wbGF0ZSB9KVxyXG5dLCBBcHApO1xyXG5leHBvcnQgeyBBcHAgfTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app.ts\n");

/***/ }),

/***/ "./src/startup.ts":
/*!************************!*\
  !*** ./src/startup.ts ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _aurelia_jit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/jit */ \"./node_modules/@aurelia/jit/dist/index.umd.js\");\n/* harmony import */ var _aurelia_jit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_aurelia_jit__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ \"./node_modules/@aurelia/runtime/dist/index.umd.js\");\n/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app */ \"./src/app.ts\");\n\r\n\r\n\r\nconst au = new _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__[\"Aurelia\"]();\r\nau.register(_aurelia_jit__WEBPACK_IMPORTED_MODULE_0__[\"BasicConfiguration\"]);\r\nconst config = {\r\n    host: document.querySelector(\"app\"),\r\n    component: new _app__WEBPACK_IMPORTED_MODULE_2__[\"App\"]()\r\n};\r\nau.app(config);\r\nau.start();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3RhcnR1cC50cz85YjcyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFrRDtBQUNQO0FBQ2Y7QUFDNUIsZUFBZSx3REFBTztBQUN0QixZQUFZLCtEQUFrQjtBQUM5QjtBQUNBO0FBQ0EsbUJBQW1CLHdDQUFHO0FBQ3RCO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9zdGFydHVwLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzaWNDb25maWd1cmF0aW9uIH0gZnJvbSBcIkBhdXJlbGlhL2ppdFwiO1xyXG5pbXBvcnQgeyBBdXJlbGlhIH0gZnJvbSBcIkBhdXJlbGlhL3J1bnRpbWVcIjtcclxuaW1wb3J0IHsgQXBwIH0gZnJvbSBcIi4vYXBwXCI7XHJcbmNvbnN0IGF1ID0gbmV3IEF1cmVsaWEoKTtcclxuYXUucmVnaXN0ZXIoQmFzaWNDb25maWd1cmF0aW9uKTtcclxuY29uc3QgY29uZmlnID0ge1xyXG4gICAgaG9zdDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImFwcFwiKSxcclxuICAgIGNvbXBvbmVudDogbmV3IEFwcCgpXHJcbn07XHJcbmF1LmFwcChjb25maWcpO1xyXG5hdS5zdGFydCgpO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/startup.ts\n");

/***/ })

/******/ });